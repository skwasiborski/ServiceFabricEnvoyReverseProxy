// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/admin/v2alpha/config_dump.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Admin.V2Alpha {

  /// <summary>Holder for reflection information generated from envoy/admin/v2alpha/config_dump.proto</summary>
  public static partial class ConfigDumpReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/admin/v2alpha/config_dump.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigDumpReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiVlbnZveS9hZG1pbi92MmFscGhhL2NvbmZpZ19kdW1wLnByb3RvEhNlbnZv",
            "eS5hZG1pbi52MmFscGhhGhZlbnZveS9hcGkvdjIvY2RzLnByb3RvGhZlbnZv",
            "eS9hcGkvdjIvbGRzLnByb3RvGhZlbnZveS9hcGkvdjIvcmRzLnByb3RvGill",
            "bnZveS9jb25maWcvYm9vdHN0cmFwL3YyL2Jvb3RzdHJhcC5wcm90bxoZZ29v",
            "Z2xlL3Byb3RvYnVmL2FueS5wcm90bxoUZ29nb3Byb3RvL2dvZ28ucHJvdG8i",
            "lwEKCkNvbmZpZ0R1bXASQwoHY29uZmlncxgBIAMoCzIsLmVudm95LmFkbWlu",
            "LnYyYWxwaGEuQ29uZmlnRHVtcC5Db25maWdzRW50cnlCBMjeHwAaRAoMQ29u",
            "Zmlnc0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2YWx1ZRgCIAEoCzIULmdvb2ds",
            "ZS5wcm90b2J1Zi5Bbnk6AjgBIlQKE0Jvb3RzdHJhcENvbmZpZ0R1bXASPQoJ",
            "Ym9vdHN0cmFwGAEgASgLMiQuZW52b3kuY29uZmlnLmJvb3RzdHJhcC52Mi5C",
            "b290c3RyYXBCBMjeHwAi3wMKE0xpc3RlbmVyc0NvbmZpZ0R1bXASFAoMdmVy",
            "c2lvbl9pbmZvGAEgASgJEjYKEHN0YXRpY19saXN0ZW5lcnMYAiADKAsyFi5l",
            "bnZveS5hcGkudjIuTGlzdGVuZXJCBMjeHwASYAoYZHluYW1pY19hY3RpdmVf",
            "bGlzdGVuZXJzGAMgAygLMjguZW52b3kuYWRtaW4udjJhbHBoYS5MaXN0ZW5l",
            "cnNDb25maWdEdW1wLkR5bmFtaWNMaXN0ZW5lckIEyN4fABJhChlkeW5hbWlj",
            "X3dhcm1pbmdfbGlzdGVuZXJzGAQgAygLMjguZW52b3kuYWRtaW4udjJhbHBo",
            "YS5MaXN0ZW5lcnNDb25maWdEdW1wLkR5bmFtaWNMaXN0ZW5lckIEyN4fABJi",
            "ChpkeW5hbWljX2RyYWluaW5nX2xpc3RlbmVycxgFIAMoCzI4LmVudm95LmFk",
            "bWluLnYyYWxwaGEuTGlzdGVuZXJzQ29uZmlnRHVtcC5EeW5hbWljTGlzdGVu",
            "ZXJCBMjeHwAaUQoPRHluYW1pY0xpc3RlbmVyEhQKDHZlcnNpb25faW5mbxgB",
            "IAEoCRIoCghsaXN0ZW5lchgCIAEoCzIWLmVudm95LmFwaS52Mi5MaXN0ZW5l",
            "ciLvAgoSQ2x1c3RlcnNDb25maWdEdW1wEhQKDHZlcnNpb25faW5mbxgBIAEo",
            "CRI0Cg9zdGF0aWNfY2x1c3RlcnMYAiADKAsyFS5lbnZveS5hcGkudjIuQ2x1",
            "c3RlckIEyN4fABJdChdkeW5hbWljX2FjdGl2ZV9jbHVzdGVycxgDIAMoCzI2",
            "LmVudm95LmFkbWluLnYyYWxwaGEuQ2x1c3RlcnNDb25maWdEdW1wLkR5bmFt",
            "aWNDbHVzdGVyQgTI3h8AEl4KGGR5bmFtaWNfd2FybWluZ19jbHVzdGVycxgE",
            "IAMoCzI2LmVudm95LmFkbWluLnYyYWxwaGEuQ2x1c3RlcnNDb25maWdEdW1w",
            "LkR5bmFtaWNDbHVzdGVyQgTI3h8AGk4KDkR5bmFtaWNDbHVzdGVyEhQKDHZl",
            "cnNpb25faW5mbxgBIAEoCRImCgdjbHVzdGVyGAIgASgLMhUuZW52b3kuYXBp",
            "LnYyLkNsdXN0ZXIimwIKEFJvdXRlc0NvbmZpZ0R1bXASRAoUc3RhdGljX3Jv",
            "dXRlX2NvbmZpZ3MYAiADKAsyIC5lbnZveS5hcGkudjIuUm91dGVDb25maWd1",
            "cmF0aW9uQgTI3h8AEl0KFWR5bmFtaWNfcm91dGVfY29uZmlncxgDIAMoCzI4",
            "LmVudm95LmFkbWluLnYyYWxwaGEuUm91dGVzQ29uZmlnRHVtcC5EeW5hbWlj",
            "Um91dGVDb25maWdCBMjeHwAaYgoSRHluYW1pY1JvdXRlQ29uZmlnEhQKDHZl",
            "cnNpb25faW5mbxgBIAEoCRI2Cgxyb3V0ZV9jb25maWcYAiABKAsyIC5lbnZv",
            "eS5hcGkudjIuUm91dGVDb25maWd1cmF0aW9uYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.CdsReflection.Descriptor, global::Envoy.Api.V2.LdsReflection.Descriptor, global::Envoy.Api.V2.RdsReflection.Descriptor, global::Envoy.Config.Bootstrap.V2.BootstrapReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.ConfigDump), global::Envoy.Admin.V2Alpha.ConfigDump.Parser, new[]{ "Configs" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.BootstrapConfigDump), global::Envoy.Admin.V2Alpha.BootstrapConfigDump.Parser, new[]{ "Bootstrap" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.ListenersConfigDump), global::Envoy.Admin.V2Alpha.ListenersConfigDump.Parser, new[]{ "VersionInfo", "StaticListeners", "DynamicActiveListeners", "DynamicWarmingListeners", "DynamicDrainingListeners" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener), global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener.Parser, new[]{ "VersionInfo", "Listener" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.ClustersConfigDump), global::Envoy.Admin.V2Alpha.ClustersConfigDump.Parser, new[]{ "VersionInfo", "StaticClusters", "DynamicActiveClusters", "DynamicWarmingClusters" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster), global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster.Parser, new[]{ "VersionInfo", "Cluster" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.RoutesConfigDump), global::Envoy.Admin.V2Alpha.RoutesConfigDump.Parser, new[]{ "StaticRouteConfigs", "DynamicRouteConfigs" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig), global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig.Parser, new[]{ "VersionInfo", "RouteConfig" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The :ref:`/config_dump &lt;operations_admin_interface_config_dump>` admin endpoint uses this wrapper
  /// message to maintain and serve arbitrary configuration information from any component in Envoy.
  /// </summary>
  public sealed partial class ConfigDump : pb::IMessage<ConfigDump> {
    private static readonly pb::MessageParser<ConfigDump> _parser = new pb::MessageParser<ConfigDump>(() => new ConfigDump());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConfigDump> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Admin.V2Alpha.ConfigDumpReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigDump() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigDump(ConfigDump other) : this() {
      configs_ = other.configs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigDump Clone() {
      return new ConfigDump(this);
    }

    /// <summary>Field number for the "configs" field.</summary>
    public const int ConfigsFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_configs_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 10);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> configs_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// This map is serialized and dumped in its entirety at the
    /// :ref:`/config_dump &lt;operations_admin_interface_config_dump>` endpoint.
    ///
    /// Keys are a short descriptor of the config object they map to. The following keys (and the
    /// messages they map to) are currently supported:
    ///
    /// * *bootstrap*: :ref:`BootstrapConfigDump &lt;envoy_api_msg_admin.v2alpha.BootstrapConfigDump>`
    /// * *listeners*: :ref:`ListenersConfigDump &lt;envoy_api_msg_admin.v2alpha.ListenersConfigDump>`
    /// * *clusters*: :ref:`ClustersConfigDump &lt;envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
    /// * *routes*:  :ref:`RoutesConfigDump &lt;envoy_api_msg_admin.v2alpha.RoutesConfigDump>`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> Configs {
      get { return configs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConfigDump);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConfigDump other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Configs.Equals(other.Configs)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Configs.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      configs_.WriteTo(output, _map_configs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += configs_.CalculateSize(_map_configs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConfigDump other) {
      if (other == null) {
        return;
      }
      configs_.Add(other.configs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            configs_.AddEntriesFrom(input, _map_configs_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// This message describes the bootstrap configuration that Envoy was started with. This includes
  /// any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
  /// the static portions of an Envoy configuration by reusing the output as the bootstrap
  /// configuration for another Envoy.
  /// </summary>
  public sealed partial class BootstrapConfigDump : pb::IMessage<BootstrapConfigDump> {
    private static readonly pb::MessageParser<BootstrapConfigDump> _parser = new pb::MessageParser<BootstrapConfigDump>(() => new BootstrapConfigDump());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BootstrapConfigDump> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Admin.V2Alpha.ConfigDumpReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrapConfigDump() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrapConfigDump(BootstrapConfigDump other) : this() {
      Bootstrap = other.bootstrap_ != null ? other.Bootstrap.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrapConfigDump Clone() {
      return new BootstrapConfigDump(this);
    }

    /// <summary>Field number for the "bootstrap" field.</summary>
    public const int BootstrapFieldNumber = 1;
    private global::Envoy.Config.Bootstrap.V2.Bootstrap bootstrap_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Bootstrap.V2.Bootstrap Bootstrap {
      get { return bootstrap_; }
      set {
        bootstrap_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BootstrapConfigDump);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BootstrapConfigDump other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Bootstrap, other.Bootstrap)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (bootstrap_ != null) hash ^= Bootstrap.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (bootstrap_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Bootstrap);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (bootstrap_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Bootstrap);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BootstrapConfigDump other) {
      if (other == null) {
        return;
      }
      if (other.bootstrap_ != null) {
        if (bootstrap_ == null) {
          bootstrap_ = new global::Envoy.Config.Bootstrap.V2.Bootstrap();
        }
        Bootstrap.MergeFrom(other.Bootstrap);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (bootstrap_ == null) {
              bootstrap_ = new global::Envoy.Config.Bootstrap.V2.Bootstrap();
            }
            input.ReadMessage(bootstrap_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Envoy's listener manager fills this message with all currently known listeners. Listener
  /// configuration information can be used to recreate an Envoy configuration by populating all
  /// listeners as static listeners or by returning them in a LDS response.
  /// </summary>
  public sealed partial class ListenersConfigDump : pb::IMessage<ListenersConfigDump> {
    private static readonly pb::MessageParser<ListenersConfigDump> _parser = new pb::MessageParser<ListenersConfigDump>(() => new ListenersConfigDump());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListenersConfigDump> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Admin.V2Alpha.ConfigDumpReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListenersConfigDump() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListenersConfigDump(ListenersConfigDump other) : this() {
      versionInfo_ = other.versionInfo_;
      staticListeners_ = other.staticListeners_.Clone();
      dynamicActiveListeners_ = other.dynamicActiveListeners_.Clone();
      dynamicWarmingListeners_ = other.dynamicWarmingListeners_.Clone();
      dynamicDrainingListeners_ = other.dynamicDrainingListeners_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListenersConfigDump Clone() {
      return new ListenersConfigDump(this);
    }

    /// <summary>Field number for the "version_info" field.</summary>
    public const int VersionInfoFieldNumber = 1;
    private string versionInfo_ = "";
    /// <summary>
    /// This is the :ref:`version_info &lt;envoy_api_field_DiscoveryResponse.version_info>` in the
    /// last processed LDS discovery response. If there are only static bootstrap listeners, this field
    /// will be "".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VersionInfo {
      get { return versionInfo_; }
      set {
        versionInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "static_listeners" field.</summary>
    public const int StaticListenersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Listener> _repeated_staticListeners_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Api.V2.Listener.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Listener> staticListeners_ = new pbc::RepeatedField<global::Envoy.Api.V2.Listener>();
    /// <summary>
    /// The statically loaded listener configs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Listener> StaticListeners {
      get { return staticListeners_; }
    }

    /// <summary>Field number for the "dynamic_active_listeners" field.</summary>
    public const int DynamicActiveListenersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> _repeated_dynamicActiveListeners_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> dynamicActiveListeners_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener>();
    /// <summary>
    /// The dynamically loaded active listeners. These are listeners that are available to service
    /// data plane traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> DynamicActiveListeners {
      get { return dynamicActiveListeners_; }
    }

    /// <summary>Field number for the "dynamic_warming_listeners" field.</summary>
    public const int DynamicWarmingListenersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> _repeated_dynamicWarmingListeners_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> dynamicWarmingListeners_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener>();
    /// <summary>
    /// The dynamically loaded warming listeners. These are listeners that are currently undergoing
    /// warming in preparation to service data plane traffic. Note that if attempting to recreate an
    /// Envoy configuration from a configuration dump, the warming listeners should generally be
    /// discarded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> DynamicWarmingListeners {
      get { return dynamicWarmingListeners_; }
    }

    /// <summary>Field number for the "dynamic_draining_listeners" field.</summary>
    public const int DynamicDrainingListenersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> _repeated_dynamicDrainingListeners_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> dynamicDrainingListeners_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener>();
    /// <summary>
    /// The dynamically loaded draining listeners. These are listeners that are currently undergoing
    /// draining in preparation to stop servicing data plane traffic. Note that if attempting to
    /// recreate an Envoy configuration from a configuration dump, the draining listeners should
    /// generally be discarded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ListenersConfigDump.Types.DynamicListener> DynamicDrainingListeners {
      get { return dynamicDrainingListeners_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListenersConfigDump);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListenersConfigDump other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VersionInfo != other.VersionInfo) return false;
      if(!staticListeners_.Equals(other.staticListeners_)) return false;
      if(!dynamicActiveListeners_.Equals(other.dynamicActiveListeners_)) return false;
      if(!dynamicWarmingListeners_.Equals(other.dynamicWarmingListeners_)) return false;
      if(!dynamicDrainingListeners_.Equals(other.dynamicDrainingListeners_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VersionInfo.Length != 0) hash ^= VersionInfo.GetHashCode();
      hash ^= staticListeners_.GetHashCode();
      hash ^= dynamicActiveListeners_.GetHashCode();
      hash ^= dynamicWarmingListeners_.GetHashCode();
      hash ^= dynamicDrainingListeners_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VersionInfo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VersionInfo);
      }
      staticListeners_.WriteTo(output, _repeated_staticListeners_codec);
      dynamicActiveListeners_.WriteTo(output, _repeated_dynamicActiveListeners_codec);
      dynamicWarmingListeners_.WriteTo(output, _repeated_dynamicWarmingListeners_codec);
      dynamicDrainingListeners_.WriteTo(output, _repeated_dynamicDrainingListeners_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VersionInfo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VersionInfo);
      }
      size += staticListeners_.CalculateSize(_repeated_staticListeners_codec);
      size += dynamicActiveListeners_.CalculateSize(_repeated_dynamicActiveListeners_codec);
      size += dynamicWarmingListeners_.CalculateSize(_repeated_dynamicWarmingListeners_codec);
      size += dynamicDrainingListeners_.CalculateSize(_repeated_dynamicDrainingListeners_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListenersConfigDump other) {
      if (other == null) {
        return;
      }
      if (other.VersionInfo.Length != 0) {
        VersionInfo = other.VersionInfo;
      }
      staticListeners_.Add(other.staticListeners_);
      dynamicActiveListeners_.Add(other.dynamicActiveListeners_);
      dynamicWarmingListeners_.Add(other.dynamicWarmingListeners_);
      dynamicDrainingListeners_.Add(other.dynamicDrainingListeners_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VersionInfo = input.ReadString();
            break;
          }
          case 18: {
            staticListeners_.AddEntriesFrom(input, _repeated_staticListeners_codec);
            break;
          }
          case 26: {
            dynamicActiveListeners_.AddEntriesFrom(input, _repeated_dynamicActiveListeners_codec);
            break;
          }
          case 34: {
            dynamicWarmingListeners_.AddEntriesFrom(input, _repeated_dynamicWarmingListeners_codec);
            break;
          }
          case 42: {
            dynamicDrainingListeners_.AddEntriesFrom(input, _repeated_dynamicDrainingListeners_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ListenersConfigDump message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes a dynamically loaded cluster via the LDS API.
      /// </summary>
      public sealed partial class DynamicListener : pb::IMessage<DynamicListener> {
        private static readonly pb::MessageParser<DynamicListener> _parser = new pb::MessageParser<DynamicListener>(() => new DynamicListener());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DynamicListener> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Admin.V2Alpha.ListenersConfigDump.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicListener() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicListener(DynamicListener other) : this() {
          versionInfo_ = other.versionInfo_;
          Listener = other.listener_ != null ? other.Listener.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicListener Clone() {
          return new DynamicListener(this);
        }

        /// <summary>Field number for the "version_info" field.</summary>
        public const int VersionInfoFieldNumber = 1;
        private string versionInfo_ = "";
        /// <summary>
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info &lt;envoy_api_field_DiscoveryResponse.version_info>` field at the time
        /// that the listener was loaded. In the future, discrete per-listener versions may be supported
        /// by the API.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string VersionInfo {
          get { return versionInfo_; }
          set {
            versionInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "listener" field.</summary>
        public const int ListenerFieldNumber = 2;
        private global::Envoy.Api.V2.Listener listener_;
        /// <summary>
        /// The listener config.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Listener Listener {
          get { return listener_; }
          set {
            listener_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DynamicListener);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DynamicListener other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (VersionInfo != other.VersionInfo) return false;
          if (!object.Equals(Listener, other.Listener)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (VersionInfo.Length != 0) hash ^= VersionInfo.GetHashCode();
          if (listener_ != null) hash ^= Listener.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (VersionInfo.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(VersionInfo);
          }
          if (listener_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Listener);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (VersionInfo.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VersionInfo);
          }
          if (listener_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Listener);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DynamicListener other) {
          if (other == null) {
            return;
          }
          if (other.VersionInfo.Length != 0) {
            VersionInfo = other.VersionInfo;
          }
          if (other.listener_ != null) {
            if (listener_ == null) {
              listener_ = new global::Envoy.Api.V2.Listener();
            }
            Listener.MergeFrom(other.Listener);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                VersionInfo = input.ReadString();
                break;
              }
              case 18: {
                if (listener_ == null) {
                  listener_ = new global::Envoy.Api.V2.Listener();
                }
                input.ReadMessage(listener_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Envoy's cluster manager fills this message with all currently known clusters. Cluster
  /// configuration information can be used to recreate an Envoy configuration by populating all
  /// clusters as static clusters or by returning them in a CDS response.
  /// </summary>
  public sealed partial class ClustersConfigDump : pb::IMessage<ClustersConfigDump> {
    private static readonly pb::MessageParser<ClustersConfigDump> _parser = new pb::MessageParser<ClustersConfigDump>(() => new ClustersConfigDump());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ClustersConfigDump> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Admin.V2Alpha.ConfigDumpReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClustersConfigDump() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClustersConfigDump(ClustersConfigDump other) : this() {
      versionInfo_ = other.versionInfo_;
      staticClusters_ = other.staticClusters_.Clone();
      dynamicActiveClusters_ = other.dynamicActiveClusters_.Clone();
      dynamicWarmingClusters_ = other.dynamicWarmingClusters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClustersConfigDump Clone() {
      return new ClustersConfigDump(this);
    }

    /// <summary>Field number for the "version_info" field.</summary>
    public const int VersionInfoFieldNumber = 1;
    private string versionInfo_ = "";
    /// <summary>
    /// This is the :ref:`version_info &lt;envoy_api_field_DiscoveryResponse.version_info>` in the
    /// last processed CDS discovery response. If there are only static bootstrap clusters, this field
    /// will be "".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VersionInfo {
      get { return versionInfo_; }
      set {
        versionInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "static_clusters" field.</summary>
    public const int StaticClustersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster> _repeated_staticClusters_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Api.V2.Cluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster> staticClusters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster>();
    /// <summary>
    /// The statically loaded cluster configs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Cluster> StaticClusters {
      get { return staticClusters_; }
    }

    /// <summary>Field number for the "dynamic_active_clusters" field.</summary>
    public const int DynamicActiveClustersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> _repeated_dynamicActiveClusters_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> dynamicActiveClusters_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster>();
    /// <summary>
    /// The dynamically loaded active clusters. These are clusters that are available to service
    /// data plane traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> DynamicActiveClusters {
      get { return dynamicActiveClusters_; }
    }

    /// <summary>Field number for the "dynamic_warming_clusters" field.</summary>
    public const int DynamicWarmingClustersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> _repeated_dynamicWarmingClusters_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> dynamicWarmingClusters_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster>();
    /// <summary>
    /// The dynamically loaded warming clusters. These are clusters that are currently undergoing
    /// warming in preparation to service data plane traffic. Note that if attempting to recreate an
    /// Envoy configuration from a configuration dump, the warming clusters should generally be
    /// discarded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.ClustersConfigDump.Types.DynamicCluster> DynamicWarmingClusters {
      get { return dynamicWarmingClusters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ClustersConfigDump);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ClustersConfigDump other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VersionInfo != other.VersionInfo) return false;
      if(!staticClusters_.Equals(other.staticClusters_)) return false;
      if(!dynamicActiveClusters_.Equals(other.dynamicActiveClusters_)) return false;
      if(!dynamicWarmingClusters_.Equals(other.dynamicWarmingClusters_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VersionInfo.Length != 0) hash ^= VersionInfo.GetHashCode();
      hash ^= staticClusters_.GetHashCode();
      hash ^= dynamicActiveClusters_.GetHashCode();
      hash ^= dynamicWarmingClusters_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VersionInfo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VersionInfo);
      }
      staticClusters_.WriteTo(output, _repeated_staticClusters_codec);
      dynamicActiveClusters_.WriteTo(output, _repeated_dynamicActiveClusters_codec);
      dynamicWarmingClusters_.WriteTo(output, _repeated_dynamicWarmingClusters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VersionInfo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VersionInfo);
      }
      size += staticClusters_.CalculateSize(_repeated_staticClusters_codec);
      size += dynamicActiveClusters_.CalculateSize(_repeated_dynamicActiveClusters_codec);
      size += dynamicWarmingClusters_.CalculateSize(_repeated_dynamicWarmingClusters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ClustersConfigDump other) {
      if (other == null) {
        return;
      }
      if (other.VersionInfo.Length != 0) {
        VersionInfo = other.VersionInfo;
      }
      staticClusters_.Add(other.staticClusters_);
      dynamicActiveClusters_.Add(other.dynamicActiveClusters_);
      dynamicWarmingClusters_.Add(other.dynamicWarmingClusters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VersionInfo = input.ReadString();
            break;
          }
          case 18: {
            staticClusters_.AddEntriesFrom(input, _repeated_staticClusters_codec);
            break;
          }
          case 26: {
            dynamicActiveClusters_.AddEntriesFrom(input, _repeated_dynamicActiveClusters_codec);
            break;
          }
          case 34: {
            dynamicWarmingClusters_.AddEntriesFrom(input, _repeated_dynamicWarmingClusters_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ClustersConfigDump message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes a dynamically loaded cluster via the CDS API.
      /// </summary>
      public sealed partial class DynamicCluster : pb::IMessage<DynamicCluster> {
        private static readonly pb::MessageParser<DynamicCluster> _parser = new pb::MessageParser<DynamicCluster>(() => new DynamicCluster());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DynamicCluster> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Admin.V2Alpha.ClustersConfigDump.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicCluster() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicCluster(DynamicCluster other) : this() {
          versionInfo_ = other.versionInfo_;
          Cluster = other.cluster_ != null ? other.Cluster.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicCluster Clone() {
          return new DynamicCluster(this);
        }

        /// <summary>Field number for the "version_info" field.</summary>
        public const int VersionInfoFieldNumber = 1;
        private string versionInfo_ = "";
        /// <summary>
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info &lt;envoy_api_field_DiscoveryResponse.version_info>` field at the time
        /// that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
        /// the API.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string VersionInfo {
          get { return versionInfo_; }
          set {
            versionInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "cluster" field.</summary>
        public const int ClusterFieldNumber = 2;
        private global::Envoy.Api.V2.Cluster cluster_;
        /// <summary>
        /// The cluster config.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster Cluster {
          get { return cluster_; }
          set {
            cluster_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DynamicCluster);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DynamicCluster other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (VersionInfo != other.VersionInfo) return false;
          if (!object.Equals(Cluster, other.Cluster)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (VersionInfo.Length != 0) hash ^= VersionInfo.GetHashCode();
          if (cluster_ != null) hash ^= Cluster.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (VersionInfo.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(VersionInfo);
          }
          if (cluster_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Cluster);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (VersionInfo.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VersionInfo);
          }
          if (cluster_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cluster);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DynamicCluster other) {
          if (other == null) {
            return;
          }
          if (other.VersionInfo.Length != 0) {
            VersionInfo = other.VersionInfo;
          }
          if (other.cluster_ != null) {
            if (cluster_ == null) {
              cluster_ = new global::Envoy.Api.V2.Cluster();
            }
            Cluster.MergeFrom(other.Cluster);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                VersionInfo = input.ReadString();
                break;
              }
              case 18: {
                if (cluster_ == null) {
                  cluster_ = new global::Envoy.Api.V2.Cluster();
                }
                input.ReadMessage(cluster_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Envoy's RDS implementation fills this message with all currently loaded routes, as described by
  /// their RouteConfiguration objects. Static routes configured in the bootstrap configuration are
  /// separated from those configured dynamically via RDS. Route configuration information can be used
  /// to recreate an Envoy configuration by populating all routes as static routes or by returning them
  /// in RDS responses.
  /// </summary>
  public sealed partial class RoutesConfigDump : pb::IMessage<RoutesConfigDump> {
    private static readonly pb::MessageParser<RoutesConfigDump> _parser = new pb::MessageParser<RoutesConfigDump>(() => new RoutesConfigDump());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RoutesConfigDump> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Admin.V2Alpha.ConfigDumpReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoutesConfigDump() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoutesConfigDump(RoutesConfigDump other) : this() {
      staticRouteConfigs_ = other.staticRouteConfigs_.Clone();
      dynamicRouteConfigs_ = other.dynamicRouteConfigs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoutesConfigDump Clone() {
      return new RoutesConfigDump(this);
    }

    /// <summary>Field number for the "static_route_configs" field.</summary>
    public const int StaticRouteConfigsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.RouteConfiguration> _repeated_staticRouteConfigs_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Api.V2.RouteConfiguration.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.RouteConfiguration> staticRouteConfigs_ = new pbc::RepeatedField<global::Envoy.Api.V2.RouteConfiguration>();
    /// <summary>
    /// The statically loaded route configs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.RouteConfiguration> StaticRouteConfigs {
      get { return staticRouteConfigs_; }
    }

    /// <summary>Field number for the "dynamic_route_configs" field.</summary>
    public const int DynamicRouteConfigsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig> _repeated_dynamicRouteConfigs_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig> dynamicRouteConfigs_ = new pbc::RepeatedField<global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig>();
    /// <summary>
    /// The dynamically loaded route configs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Admin.V2Alpha.RoutesConfigDump.Types.DynamicRouteConfig> DynamicRouteConfigs {
      get { return dynamicRouteConfigs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RoutesConfigDump);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RoutesConfigDump other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!staticRouteConfigs_.Equals(other.staticRouteConfigs_)) return false;
      if(!dynamicRouteConfigs_.Equals(other.dynamicRouteConfigs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= staticRouteConfigs_.GetHashCode();
      hash ^= dynamicRouteConfigs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      staticRouteConfigs_.WriteTo(output, _repeated_staticRouteConfigs_codec);
      dynamicRouteConfigs_.WriteTo(output, _repeated_dynamicRouteConfigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += staticRouteConfigs_.CalculateSize(_repeated_staticRouteConfigs_codec);
      size += dynamicRouteConfigs_.CalculateSize(_repeated_dynamicRouteConfigs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RoutesConfigDump other) {
      if (other == null) {
        return;
      }
      staticRouteConfigs_.Add(other.staticRouteConfigs_);
      dynamicRouteConfigs_.Add(other.dynamicRouteConfigs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            staticRouteConfigs_.AddEntriesFrom(input, _repeated_staticRouteConfigs_codec);
            break;
          }
          case 26: {
            dynamicRouteConfigs_.AddEntriesFrom(input, _repeated_dynamicRouteConfigs_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RoutesConfigDump message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class DynamicRouteConfig : pb::IMessage<DynamicRouteConfig> {
        private static readonly pb::MessageParser<DynamicRouteConfig> _parser = new pb::MessageParser<DynamicRouteConfig>(() => new DynamicRouteConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DynamicRouteConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Admin.V2Alpha.RoutesConfigDump.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicRouteConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicRouteConfig(DynamicRouteConfig other) : this() {
          versionInfo_ = other.versionInfo_;
          RouteConfig = other.routeConfig_ != null ? other.RouteConfig.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DynamicRouteConfig Clone() {
          return new DynamicRouteConfig(this);
        }

        /// <summary>Field number for the "version_info" field.</summary>
        public const int VersionInfoFieldNumber = 1;
        private string versionInfo_ = "";
        /// <summary>
        /// This is the per-resource version information. This version is currently taken from the
        /// :ref:`version_info &lt;envoy_api_field_DiscoveryResponse.version_info>` field at the time that
        /// the route configuration was loaded.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string VersionInfo {
          get { return versionInfo_; }
          set {
            versionInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "route_config" field.</summary>
        public const int RouteConfigFieldNumber = 2;
        private global::Envoy.Api.V2.RouteConfiguration routeConfig_;
        /// <summary>
        /// The route config.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.RouteConfiguration RouteConfig {
          get { return routeConfig_; }
          set {
            routeConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DynamicRouteConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DynamicRouteConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (VersionInfo != other.VersionInfo) return false;
          if (!object.Equals(RouteConfig, other.RouteConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (VersionInfo.Length != 0) hash ^= VersionInfo.GetHashCode();
          if (routeConfig_ != null) hash ^= RouteConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (VersionInfo.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(VersionInfo);
          }
          if (routeConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(RouteConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (VersionInfo.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VersionInfo);
          }
          if (routeConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DynamicRouteConfig other) {
          if (other == null) {
            return;
          }
          if (other.VersionInfo.Length != 0) {
            VersionInfo = other.VersionInfo;
          }
          if (other.routeConfig_ != null) {
            if (routeConfig_ == null) {
              routeConfig_ = new global::Envoy.Api.V2.RouteConfiguration();
            }
            RouteConfig.MergeFrom(other.RouteConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                VersionInfo = input.ReadString();
                break;
              }
              case 18: {
                if (routeConfig_ == null) {
                  routeConfig_ = new global::Envoy.Api.V2.RouteConfiguration();
                }
                input.ReadMessage(routeConfig_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
