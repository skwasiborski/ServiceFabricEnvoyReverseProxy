// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/cds.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from envoy/api/v2/cds.proto</summary>
  public static partial class CdsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/cds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZlbnZveS9hcGkvdjIvY2RzLnByb3RvEgxlbnZveS5hcGkudjIaH2Vudm95",
            "L2FwaS92Mi9jb3JlL2FkZHJlc3MucHJvdG8aHGVudm95L2FwaS92Mi9hdXRo",
            "L2NlcnQucHJvdG8aHGVudm95L2FwaS92Mi9jb3JlL2Jhc2UucHJvdG8aJWVu",
            "dm95L2FwaS92Mi9jb3JlL2NvbmZpZ19zb3VyY2UucHJvdG8aHGVudm95L2Fw",
            "aS92Mi9kaXNjb3ZlcnkucHJvdG8aJGVudm95L2FwaS92Mi9jb3JlL2hlYWx0",
            "aF9jaGVjay5wcm90bxogZW52b3kvYXBpL3YyL2NvcmUvcHJvdG9jb2wucHJv",
            "dG8aKmVudm95L2FwaS92Mi9jbHVzdGVyL2NpcmN1aXRfYnJlYWtlci5wcm90",
            "bxosZW52b3kvYXBpL3YyL2NsdXN0ZXIvb3V0bGllcl9kZXRlY3Rpb24ucHJv",
            "dG8aFmVudm95L2FwaS92Mi9lZHMucHJvdG8aGGVudm95L3R5cGUvcGVyY2Vu",
            "dC5wcm90bxocZ29vZ2xlL2FwaS9hbm5vdGF0aW9ucy5wcm90bxoeZ29vZ2xl",
            "L3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGhxnb29nbGUvcHJvdG9idWYvc3Ry",
            "dWN0LnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3Zh",
            "bGlkYXRlL3ZhbGlkYXRlLnByb3RvGhRnb2dvcHJvdG8vZ29nby5wcm90byLe",
            "GgoHQ2x1c3RlchIXCgRuYW1lGAEgASgJQgm66cADBHICIAESFQoNYWx0X3N0",
            "YXRfbmFtZRgcIAEoCRI9CgR0eXBlGAIgASgOMiMuZW52b3kuYXBpLnYyLkNs",
            "dXN0ZXIuRGlzY292ZXJ5VHlwZUIKuunAAwWCAQIQARJCChJlZHNfY2x1c3Rl",
            "cl9jb25maWcYAyABKAsyJi5lbnZveS5hcGkudjIuQ2x1c3Rlci5FZHNDbHVz",
            "dGVyQ29uZmlnEkYKD2Nvbm5lY3RfdGltZW91dBgEIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbkISuunAAwWqAQIqAJjfHwHI3h8AEkcKIXBlcl9j",
            "b25uZWN0aW9uX2J1ZmZlcl9saW1pdF9ieXRlcxgFIAEoCzIcLmdvb2dsZS5w",
            "cm90b2J1Zi5VSW50MzJWYWx1ZRI9CglsYl9wb2xpY3kYBiABKA4yHi5lbnZv",
            "eS5hcGkudjIuQ2x1c3Rlci5MYlBvbGljeUIKuunAAwWCAQIQARIpCgVob3N0",
            "cxgHIAMoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3MSPAoPbG9hZF9h",
            "c3NpZ25tZW50GCEgASgLMiMuZW52b3kuYXBpLnYyLkNsdXN0ZXJMb2FkQXNz",
            "aWdubWVudBI1Cg1oZWFsdGhfY2hlY2tzGAggAygLMh4uZW52b3kuYXBpLnYy",
            "LmNvcmUuSGVhbHRoQ2hlY2sSQQobbWF4X3JlcXVlc3RzX3Blcl9jb25uZWN0",
            "aW9uGAkgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEj8KEGNp",
            "cmN1aXRfYnJlYWtlcnMYCiABKAsyJS5lbnZveS5hcGkudjIuY2x1c3Rlci5D",
            "aXJjdWl0QnJlYWtlcnMSOgoLdGxzX2NvbnRleHQYCyABKAsyJS5lbnZveS5h",
            "cGkudjIuYXV0aC5VcHN0cmVhbVRsc0NvbnRleHQSTAocY29tbW9uX2h0dHBf",
            "cHJvdG9jb2xfb3B0aW9ucxgdIAEoCzImLmVudm95LmFwaS52Mi5jb3JlLkh0",
            "dHBQcm90b2NvbE9wdGlvbnMSRgoVaHR0cF9wcm90b2NvbF9vcHRpb25zGA0g",
            "ASgLMicuZW52b3kuYXBpLnYyLmNvcmUuSHR0cDFQcm90b2NvbE9wdGlvbnMS",
            "RwoWaHR0cDJfcHJvdG9jb2xfb3B0aW9ucxgOIAEoCzInLmVudm95LmFwaS52",
            "Mi5jb3JlLkh0dHAyUHJvdG9jb2xPcHRpb25zEkMKEGRuc19yZWZyZXNoX3Jh",
            "dGUYECABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CDrrpwAMFqgEC",
            "KgCY3x8BEkwKEWRuc19sb29rdXBfZmFtaWx5GBEgASgOMiUuZW52b3kuYXBp",
            "LnYyLkNsdXN0ZXIuRG5zTG9va3VwRmFtaWx5Qgq66cADBYIBAhABEjEKDWRu",
            "c19yZXNvbHZlcnMYEiADKAsyGi5lbnZveS5hcGkudjIuY29yZS5BZGRyZXNz",
            "EkEKEW91dGxpZXJfZGV0ZWN0aW9uGBMgASgLMiYuZW52b3kuYXBpLnYyLmNs",
            "dXN0ZXIuT3V0bGllckRldGVjdGlvbhJDChBjbGVhbnVwX2ludGVydmFsGBQg",
            "ASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQg666cADBaoBAioAmN8f",
            "ARI7ChR1cHN0cmVhbV9iaW5kX2NvbmZpZxgVIAEoCzIdLmVudm95LmFwaS52",
            "Mi5jb3JlLkJpbmRDb25maWcSPgoQbGJfc3Vic2V0X2NvbmZpZxgWIAEoCzIk",
            "LmVudm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnEkUKE3Jpbmdf",
            "aGFzaF9sYl9jb25maWcYFyABKAsyJi5lbnZveS5hcGkudjIuQ2x1c3Rlci5S",
            "aW5nSGFzaExiQ29uZmlnSAASPgoQY29tbW9uX2xiX2NvbmZpZxgbIAEoCzIk",
            "LmVudm95LmFwaS52Mi5DbHVzdGVyLkNvbW1vbkxiQ29uZmlnEjwKEHRyYW5z",
            "cG9ydF9zb2NrZXQYGCABKAsyIi5lbnZveS5hcGkudjIuY29yZS5UcmFuc3Bv",
            "cnRTb2NrZXQSLQoIbWV0YWRhdGEYGSABKAsyGy5lbnZveS5hcGkudjIuY29y",
            "ZS5NZXRhZGF0YRJKChJwcm90b2NvbF9zZWxlY3Rpb24YGiABKA4yLi5lbnZv",
            "eS5hcGkudjIuQ2x1c3Rlci5DbHVzdGVyUHJvdG9jb2xTZWxlY3Rpb24STAob",
            "dXBzdHJlYW1fY29ubmVjdGlvbl9vcHRpb25zGB4gASgLMicuZW52b3kuYXBp",
            "LnYyLlVwc3RyZWFtQ29ubmVjdGlvbk9wdGlvbnMSMAooY2xvc2VfY29ubmVj",
            "dGlvbnNfb25faG9zdF9oZWFsdGhfZmFpbHVyZRgfIAEoCBIpCiFkcmFpbl9j",
            "b25uZWN0aW9uc19vbl9ob3N0X3JlbW92YWwYICABKAgaXQoQRWRzQ2x1c3Rl",
            "ckNvbmZpZxIzCgplZHNfY29uZmlnGAEgASgLMh8uZW52b3kuYXBpLnYyLmNv",
            "cmUuQ29uZmlnU291cmNlEhQKDHNlcnZpY2VfbmFtZRgCIAEoCRrnAgoOTGJT",
            "dWJzZXRDb25maWcSYAoPZmFsbGJhY2tfcG9saWN5GAEgASgOMjsuZW52b3ku",
            "YXBpLnYyLkNsdXN0ZXIuTGJTdWJzZXRDb25maWcuTGJTdWJzZXRGYWxsYmFj",
            "a1BvbGljeUIKuunAAwWCAQIQARIvCg5kZWZhdWx0X3N1YnNldBgCIAEoCzIX",
            "Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSTwoQc3Vic2V0X3NlbGVjdG9ycxgD",
            "IAMoCzI1LmVudm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxi",
            "U3Vic2V0U2VsZWN0b3IaIAoQTGJTdWJzZXRTZWxlY3RvchIMCgRrZXlzGAEg",
            "AygJIk8KFkxiU3Vic2V0RmFsbGJhY2tQb2xpY3kSDwoLTk9fRkFMTEJBQ0sQ",
            "ABIQCgxBTllfRU5EUE9JTlQQARISCg5ERUZBVUxUX1NVQlNFVBACGusBChBS",
            "aW5nSGFzaExiQ29uZmlnEkUKEW1pbmltdW1fcmluZ19zaXplGAEgASgLMhwu",
            "Z29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlQgy66cADBzIFGICAgAQSTgoN",
            "ZGVwcmVjYXRlZF92MRgCIAEoCzIzLmVudm95LmFwaS52Mi5DbHVzdGVyLlJp",
            "bmdIYXNoTGJDb25maWcuRGVwcmVjYXRlZFYxQgIYARpACgxEZXByZWNhdGVk",
            "VjESMAoMdXNlX3N0ZF9oYXNoGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJv",
            "b2xWYWx1ZRq4AwoOQ29tbW9uTGJDb25maWcSNAoXaGVhbHRoeV9wYW5pY190",
            "aHJlc2hvbGQYASABKAsyEy5lbnZveS50eXBlLlBlcmNlbnQSVgoUem9uZV9h",
            "d2FyZV9sYl9jb25maWcYAiABKAsyNi5lbnZveS5hcGkudjIuQ2x1c3Rlci5D",
            "b21tb25MYkNvbmZpZy5ab25lQXdhcmVMYkNvbmZpZ0gAEmQKG2xvY2FsaXR5",
            "X3dlaWdodGVkX2xiX2NvbmZpZxgDIAEoCzI9LmVudm95LmFwaS52Mi5DbHVz",
            "dGVyLkNvbW1vbkxiQ29uZmlnLkxvY2FsaXR5V2VpZ2h0ZWRMYkNvbmZpZ0gA",
            "GnkKEVpvbmVBd2FyZUxiQ29uZmlnEiwKD3JvdXRpbmdfZW5hYmxlZBgBIAEo",
            "CzITLmVudm95LnR5cGUuUGVyY2VudBI2ChBtaW5fY2x1c3Rlcl9zaXplGAIg",
            "ASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlGhoKGExvY2FsaXR5",
            "V2VpZ2h0ZWRMYkNvbmZpZ0IbChlsb2NhbGl0eV9jb25maWdfc3BlY2lmaWVy",
            "IlcKDURpc2NvdmVyeVR5cGUSCgoGU1RBVElDEAASDgoKU1RSSUNUX0ROUxAB",
            "Eg8KC0xPR0lDQUxfRE5TEAISBwoDRURTEAMSEAoMT1JJR0lOQUxfRFNUEAQi",
            "agoITGJQb2xpY3kSDwoLUk9VTkRfUk9CSU4QABIRCg1MRUFTVF9SRVFVRVNU",
            "EAESDQoJUklOR19IQVNIEAISCgoGUkFORE9NEAMSEwoPT1JJR0lOQUxfRFNU",
            "X0xCEAQSCgoGTUFHTEVWEAUiNQoPRG5zTG9va3VwRmFtaWx5EggKBEFVVE8Q",
            "ABILCgdWNF9PTkxZEAESCwoHVjZfT05MWRACIlQKGENsdXN0ZXJQcm90b2Nv",
            "bFNlbGVjdGlvbhIbChdVU0VfQ09ORklHVVJFRF9QUk9UT0NPTBAAEhsKF1VT",
            "RV9ET1dOU1RSRUFNX1BST1RPQ09MEAFCCwoJbGJfY29uZmlnSgQIDBANSgQI",
            "DxAQIkgKElVwc3RyZWFtQmluZENvbmZpZxIyCg5zb3VyY2VfYWRkcmVzcxgB",
            "IAEoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3MiUwoZVXBzdHJlYW1D",
            "b25uZWN0aW9uT3B0aW9ucxI2Cg10Y3Bfa2VlcGFsaXZlGAEgASgLMh8uZW52",
            "b3kuYXBpLnYyLmNvcmUuVGNwS2VlcGFsaXZlMucBChdDbHVzdGVyRGlzY292",
            "ZXJ5U2VydmljZRJXCg5TdHJlYW1DbHVzdGVycxIeLmVudm95LmFwaS52Mi5E",
            "aXNjb3ZlcnlSZXF1ZXN0Gh8uZW52b3kuYXBpLnYyLkRpc2NvdmVyeVJlc3Bv",
            "bnNlIgAoATABEnMKDUZldGNoQ2x1c3RlcnMSHi5lbnZveS5hcGkudjIuRGlz",
            "Y292ZXJ5UmVxdWVzdBofLmVudm95LmFwaS52Mi5EaXNjb3ZlcnlSZXNwb25z",
            "ZSIhgtPkkwIbIhYvdjIvZGlzY292ZXJ5OmNsdXN0ZXJzOgEqQgeIAQGo4h4B",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Auth.CertReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V2.DiscoveryReflection.Descriptor, global::Envoy.Api.V2.Core.HealthCheckReflection.Descriptor, global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.CircuitBreakerReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.OutlierDetectionReflection.Descriptor, global::Envoy.Api.V2.EdsReflection.Descriptor, global::Envoy.Type.PercentReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster), global::Envoy.Api.V2.Cluster.Parser, new[]{ "Name", "AltStatName", "Type", "EdsClusterConfig", "ConnectTimeout", "PerConnectionBufferLimitBytes", "LbPolicy", "Hosts", "LoadAssignment", "HealthChecks", "MaxRequestsPerConnection", "CircuitBreakers", "TlsContext", "CommonHttpProtocolOptions", "HttpProtocolOptions", "Http2ProtocolOptions", "DnsRefreshRate", "DnsLookupFamily", "DnsResolvers", "OutlierDetection", "CleanupInterval", "UpstreamBindConfig", "LbSubsetConfig", "RingHashLbConfig", "CommonLbConfig", "TransportSocket", "Metadata", "ProtocolSelection", "UpstreamConnectionOptions", "CloseConnectionsOnHostHealthFailure", "DrainConnectionsOnHostRemoval" }, new[]{ "LbConfig" }, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.DiscoveryType), typeof(global::Envoy.Api.V2.Cluster.Types.LbPolicy), typeof(global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily), typeof(global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig), global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig.Parser, new[]{ "EdsConfig", "ServiceName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Parser, new[]{ "FallbackPolicy", "DefaultSubset", "SubsetSelectors" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser, new[]{ "Keys" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Parser, new[]{ "MinimumRingSize", "DeprecatedV1" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1.Parser, new[]{ "UseStdHash" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Parser, new[]{ "HealthyPanicThreshold", "ZoneAwareLbConfig", "LocalityWeightedLbConfig" }, new[]{ "LocalityConfigSpecifier" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig.Parser, new[]{ "RoutingEnabled", "MinClusterSize" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig.Parser, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamBindConfig), global::Envoy.Api.V2.UpstreamBindConfig.Parser, new[]{ "SourceAddress" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamConnectionOptions), global::Envoy.Api.V2.UpstreamConnectionOptions.Parser, new[]{ "TcpKeepalive" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a single upstream cluster.
  /// [#comment:next free field: 34]
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster> {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster(Cluster other) : this() {
      name_ = other.name_;
      altStatName_ = other.altStatName_;
      type_ = other.type_;
      EdsClusterConfig = other.edsClusterConfig_ != null ? other.EdsClusterConfig.Clone() : null;
      ConnectTimeout = other.connectTimeout_ != null ? other.ConnectTimeout.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      lbPolicy_ = other.lbPolicy_;
      hosts_ = other.hosts_.Clone();
      LoadAssignment = other.loadAssignment_ != null ? other.LoadAssignment.Clone() : null;
      healthChecks_ = other.healthChecks_.Clone();
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      CircuitBreakers = other.circuitBreakers_ != null ? other.CircuitBreakers.Clone() : null;
      TlsContext = other.tlsContext_ != null ? other.TlsContext.Clone() : null;
      CommonHttpProtocolOptions = other.commonHttpProtocolOptions_ != null ? other.CommonHttpProtocolOptions.Clone() : null;
      HttpProtocolOptions = other.httpProtocolOptions_ != null ? other.HttpProtocolOptions.Clone() : null;
      Http2ProtocolOptions = other.http2ProtocolOptions_ != null ? other.Http2ProtocolOptions.Clone() : null;
      DnsRefreshRate = other.dnsRefreshRate_ != null ? other.DnsRefreshRate.Clone() : null;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsResolvers_ = other.dnsResolvers_.Clone();
      OutlierDetection = other.outlierDetection_ != null ? other.OutlierDetection.Clone() : null;
      CleanupInterval = other.cleanupInterval_ != null ? other.CleanupInterval.Clone() : null;
      UpstreamBindConfig = other.upstreamBindConfig_ != null ? other.UpstreamBindConfig.Clone() : null;
      LbSubsetConfig = other.lbSubsetConfig_ != null ? other.LbSubsetConfig.Clone() : null;
      CommonLbConfig = other.commonLbConfig_ != null ? other.CommonLbConfig.Clone() : null;
      TransportSocket = other.transportSocket_ != null ? other.TransportSocket.Clone() : null;
      Metadata = other.metadata_ != null ? other.Metadata.Clone() : null;
      protocolSelection_ = other.protocolSelection_;
      UpstreamConnectionOptions = other.upstreamConnectionOptions_ != null ? other.UpstreamConnectionOptions.Clone() : null;
      closeConnectionsOnHostHealthFailure_ = other.closeConnectionsOnHostHealthFailure_;
      drainConnectionsOnHostRemoval_ = other.drainConnectionsOnHostRemoval_;
      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          RingHashLbConfig = other.RingHashLbConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Supplies the name of the cluster which must be unique across all clusters.
    /// The cluster name is used when emitting
    /// :ref:`statistics &lt;config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    /// &lt;envoy_api_field_Cluster.alt_stat_name>` is not provided.
    /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    /// By default, the maximum length of a cluster name is limited to 60
    /// characters. This limit can be increased by setting the
    /// :option:`--max-obj-name-len` command line argument to the desired value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alt_stat_name" field.</summary>
    public const int AltStatNameFieldNumber = 28;
    private string altStatName_ = "";
    /// <summary>
    /// An optional alternative to the cluster name to be used while emitting stats.
    /// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
    /// confused with :ref:`Router Filter Header
    /// &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AltStatName {
      get { return altStatName_; }
      set {
        altStatName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Envoy.Api.V2.Cluster.Types.DiscoveryType type_ = 0;
    /// <summary>
    /// The :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DiscoveryType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "eds_cluster_config" field.</summary>
    public const int EdsClusterConfigFieldNumber = 3;
    private global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig edsClusterConfig_;
    /// <summary>
    /// Configuration to use for EDS updates for the Cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig EdsClusterConfig {
      get { return edsClusterConfig_; }
      set {
        edsClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "connect_timeout" field.</summary>
    public const int ConnectTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectTimeout_;
    /// <summary>
    /// The timeout for new network connections to hosts in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectTimeout {
      get { return connectTimeout_; }
      set {
        connectTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the cluster’s connections read and write buffers. If
    /// unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }

    /// <summary>Field number for the "lb_policy" field.</summary>
    public const int LbPolicyFieldNumber = 6;
    private global::Envoy.Api.V2.Cluster.Types.LbPolicy lbPolicy_ = 0;
    /// <summary>
    /// The :ref:`load balancer type &lt;arch_overview_load_balancing_types>` to use
    /// when picking a host in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbPolicy LbPolicy {
      get { return lbPolicy_; }
      set {
        lbPolicy_ = value;
      }
    }

    /// <summary>Field number for the "hosts" field.</summary>
    public const int HostsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_hosts_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> hosts_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If the service discovery type is
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// then hosts is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> Hosts {
      get { return hosts_; }
    }

    /// <summary>Field number for the "load_assignment" field.</summary>
    public const int LoadAssignmentFieldNumber = 33;
    private global::Envoy.Api.V2.ClusterLoadAssignment loadAssignment_;
    /// <summary>
    /// Setting this is required for specifying members of
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
    /// This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts>` field.
    /// [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
    /// once load_assignment is implemented.]
    ///
    /// .. attention::
    ///
    ///   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
    ///   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment>`.
    ///   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts>` values.
    ///
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterLoadAssignment LoadAssignment {
      get { return loadAssignment_; }
      set {
        loadAssignment_ = value;
      }
    }

    /// <summary>Field number for the "health_checks" field.</summary>
    public const int HealthChecksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HealthCheck> _repeated_healthChecks_codec
        = pb::FieldCodec.ForMessage(66, global::Envoy.Api.V2.Core.HealthCheck.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> healthChecks_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck>();
    /// <summary>
    /// Optional :ref:`active health checking &lt;arch_overview_health_checking>`
    /// configuration for the cluster. If no
    /// configuration is specified no health checking will be done and all cluster
    /// members will be considered healthy at all times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> HealthChecks {
      get { return healthChecks_; }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for a single upstream connection. This parameter
    /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
    /// implementations. If not specified, there is no limit. Setting this
    /// parameter to 1 will effectively disable keep alive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }

    /// <summary>Field number for the "circuit_breakers" field.</summary>
    public const int CircuitBreakersFieldNumber = 10;
    private global::Envoy.Api.V2.ClusterNS.CircuitBreakers circuitBreakers_;
    /// <summary>
    /// Optional :ref:`circuit breaking &lt;arch_overview_circuit_break>` for the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterNS.CircuitBreakers CircuitBreakers {
      get { return circuitBreakers_; }
      set {
        circuitBreakers_ = value;
      }
    }

    /// <summary>Field number for the "tls_context" field.</summary>
    public const int TlsContextFieldNumber = 11;
    private global::Envoy.Api.V2.Auth.UpstreamTlsContext tlsContext_;
    /// <summary>
    /// The TLS configuration for connections to the upstream cluster. If no TLS
    /// configuration is specified, TLS will not be used for new connections.
    ///
    /// .. attention::
    ///
    ///   Server certificate verification is not enabled by default. Configure
    ///   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca>` to enable
    ///   verification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.UpstreamTlsContext TlsContext {
      get { return tlsContext_; }
      set {
        tlsContext_ = value;
      }
    }

    /// <summary>Field number for the "common_http_protocol_options" field.</summary>
    public const int CommonHttpProtocolOptionsFieldNumber = 29;
    private global::Envoy.Api.V2.Core.HttpProtocolOptions commonHttpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP requests. These options will be applicable to both
    /// HTTP1 and HTTP2 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.HttpProtocolOptions CommonHttpProtocolOptions {
      get { return commonHttpProtocolOptions_; }
      set {
        commonHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 13;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP1 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 14;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Even if default HTTP2 protocol options are desired, this field must be
    /// set so that Envoy will assume that the upstream supports HTTP/2 when
    /// making new HTTP connection pool connections. Currently, Envoy only
    /// supports prior knowledge for upstream connections. Even if TLS is used
    /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    /// connections to happen over plain text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// If the DNS refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used as the cluster’s DNS refresh
    /// rate. If this setting is not specified, the value defaults to 5000. For
    /// cluster types other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 17;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = 0;
    /// <summary>
    /// The DNS IP address resolution policy. If this setting is not specified, the
    /// value defaults to
    /// :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolvers" field.</summary>
    public const int DnsResolversFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_dnsResolvers_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> dnsResolvers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If DNS resolvers are specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used to specify the cluster’s dns resolvers.
    /// If this setting is not specified, the value defaults to the default
    /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
    /// other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> DnsResolvers {
      get { return dnsResolvers_; }
    }

    /// <summary>Field number for the "outlier_detection" field.</summary>
    public const int OutlierDetectionFieldNumber = 19;
    private global::Envoy.Api.V2.ClusterNS.OutlierDetection outlierDetection_;
    /// <summary>
    /// If specified, outlier detection will be enabled for this upstream cluster.
    /// Each of the configuration values can be overridden via
    /// :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterNS.OutlierDetection OutlierDetection {
      get { return outlierDetection_; }
      set {
        outlierDetection_ = value;
      }
    }

    /// <summary>Field number for the "cleanup_interval" field.</summary>
    public const int CleanupIntervalFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Duration cleanupInterval_;
    /// <summary>
    /// The interval for removing stale hosts from a cluster type
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
    /// Hosts are considered stale if they have not been used
    /// as upstream destinations during this interval. New hosts are added
    /// to original destination clusters on demand as new connections are
    /// redirected to Envoy, causing the number of hosts in the cluster to
    /// grow over time. Hosts that are not stale (they are actively used as
    /// destinations) are kept in the cluster, which allows connections to
    /// them remain open, saving the latency that would otherwise be spent
    /// on opening new connections. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration CleanupInterval {
      get { return cleanupInterval_; }
      set {
        cleanupInterval_ = value;
      }
    }

    /// <summary>Field number for the "upstream_bind_config" field.</summary>
    public const int UpstreamBindConfigFieldNumber = 21;
    private global::Envoy.Api.V2.Core.BindConfig upstreamBindConfig_;
    /// <summary>
    /// Optional configuration used to bind newly established upstream connections.
    /// This overrides any bind_config specified in the bootstrap proto.
    /// If the address and port are empty, no bind will be performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.BindConfig UpstreamBindConfig {
      get { return upstreamBindConfig_; }
      set {
        upstreamBindConfig_ = value;
      }
    }

    /// <summary>Field number for the "lb_subset_config" field.</summary>
    public const int LbSubsetConfigFieldNumber = 22;
    private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig lbSubsetConfig_;
    /// <summary>
    /// Configuration for load balancing subsetting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig LbSubsetConfig {
      get { return lbSubsetConfig_; }
      set {
        lbSubsetConfig_ = value;
      }
    }

    /// <summary>Field number for the "ring_hash_lb_config" field.</summary>
    public const int RingHashLbConfigFieldNumber = 23;
    /// <summary>
    /// Optional configuration for the Ring Hash load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig RingHashLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig ? (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RingHashLbConfig;
      }
    }

    /// <summary>Field number for the "common_lb_config" field.</summary>
    public const int CommonLbConfigFieldNumber = 27;
    private global::Envoy.Api.V2.Cluster.Types.CommonLbConfig commonLbConfig_;
    /// <summary>
    /// Common configuration for all load balancer implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig CommonLbConfig {
      get { return commonLbConfig_; }
      set {
        commonLbConfig_ = value;
      }
    }

    /// <summary>Field number for the "transport_socket" field.</summary>
    public const int TransportSocketFieldNumber = 24;
    private global::Envoy.Api.V2.Core.TransportSocket transportSocket_;
    /// <summary>
    /// Optional custom transport socket implementation to use for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.TransportSocket TransportSocket {
      get { return transportSocket_; }
      set {
        transportSocket_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 25;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information about the
    /// cluster. It can be used for stats, logging, and varying filter behavior.
    /// Fields should use reverse DNS notation to denote which entity within Envoy
    /// will need the information. For instance, if the metadata is intended for
    /// the Router filter, the filter name should be specified as *envoy.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "protocol_selection" field.</summary>
    public const int ProtocolSelectionFieldNumber = 26;
    private global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection protocolSelection_ = 0;
    /// <summary>
    /// Determines how Envoy selects the protocol used to speak to upstream hosts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection ProtocolSelection {
      get { return protocolSelection_; }
      set {
        protocolSelection_ = value;
      }
    }

    /// <summary>Field number for the "upstream_connection_options" field.</summary>
    public const int UpstreamConnectionOptionsFieldNumber = 30;
    private global::Envoy.Api.V2.UpstreamConnectionOptions upstreamConnectionOptions_;
    /// <summary>
    /// Optional options for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.UpstreamConnectionOptions UpstreamConnectionOptions {
      get { return upstreamConnectionOptions_; }
      set {
        upstreamConnectionOptions_ = value;
      }
    }

    /// <summary>Field number for the "close_connections_on_host_health_failure" field.</summary>
    public const int CloseConnectionsOnHostHealthFailureFieldNumber = 31;
    private bool closeConnectionsOnHostHealthFailure_;
    /// <summary>
    /// If an upstream host becomes unhealthy (as determined by the configured health checks
    /// or outlier detection), immediately close all connections to the failed host.
    ///
    /// .. note::
    ///
    ///   This is currently only supported for connections created by tcp_proxy.
    ///
    /// .. note::
    ///
    ///   The current implementation of this feature closes all connections immediately when
    ///   the unhealthy status is detected. If there are a large number of connections open
    ///   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
    ///   time exclusively closing these connections, and not processing any other traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool CloseConnectionsOnHostHealthFailure {
      get { return closeConnectionsOnHostHealthFailure_; }
      set {
        closeConnectionsOnHostHealthFailure_ = value;
      }
    }

    /// <summary>Field number for the "drain_connections_on_host_removal" field.</summary>
    public const int DrainConnectionsOnHostRemovalFieldNumber = 32;
    private bool drainConnectionsOnHostRemoval_;
    /// <summary>
    /// If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
    /// connections from any hosts that are removed from service discovery.
    ///
    /// This only affects behavior for hosts that are being actively health checked.
    /// If this flag is not set to true, Envoy will wait until the hosts fail active health
    /// checking before removing it from the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DrainConnectionsOnHostRemoval {
      get { return drainConnectionsOnHostRemoval_; }
      set {
        drainConnectionsOnHostRemoval_ = value;
      }
    }

    private object lbConfig_;
    /// <summary>Enum of possible cases for the "lb_config" oneof.</summary>
    public enum LbConfigOneofCase {
      None = 0,
      RingHashLbConfig = 23,
    }
    private LbConfigOneofCase lbConfigCase_ = LbConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LbConfigOneofCase LbConfigCase {
      get { return lbConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLbConfig() {
      lbConfigCase_ = LbConfigOneofCase.None;
      lbConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (AltStatName != other.AltStatName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(EdsClusterConfig, other.EdsClusterConfig)) return false;
      if (!object.Equals(ConnectTimeout, other.ConnectTimeout)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (LbPolicy != other.LbPolicy) return false;
      if(!hosts_.Equals(other.hosts_)) return false;
      if (!object.Equals(LoadAssignment, other.LoadAssignment)) return false;
      if(!healthChecks_.Equals(other.healthChecks_)) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      if (!object.Equals(CircuitBreakers, other.CircuitBreakers)) return false;
      if (!object.Equals(TlsContext, other.TlsContext)) return false;
      if (!object.Equals(CommonHttpProtocolOptions, other.CommonHttpProtocolOptions)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if(!dnsResolvers_.Equals(other.dnsResolvers_)) return false;
      if (!object.Equals(OutlierDetection, other.OutlierDetection)) return false;
      if (!object.Equals(CleanupInterval, other.CleanupInterval)) return false;
      if (!object.Equals(UpstreamBindConfig, other.UpstreamBindConfig)) return false;
      if (!object.Equals(LbSubsetConfig, other.LbSubsetConfig)) return false;
      if (!object.Equals(RingHashLbConfig, other.RingHashLbConfig)) return false;
      if (!object.Equals(CommonLbConfig, other.CommonLbConfig)) return false;
      if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (ProtocolSelection != other.ProtocolSelection) return false;
      if (!object.Equals(UpstreamConnectionOptions, other.UpstreamConnectionOptions)) return false;
      if (CloseConnectionsOnHostHealthFailure != other.CloseConnectionsOnHostHealthFailure) return false;
      if (DrainConnectionsOnHostRemoval != other.DrainConnectionsOnHostRemoval) return false;
      if (LbConfigCase != other.LbConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (AltStatName.Length != 0) hash ^= AltStatName.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (edsClusterConfig_ != null) hash ^= EdsClusterConfig.GetHashCode();
      if (connectTimeout_ != null) hash ^= ConnectTimeout.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (LbPolicy != 0) hash ^= LbPolicy.GetHashCode();
      hash ^= hosts_.GetHashCode();
      if (loadAssignment_ != null) hash ^= LoadAssignment.GetHashCode();
      hash ^= healthChecks_.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (circuitBreakers_ != null) hash ^= CircuitBreakers.GetHashCode();
      if (tlsContext_ != null) hash ^= TlsContext.GetHashCode();
      if (commonHttpProtocolOptions_ != null) hash ^= CommonHttpProtocolOptions.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (DnsLookupFamily != 0) hash ^= DnsLookupFamily.GetHashCode();
      hash ^= dnsResolvers_.GetHashCode();
      if (outlierDetection_ != null) hash ^= OutlierDetection.GetHashCode();
      if (cleanupInterval_ != null) hash ^= CleanupInterval.GetHashCode();
      if (upstreamBindConfig_ != null) hash ^= UpstreamBindConfig.GetHashCode();
      if (lbSubsetConfig_ != null) hash ^= LbSubsetConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) hash ^= RingHashLbConfig.GetHashCode();
      if (commonLbConfig_ != null) hash ^= CommonLbConfig.GetHashCode();
      if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (ProtocolSelection != 0) hash ^= ProtocolSelection.GetHashCode();
      if (upstreamConnectionOptions_ != null) hash ^= UpstreamConnectionOptions.GetHashCode();
      if (CloseConnectionsOnHostHealthFailure != false) hash ^= CloseConnectionsOnHostHealthFailure.GetHashCode();
      if (DrainConnectionsOnHostRemoval != false) hash ^= DrainConnectionsOnHostRemoval.GetHashCode();
      hash ^= (int) lbConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      hosts_.WriteTo(output, _repeated_hosts_codec);
      healthChecks_.WriteTo(output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != 0) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (DrainConnectionsOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(DrainConnectionsOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (AltStatName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AltStatName);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (edsClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LbPolicy);
      }
      size += hosts_.CalculateSize(_repeated_hosts_codec);
      if (loadAssignment_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadAssignment);
      }
      size += healthChecks_.CalculateSize(_repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsContext);
      }
      if (commonHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonHttpProtocolOptions);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (DnsLookupFamily != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      size += dnsResolvers_.CalculateSize(_repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RingHashLbConfig);
      }
      if (commonLbConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonLbConfig);
      }
      if (transportSocket_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
      }
      if (metadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ProtocolSelection != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolSelection);
      }
      if (upstreamConnectionOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        size += 2 + 1;
      }
      if (DrainConnectionsOnHostRemoval != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.AltStatName.Length != 0) {
        AltStatName = other.AltStatName;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.edsClusterConfig_ != null) {
        if (edsClusterConfig_ == null) {
          edsClusterConfig_ = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
        }
        EdsClusterConfig.MergeFrom(other.EdsClusterConfig);
      }
      if (other.connectTimeout_ != null) {
        if (connectTimeout_ == null) {
          connectTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectTimeout.MergeFrom(other.ConnectTimeout);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.LbPolicy != 0) {
        LbPolicy = other.LbPolicy;
      }
      hosts_.Add(other.hosts_);
      if (other.loadAssignment_ != null) {
        if (loadAssignment_ == null) {
          loadAssignment_ = new global::Envoy.Api.V2.ClusterLoadAssignment();
        }
        LoadAssignment.MergeFrom(other.LoadAssignment);
      }
      healthChecks_.Add(other.healthChecks_);
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      if (other.circuitBreakers_ != null) {
        if (circuitBreakers_ == null) {
          circuitBreakers_ = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
        }
        CircuitBreakers.MergeFrom(other.CircuitBreakers);
      }
      if (other.tlsContext_ != null) {
        if (tlsContext_ == null) {
          tlsContext_ = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
        }
        TlsContext.MergeFrom(other.TlsContext);
      }
      if (other.commonHttpProtocolOptions_ != null) {
        if (commonHttpProtocolOptions_ == null) {
          commonHttpProtocolOptions_ = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
        }
        CommonHttpProtocolOptions.MergeFrom(other.CommonHttpProtocolOptions);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          dnsRefreshRate_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.DnsLookupFamily != 0) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      dnsResolvers_.Add(other.dnsResolvers_);
      if (other.outlierDetection_ != null) {
        if (outlierDetection_ == null) {
          outlierDetection_ = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
        }
        OutlierDetection.MergeFrom(other.OutlierDetection);
      }
      if (other.cleanupInterval_ != null) {
        if (cleanupInterval_ == null) {
          cleanupInterval_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        CleanupInterval.MergeFrom(other.CleanupInterval);
      }
      if (other.upstreamBindConfig_ != null) {
        if (upstreamBindConfig_ == null) {
          upstreamBindConfig_ = new global::Envoy.Api.V2.Core.BindConfig();
        }
        UpstreamBindConfig.MergeFrom(other.UpstreamBindConfig);
      }
      if (other.lbSubsetConfig_ != null) {
        if (lbSubsetConfig_ == null) {
          lbSubsetConfig_ = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
        }
        LbSubsetConfig.MergeFrom(other.LbSubsetConfig);
      }
      if (other.commonLbConfig_ != null) {
        if (commonLbConfig_ == null) {
          commonLbConfig_ = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
        }
        CommonLbConfig.MergeFrom(other.CommonLbConfig);
      }
      if (other.transportSocket_ != null) {
        if (transportSocket_ == null) {
          transportSocket_ = new global::Envoy.Api.V2.Core.TransportSocket();
        }
        TransportSocket.MergeFrom(other.TransportSocket);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          metadata_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.ProtocolSelection != 0) {
        ProtocolSelection = other.ProtocolSelection;
      }
      if (other.upstreamConnectionOptions_ != null) {
        if (upstreamConnectionOptions_ == null) {
          upstreamConnectionOptions_ = new global::Envoy.Api.V2.UpstreamConnectionOptions();
        }
        UpstreamConnectionOptions.MergeFrom(other.UpstreamConnectionOptions);
      }
      if (other.CloseConnectionsOnHostHealthFailure != false) {
        CloseConnectionsOnHostHealthFailure = other.CloseConnectionsOnHostHealthFailure;
      }
      if (other.DrainConnectionsOnHostRemoval != false) {
        DrainConnectionsOnHostRemoval = other.DrainConnectionsOnHostRemoval;
      }
      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          if (RingHashLbConfig == null) {
            RingHashLbConfig = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
          }
          RingHashLbConfig.MergeFrom(other.RingHashLbConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            type_ = (global::Envoy.Api.V2.Cluster.Types.DiscoveryType) input.ReadEnum();
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              edsClusterConfig_ = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(edsClusterConfig_);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              connectTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(connectTimeout_);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            lbPolicy_ = (global::Envoy.Api.V2.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 58: {
            hosts_.AddEntriesFrom(input, _repeated_hosts_codec);
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              circuitBreakers_ = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
            }
            input.ReadMessage(circuitBreakers_);
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              tlsContext_ = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
            }
            input.ReadMessage(tlsContext_);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(httpProtocolOptions_);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(http2ProtocolOptions_);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              dnsRefreshRate_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(dnsRefreshRate_);
            break;
          }
          case 136: {
            dnsLookupFamily_ = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              outlierDetection_ = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
            }
            input.ReadMessage(outlierDetection_);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              cleanupInterval_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(cleanupInterval_);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              upstreamBindConfig_ = new global::Envoy.Api.V2.Core.BindConfig();
            }
            input.ReadMessage(upstreamBindConfig_);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              lbSubsetConfig_ = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(lbSubsetConfig_);
            break;
          }
          case 186: {
            global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              transportSocket_ = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            input.ReadMessage(transportSocket_);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              metadata_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadata_);
            break;
          }
          case 208: {
            protocolSelection_ = (global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              commonLbConfig_ = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(commonLbConfig_);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              commonHttpProtocolOptions_ = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
            }
            input.ReadMessage(commonHttpProtocolOptions_);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              upstreamConnectionOptions_ = new global::Envoy.Api.V2.UpstreamConnectionOptions();
            }
            input.ReadMessage(upstreamConnectionOptions_);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            DrainConnectionsOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              loadAssignment_ = new global::Envoy.Api.V2.ClusterLoadAssignment();
            }
            input.ReadMessage(loadAssignment_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
      /// for an explanation on each type.
      /// </summary>
      public enum DiscoveryType {
        /// <summary>
        /// Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STATIC")] Static = 0,
        /// <summary>
        /// Refer to the :ref:`strict DNS discovery
        /// type&lt;arch_overview_service_discovery_types_strict_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STRICT_DNS")] StrictDns = 1,
        /// <summary>
        /// Refer to the :ref:`logical DNS discovery
        /// type&lt;arch_overview_service_discovery_types_logical_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LOGICAL_DNS")] LogicalDns = 2,
        /// <summary>
        /// Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_sds>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("EDS")] Eds = 3,
        /// <summary>
        /// Refer to the :ref:`original destination discovery
        /// type&lt;arch_overview_service_discovery_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST")] OriginalDst = 4,
      }

      /// <summary>
      /// Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types>` architecture
      /// overview section for information on each type.
      /// </summary>
      public enum LbPolicy {
        /// <summary>
        /// Refer to the :ref:`round robin load balancing
        /// policy&lt;arch_overview_load_balancing_types_round_robin>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 0,
        /// <summary>
        /// Refer to the :ref:`least request load balancing
        /// policy&lt;arch_overview_load_balancing_types_least_request>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LEAST_REQUEST")] LeastRequest = 1,
        /// <summary>
        /// Refer to the :ref:`ring hash load balancing
        /// policy&lt;arch_overview_load_balancing_types_ring_hash>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RING_HASH")] RingHash = 2,
        /// <summary>
        /// Refer to the :ref:`random load balancing
        /// policy&lt;arch_overview_load_balancing_types_random>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RANDOM")] Random = 3,
        /// <summary>
        /// Refer to the :ref:`original destination load balancing
        /// policy&lt;arch_overview_load_balancing_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST_LB")] OriginalDstLb = 4,
        /// <summary>
        /// Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("MAGLEV")] Maglev = 5,
      }

      /// <summary>
      /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
      /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
      /// only perform a lookup for addresses in the IPv6 family. If AUTO is
      /// specified, the DNS resolver will first perform a lookup for addresses in
      /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
      /// For cluster types other than
      /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
      /// :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
      /// this setting is
      /// ignored.
      /// </summary>
      public enum DnsLookupFamily {
        [pbr::OriginalName("AUTO")] Auto = 0,
        [pbr::OriginalName("V4_ONLY")] V4Only = 1,
        [pbr::OriginalName("V6_ONLY")] V6Only = 2,
      }

      public enum ClusterProtocolSelection {
        /// <summary>
        /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
        /// If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options>` are
        /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
        /// </summary>
        [pbr::OriginalName("USE_CONFIGURED_PROTOCOL")] UseConfiguredProtocol = 0,
        /// <summary>
        /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
        /// </summary>
        [pbr::OriginalName("USE_DOWNSTREAM_PROTOCOL")] UseDownstreamProtocol = 1,
      }

      /// <summary>
      /// Only valid when discovery type is EDS.
      /// </summary>
      public sealed partial class EdsClusterConfig : pb::IMessage<EdsClusterConfig> {
        private static readonly pb::MessageParser<EdsClusterConfig> _parser = new pb::MessageParser<EdsClusterConfig>(() => new EdsClusterConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<EdsClusterConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig(EdsClusterConfig other) : this() {
          EdsConfig = other.edsConfig_ != null ? other.EdsConfig.Clone() : null;
          serviceName_ = other.serviceName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig Clone() {
          return new EdsClusterConfig(this);
        }

        /// <summary>Field number for the "eds_config" field.</summary>
        public const int EdsConfigFieldNumber = 1;
        private global::Envoy.Api.V2.Core.ConfigSource edsConfig_;
        /// <summary>
        /// Configuration for the source of EDS updates for this Cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.ConfigSource EdsConfig {
          get { return edsConfig_; }
          set {
            edsConfig_ = value;
          }
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 2;
        private string serviceName_ = "";
        /// <summary>
        /// Optional alternative to cluster name to present to EDS. This does not
        /// have the same restrictions as cluster name, i.e. it may be arbitrary
        /// length.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as EdsClusterConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(EdsClusterConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EdsConfig, other.EdsConfig)) return false;
          if (ServiceName != other.ServiceName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (edsConfig_ != null) hash ^= EdsConfig.GetHashCode();
          if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (edsConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(EdsClusterConfig other) {
          if (other == null) {
            return;
          }
          if (other.edsConfig_ != null) {
            if (edsConfig_ == null) {
              edsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            EdsConfig.MergeFrom(other.EdsConfig);
          }
          if (other.ServiceName.Length != 0) {
            ServiceName = other.ServiceName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  edsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
                }
                input.ReadMessage(edsConfig_);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Optionally divide the endpoints in this cluster into subsets defined by
      /// endpoint metadata and selected by route and weighted cluster metadata.
      /// </summary>
      public sealed partial class LbSubsetConfig : pb::IMessage<LbSubsetConfig> {
        private static readonly pb::MessageParser<LbSubsetConfig> _parser = new pb::MessageParser<LbSubsetConfig>(() => new LbSubsetConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LbSubsetConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig(LbSubsetConfig other) : this() {
          fallbackPolicy_ = other.fallbackPolicy_;
          DefaultSubset = other.defaultSubset_ != null ? other.DefaultSubset.Clone() : null;
          subsetSelectors_ = other.subsetSelectors_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig Clone() {
          return new LbSubsetConfig(this);
        }

        /// <summary>Field number for the "fallback_policy" field.</summary>
        public const int FallbackPolicyFieldNumber = 1;
        private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy fallbackPolicy_ = 0;
        /// <summary>
        /// The behavior used when no endpoint subset matches the selected route's
        /// metadata. The value defaults to
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy FallbackPolicy {
          get { return fallbackPolicy_; }
          set {
            fallbackPolicy_ = value;
          }
        }

        /// <summary>Field number for the "default_subset" field.</summary>
        public const int DefaultSubsetFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct defaultSubset_;
        /// <summary>
        /// Specifies the default subset of endpoints used during fallback if
        /// fallback_policy is
        /// :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
        /// Each field in default_subset is
        /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
        /// namespace. It is valid for no hosts to match, in which case the behavior
        /// is the same as a fallback_policy of
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct DefaultSubset {
          get { return defaultSubset_; }
          set {
            defaultSubset_ = value;
          }
        }

        /// <summary>Field number for the "subset_selectors" field.</summary>
        public const int SubsetSelectorsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> _repeated_subsetSelectors_codec
            = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> subsetSelectors_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector>();
        /// <summary>
        /// For each entry, LbEndpoint.Metadata's
        /// *envoy.lb* namespace is traversed and a subset is created for each unique
        /// combination of key and value. For example:
        ///
        /// .. code-block:: json
        ///
        ///   { "subset_selectors": [
        ///       { "keys": [ "version" ] },
        ///       { "keys": [ "stage", "hardware_type" ] }
        ///   ]}
        ///
        /// A subset is matched when the metadata from the selected route and
        /// weighted cluster contains the same keys and values as the subset's
        /// metadata. The same host may appear in multiple subsets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> SubsetSelectors {
          get { return subsetSelectors_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LbSubsetConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LbSubsetConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FallbackPolicy != other.FallbackPolicy) return false;
          if (!object.Equals(DefaultSubset, other.DefaultSubset)) return false;
          if(!subsetSelectors_.Equals(other.subsetSelectors_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FallbackPolicy != 0) hash ^= FallbackPolicy.GetHashCode();
          if (defaultSubset_ != null) hash ^= DefaultSubset.GetHashCode();
          hash ^= subsetSelectors_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FallbackPolicy != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(output, _repeated_subsetSelectors_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FallbackPolicy != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultSubset);
          }
          size += subsetSelectors_.CalculateSize(_repeated_subsetSelectors_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LbSubsetConfig other) {
          if (other == null) {
            return;
          }
          if (other.FallbackPolicy != 0) {
            FallbackPolicy = other.FallbackPolicy;
          }
          if (other.defaultSubset_ != null) {
            if (defaultSubset_ == null) {
              defaultSubset_ = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            DefaultSubset.MergeFrom(other.DefaultSubset);
          }
          subsetSelectors_.Add(other.subsetSelectors_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                fallbackPolicy_ = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  defaultSubset_ = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(defaultSubset_);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(input, _repeated_subsetSelectors_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LbSubsetConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// If NO_FALLBACK is selected, a result
          /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
          /// any cluster endpoint may be returned (subject to policy, health checks,
          /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
          /// endpoints matching the values from the default_subset field.
          /// </summary>
          public enum LbSubsetFallbackPolicy {
            [pbr::OriginalName("NO_FALLBACK")] NoFallback = 0,
            [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 1,
            [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 2,
          }

          /// <summary>
          /// Specifications for subsets.
          /// </summary>
          public sealed partial class LbSubsetSelector : pb::IMessage<LbSubsetSelector> {
            private static readonly pb::MessageParser<LbSubsetSelector> _parser = new pb::MessageParser<LbSubsetSelector>(() => new LbSubsetSelector());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LbSubsetSelector> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector(LbSubsetSelector other) : this() {
              keys_ = other.keys_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector Clone() {
              return new LbSubsetSelector(this);
            }

            /// <summary>Field number for the "keys" field.</summary>
            public const int KeysFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_keys_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of keys to match with the weighted cluster metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> Keys {
              get { return keys_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LbSubsetSelector);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LbSubsetSelector other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!keys_.Equals(other.keys_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= keys_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              keys_.WriteTo(output, _repeated_keys_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += keys_.CalculateSize(_repeated_keys_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LbSubsetSelector other) {
              if (other == null) {
                return;
              }
              keys_.Add(other.keys_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(input, _repeated_keys_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class RingHashLbConfig : pb::IMessage<RingHashLbConfig> {
        private static readonly pb::MessageParser<RingHashLbConfig> _parser = new pb::MessageParser<RingHashLbConfig>(() => new RingHashLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RingHashLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig(RingHashLbConfig other) : this() {
          MinimumRingSize = other.MinimumRingSize;
          DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig Clone() {
          return new RingHashLbConfig(this);
        }

        /// <summary>Field number for the "minimum_ring_size" field.</summary>
        public const int MinimumRingSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_minimumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? minimumRingSize_;
        /// <summary>
        /// Minimum hash ring size, i.e. total virtual nodes. A larger size
        /// will provide better request distribution since each host in the
        /// cluster will have more virtual nodes. Defaults to 1024. In the case
        /// that total number of hosts is greater than the minimum, each host will
        /// be allocated a single virtual node. This field is limited to 8M to bound
        /// resource use.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong? MinimumRingSize {
          get { return minimumRingSize_; }
          set {
            minimumRingSize_ = value;
          }
        }

        /// <summary>Field number for the "deprecated_v1" field.</summary>
        public const int DeprecatedV1FieldNumber = 2;
        private global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1 deprecatedV1_;
        /// <summary>
        /// Deprecated settings from v1 config.
        /// [#not-implemented-hide:] Hide from docs.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1 DeprecatedV1 {
          get { return deprecatedV1_; }
          set {
            deprecatedV1_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RingHashLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RingHashLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinimumRingSize != other.MinimumRingSize) return false;
          if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (minimumRingSize_ != null) hash ^= MinimumRingSize.GetHashCode();
          if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(output, MinimumRingSize);
          }
          if (deprecatedV1_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DeprecatedV1);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (minimumRingSize_ != null) {
            size += _single_minimumRingSize_codec.CalculateSizeWithTag(MinimumRingSize);
          }
          if (deprecatedV1_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RingHashLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.minimumRingSize_ != null) {
            if (minimumRingSize_ == null || other.MinimumRingSize != 0UL) {
              MinimumRingSize = other.MinimumRingSize;
            }
          }
          if (other.deprecatedV1_ != null) {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1();
            }
            DeprecatedV1.MergeFrom(other.DeprecatedV1);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 18: {
                if (deprecatedV1_ == null) {
                  deprecatedV1_ = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1();
                }
                input.ReadMessage(deprecatedV1_);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the RingHashLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// [#not-implemented-hide:] Hide from docs.
          /// </summary>
          public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
            private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1(DeprecatedV1 other) : this() {
              UseStdHash = other.UseStdHash;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1 Clone() {
              return new DeprecatedV1(this);
            }

            /// <summary>Field number for the "use_std_hash" field.</summary>
            public const int UseStdHashFieldNumber = 1;
            private static readonly pb::FieldCodec<bool?> _single_useStdHash_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
            private bool? useStdHash_;
            /// <summary>
            /// Defaults to true, meaning that std::hash is used to hash hosts onto
            /// the ketama ring. std::hash can vary by platform. For this reason,
            /// Envoy will eventually use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_
            /// by default. This field exists for
            /// migration purposes and will eventually be deprecated. Set it to false
            /// to use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_ now.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool? UseStdHash {
              get { return useStdHash_; }
              set {
                useStdHash_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as DeprecatedV1);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(DeprecatedV1 other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (UseStdHash != other.UseStdHash) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (useStdHash_ != null) hash ^= UseStdHash.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (useStdHash_ != null) {
                _single_useStdHash_codec.WriteTagAndValue(output, UseStdHash);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (useStdHash_ != null) {
                size += _single_useStdHash_codec.CalculateSizeWithTag(UseStdHash);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(DeprecatedV1 other) {
              if (other == null) {
                return;
              }
              if (other.useStdHash_ != null) {
                if (useStdHash_ == null || other.UseStdHash != false) {
                  UseStdHash = other.UseStdHash;
                }
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    bool? value = _single_useStdHash_codec.Read(input);
                    if (useStdHash_ == null || value != false) {
                      UseStdHash = value;
                    }
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Common configuration for all load balancer implementations.
      /// </summary>
      public sealed partial class CommonLbConfig : pb::IMessage<CommonLbConfig> {
        private static readonly pb::MessageParser<CommonLbConfig> _parser = new pb::MessageParser<CommonLbConfig>(() => new CommonLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CommonLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig(CommonLbConfig other) : this() {
          HealthyPanicThreshold = other.healthyPanicThreshold_ != null ? other.HealthyPanicThreshold.Clone() : null;
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              ZoneAwareLbConfig = other.ZoneAwareLbConfig.Clone();
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              LocalityWeightedLbConfig = other.LocalityWeightedLbConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig Clone() {
          return new CommonLbConfig(this);
        }

        /// <summary>Field number for the "healthy_panic_threshold" field.</summary>
        public const int HealthyPanicThresholdFieldNumber = 1;
        private global::Envoy.Type.Percent healthyPanicThreshold_;
        /// <summary>
        /// Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold>`.
        /// If not specified, the default is 50%.
        ///
        /// .. note::
        ///   The specified percent will be truncated to the nearest 1%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Percent HealthyPanicThreshold {
          get { return healthyPanicThreshold_; }
          set {
            healthyPanicThreshold_ = value;
          }
        }

        /// <summary>Field number for the "zone_aware_lb_config" field.</summary>
        public const int ZoneAwareLbConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig ZoneAwareLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig;
          }
        }

        /// <summary>Field number for the "locality_weighted_lb_config" field.</summary>
        public const int LocalityWeightedLbConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig LocalityWeightedLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig;
          }
        }

        private object localityConfigSpecifier_;
        /// <summary>Enum of possible cases for the "locality_config_specifier" oneof.</summary>
        public enum LocalityConfigSpecifierOneofCase {
          None = 0,
          ZoneAwareLbConfig = 2,
          LocalityWeightedLbConfig = 3,
        }
        private LocalityConfigSpecifierOneofCase localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LocalityConfigSpecifierOneofCase LocalityConfigSpecifierCase {
          get { return localityConfigSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearLocalityConfigSpecifier() {
          localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
          localityConfigSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CommonLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CommonLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(HealthyPanicThreshold, other.HealthyPanicThreshold)) return false;
          if (!object.Equals(ZoneAwareLbConfig, other.ZoneAwareLbConfig)) return false;
          if (!object.Equals(LocalityWeightedLbConfig, other.LocalityWeightedLbConfig)) return false;
          if (LocalityConfigSpecifierCase != other.LocalityConfigSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (healthyPanicThreshold_ != null) hash ^= HealthyPanicThreshold.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) hash ^= ZoneAwareLbConfig.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) hash ^= LocalityWeightedLbConfig.GetHashCode();
          hash ^= (int) localityConfigSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (healthyPanicThreshold_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalityWeightedLbConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CommonLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.healthyPanicThreshold_ != null) {
            if (healthyPanicThreshold_ == null) {
              healthyPanicThreshold_ = new global::Envoy.Type.Percent();
            }
            HealthyPanicThreshold.MergeFrom(other.HealthyPanicThreshold);
          }
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              if (ZoneAwareLbConfig == null) {
                ZoneAwareLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
              }
              ZoneAwareLbConfig.MergeFrom(other.ZoneAwareLbConfig);
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              if (LocalityWeightedLbConfig == null) {
                LocalityWeightedLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
              }
              LocalityWeightedLbConfig.MergeFrom(other.LocalityWeightedLbConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  healthyPanicThreshold_ = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(healthyPanicThreshold_);
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the CommonLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Configuration for :ref:`zone aware routing
          /// &lt;arch_overview_load_balancing_zone_aware_routing>`.
          /// </summary>
          public sealed partial class ZoneAwareLbConfig : pb::IMessage<ZoneAwareLbConfig> {
            private static readonly pb::MessageParser<ZoneAwareLbConfig> _parser = new pb::MessageParser<ZoneAwareLbConfig>(() => new ZoneAwareLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<ZoneAwareLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig(ZoneAwareLbConfig other) : this() {
              RoutingEnabled = other.routingEnabled_ != null ? other.RoutingEnabled.Clone() : null;
              MinClusterSize = other.MinClusterSize;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig Clone() {
              return new ZoneAwareLbConfig(this);
            }

            /// <summary>Field number for the "routing_enabled" field.</summary>
            public const int RoutingEnabledFieldNumber = 1;
            private global::Envoy.Type.Percent routingEnabled_;
            /// <summary>
            /// Configures percentage of requests that will be considered for zone aware routing
            /// if zone aware routing is configured. If not specified, the default is 100%.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Envoy.Type.Percent RoutingEnabled {
              get { return routingEnabled_; }
              set {
                routingEnabled_ = value;
              }
            }

            /// <summary>Field number for the "min_cluster_size" field.</summary>
            public const int MinClusterSizeFieldNumber = 2;
            private static readonly pb::FieldCodec<ulong?> _single_minClusterSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(18);
            private ulong? minClusterSize_;
            /// <summary>
            /// Configures minimum upstream cluster size required for zone aware routing
            /// If upstream cluster size is less than specified, zone aware routing is not performed
            /// even if zone aware routing is configured. If not specified, the default is 6.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ulong? MinClusterSize {
              get { return minClusterSize_; }
              set {
                minClusterSize_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as ZoneAwareLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(ZoneAwareLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(RoutingEnabled, other.RoutingEnabled)) return false;
              if (MinClusterSize != other.MinClusterSize) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (routingEnabled_ != null) hash ^= RoutingEnabled.GetHashCode();
              if (minClusterSize_ != null) hash ^= MinClusterSize.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(output, MinClusterSize);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (routingEnabled_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                size += _single_minClusterSize_codec.CalculateSizeWithTag(MinClusterSize);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(ZoneAwareLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.routingEnabled_ != null) {
                if (routingEnabled_ == null) {
                  routingEnabled_ = new global::Envoy.Type.Percent();
                }
                RoutingEnabled.MergeFrom(other.RoutingEnabled);
              }
              if (other.minClusterSize_ != null) {
                if (minClusterSize_ == null || other.MinClusterSize != 0UL) {
                  MinClusterSize = other.MinClusterSize;
                }
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      routingEnabled_ = new global::Envoy.Type.Percent();
                    }
                    input.ReadMessage(routingEnabled_);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Configuration for :ref:`locality weighted load balancing
          /// &lt;arch_overview_load_balancing_locality_weighted_lb>`
          /// </summary>
          public sealed partial class LocalityWeightedLbConfig : pb::IMessage<LocalityWeightedLbConfig> {
            private static readonly pb::MessageParser<LocalityWeightedLbConfig> _parser = new pb::MessageParser<LocalityWeightedLbConfig>(() => new LocalityWeightedLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LocalityWeightedLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig(LocalityWeightedLbConfig other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig Clone() {
              return new LocalityWeightedLbConfig(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LocalityWeightedLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LocalityWeightedLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LocalityWeightedLbConfig other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// An extensible structure containing the address Envoy should bind to when
  /// establishing upstream connections.
  /// </summary>
  public sealed partial class UpstreamBindConfig : pb::IMessage<UpstreamBindConfig> {
    private static readonly pb::MessageParser<UpstreamBindConfig> _parser = new pb::MessageParser<UpstreamBindConfig>(() => new UpstreamBindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamBindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig(UpstreamBindConfig other) : this() {
      SourceAddress = other.sourceAddress_ != null ? other.SourceAddress.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig Clone() {
      return new UpstreamBindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Address sourceAddress_;
    /// <summary>
    /// The address Envoy should bind to when establishing upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Address SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamBindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamBindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamBindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          sourceAddress_ = new global::Envoy.Api.V2.Core.Address();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              sourceAddress_ = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(sourceAddress_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class UpstreamConnectionOptions : pb::IMessage<UpstreamConnectionOptions> {
    private static readonly pb::MessageParser<UpstreamConnectionOptions> _parser = new pb::MessageParser<UpstreamConnectionOptions>(() => new UpstreamConnectionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamConnectionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions(UpstreamConnectionOptions other) : this() {
      TcpKeepalive = other.tcpKeepalive_ != null ? other.TcpKeepalive.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions Clone() {
      return new UpstreamConnectionOptions(this);
    }

    /// <summary>Field number for the "tcp_keepalive" field.</summary>
    public const int TcpKeepaliveFieldNumber = 1;
    private global::Envoy.Api.V2.Core.TcpKeepalive tcpKeepalive_;
    /// <summary>
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.TcpKeepalive TcpKeepalive {
      get { return tcpKeepalive_; }
      set {
        tcpKeepalive_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamConnectionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamConnectionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TcpKeepalive, other.TcpKeepalive)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tcpKeepalive_ != null) hash ^= TcpKeepalive.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tcpKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpKeepalive);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamConnectionOptions other) {
      if (other == null) {
        return;
      }
      if (other.tcpKeepalive_ != null) {
        if (tcpKeepalive_ == null) {
          tcpKeepalive_ = new global::Envoy.Api.V2.Core.TcpKeepalive();
        }
        TcpKeepalive.MergeFrom(other.TcpKeepalive);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              tcpKeepalive_ = new global::Envoy.Api.V2.Core.TcpKeepalive();
            }
            input.ReadMessage(tcpKeepalive_);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
