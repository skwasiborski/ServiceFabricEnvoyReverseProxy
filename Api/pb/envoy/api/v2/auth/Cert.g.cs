// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/auth/cert.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Auth {

  /// <summary>Holder for reflection information generated from envoy/api/v2/auth/cert.proto</summary>
  public static partial class CertReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/auth/cert.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CertReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChxlbnZveS9hcGkvdjIvYXV0aC9jZXJ0LnByb3RvEhFlbnZveS5hcGkudjIu",
            "YXV0aBocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxolZW52b3kvYXBp",
            "L3YyL2NvcmUvY29uZmlnX3NvdXJjZS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVm",
            "L3dyYXBwZXJzLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90bxoUZ29n",
            "b3Byb3RvL2dvZ28ucHJvdG8izAIKDVRsc1BhcmFtZXRlcnMSXgocdGxzX21p",
            "bmltdW1fcHJvdG9jb2xfdmVyc2lvbhgBIAEoDjIsLmVudm95LmFwaS52Mi5h",
            "dXRoLlRsc1BhcmFtZXRlcnMuVGxzUHJvdG9jb2xCCrrpwAMFggECEAESXgoc",
            "dGxzX21heGltdW1fcHJvdG9jb2xfdmVyc2lvbhgCIAEoDjIsLmVudm95LmFw",
            "aS52Mi5hdXRoLlRsc1BhcmFtZXRlcnMuVGxzUHJvdG9jb2xCCrrpwAMFggEC",
            "EAESFQoNY2lwaGVyX3N1aXRlcxgDIAMoCRITCgtlY2RoX2N1cnZlcxgEIAMo",
            "CSJPCgtUbHNQcm90b2NvbBIMCghUTFNfQVVUTxAAEgsKB1RMU3YxXzAQARIL",
            "CgdUTFN2MV8xEAISCwoHVExTdjFfMhADEgsKB1RMU3YxXzMQBCKoAgoOVGxz",
            "Q2VydGlmaWNhdGUSOAoRY2VydGlmaWNhdGVfY2hhaW4YASABKAsyHS5lbnZv",
            "eS5hcGkudjIuY29yZS5EYXRhU291cmNlEjIKC3ByaXZhdGVfa2V5GAIgASgL",
            "Mh0uZW52b3kuYXBpLnYyLmNvcmUuRGF0YVNvdXJjZRIvCghwYXNzd29yZBgD",
            "IAEoCzIdLmVudm95LmFwaS52Mi5jb3JlLkRhdGFTb3VyY2USMgoLb2NzcF9z",
            "dGFwbGUYBCABKAsyHS5lbnZveS5hcGkudjIuY29yZS5EYXRhU291cmNlEkMK",
            "HHNpZ25lZF9jZXJ0aWZpY2F0ZV90aW1lc3RhbXAYBSADKAsyHS5lbnZveS5h",
            "cGkudjIuY29yZS5EYXRhU291cmNlIk8KFFRsc1Nlc3Npb25UaWNrZXRLZXlz",
            "EjcKBGtleXMYASADKAsyHS5lbnZveS5hcGkudjIuY29yZS5EYXRhU291cmNl",
            "Qgq66cADBZIBAggBIqoDChxDZXJ0aWZpY2F0ZVZhbGlkYXRpb25Db250ZXh0",
            "EjEKCnRydXN0ZWRfY2EYASABKAsyHS5lbnZveS5hcGkudjIuY29yZS5EYXRh",
            "U291cmNlEjEKF3ZlcmlmeV9jZXJ0aWZpY2F0ZV9zcGtpGAMgAygJQhC66cAD",
            "C5IBCCIGcgQgLCgsEjEKF3ZlcmlmeV9jZXJ0aWZpY2F0ZV9oYXNoGAIgAygJ",
            "QhC66cADC5IBCCIGcgQgQChfEh8KF3ZlcmlmeV9zdWJqZWN0X2FsdF9uYW1l",
            "GAQgAygJEjcKE3JlcXVpcmVfb2NzcF9zdGFwbGUYBSABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuQm9vbFZhbHVlEkgKJHJlcXVpcmVfc2lnbmVkX2NlcnRpZmlj",
            "YXRlX3RpbWVzdGFtcBgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFs",
            "dWUSKgoDY3JsGAcgASgLMh0uZW52b3kuYXBpLnYyLmNvcmUuRGF0YVNvdXJj",
            "ZRIhChlhbGxvd19leHBpcmVkX2NlcnRpZmljYXRlGAggASgIIrAEChBDb21t",
            "b25UbHNDb250ZXh0EjQKCnRsc19wYXJhbXMYASABKAsyIC5lbnZveS5hcGku",
            "djIuYXV0aC5UbHNQYXJhbWV0ZXJzEkcKEHRsc19jZXJ0aWZpY2F0ZXMYAiAD",
            "KAsyIS5lbnZveS5hcGkudjIuYXV0aC5UbHNDZXJ0aWZpY2F0ZUIKuunAAwWS",
            "AQIQARJOCiJ0bHNfY2VydGlmaWNhdGVfc2RzX3NlY3JldF9jb25maWdzGAYg",
            "AygLMiIuZW52b3kuYXBpLnYyLmF1dGguU2RzU2VjcmV0Q29uZmlnEk0KEnZh",
            "bGlkYXRpb25fY29udGV4dBgDIAEoCzIvLmVudm95LmFwaS52Mi5hdXRoLkNl",
            "cnRpZmljYXRlVmFsaWRhdGlvbkNvbnRleHRIABJSCiR2YWxpZGF0aW9uX2Nv",
            "bnRleHRfc2RzX3NlY3JldF9jb25maWcYByABKAsyIi5lbnZveS5hcGkudjIu",
            "YXV0aC5TZHNTZWNyZXRDb25maWdIABIWCg5hbHBuX3Byb3RvY29scxgEIAMo",
            "CRJLCg1kZXByZWNhdGVkX3YxGAUgASgLMjAuZW52b3kuYXBpLnYyLmF1dGgu",
            "Q29tbW9uVGxzQ29udGV4dC5EZXByZWNhdGVkVjFCAhgBGioKDERlcHJlY2F0",
            "ZWRWMRIaChJhbHRfYWxwbl9wcm90b2NvbHMYASABKAlCGQoXdmFsaWRhdGlv",
            "bl9jb250ZXh0X3R5cGUiiwEKElVwc3RyZWFtVGxzQ29udGV4dBI/ChJjb21t",
            "b25fdGxzX2NvbnRleHQYASABKAsyIy5lbnZveS5hcGkudjIuYXV0aC5Db21t",
            "b25UbHNDb250ZXh0EhcKA3NuaRgCIAEoCUIKuunAAwVyAyj/ARIbChNhbGxv",
            "d19yZW5lZ290aWF0aW9uGAMgASgIIoEDChREb3duc3RyZWFtVGxzQ29udGV4",
            "dBI/ChJjb21tb25fdGxzX2NvbnRleHQYASABKAsyIy5lbnZveS5hcGkudjIu",
            "YXV0aC5Db21tb25UbHNDb250ZXh0Ej4KGnJlcXVpcmVfY2xpZW50X2NlcnRp",
            "ZmljYXRlGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIvCgty",
            "ZXF1aXJlX3NuaRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUS",
            "RgoTc2Vzc2lvbl90aWNrZXRfa2V5cxgEIAEoCzInLmVudm95LmFwaS52Mi5h",
            "dXRoLlRsc1Nlc3Npb25UaWNrZXRLZXlzSAASUwolc2Vzc2lvbl90aWNrZXRf",
            "a2V5c19zZHNfc2VjcmV0X2NvbmZpZxgFIAEoCzIiLmVudm95LmFwaS52Mi5h",
            "dXRoLlNkc1NlY3JldENvbmZpZ0gAQhoKGHNlc3Npb25fdGlja2V0X2tleXNf",
            "dHlwZSJUCg9TZHNTZWNyZXRDb25maWcSDAoEbmFtZRgBIAEoCRIzCgpzZHNf",
            "Y29uZmlnGAIgASgLMh8uZW52b3kuYXBpLnYyLmNvcmUuQ29uZmlnU291cmNl",
            "IvMBCgZTZWNyZXQSDAoEbmFtZRgBIAEoCRI8Cg90bHNfY2VydGlmaWNhdGUY",
            "AiABKAsyIS5lbnZveS5hcGkudjIuYXV0aC5UbHNDZXJ0aWZpY2F0ZUgAEkYK",
            "E3Nlc3Npb25fdGlja2V0X2tleXMYAyABKAsyJy5lbnZveS5hcGkudjIuYXV0",
            "aC5UbHNTZXNzaW9uVGlja2V0S2V5c0gAEk0KEnZhbGlkYXRpb25fY29udGV4",
            "dBgEIAEoCzIvLmVudm95LmFwaS52Mi5hdXRoLkNlcnRpZmljYXRlVmFsaWRh",
            "dGlvbkNvbnRleHRIAEIGCgR0eXBlQgpaBGF1dGio4h4BYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.TlsParameters), global::Envoy.Api.V2.Auth.TlsParameters.Parser, new[]{ "TlsMinimumProtocolVersion", "TlsMaximumProtocolVersion", "CipherSuites", "EcdhCurves" }, null, new[]{ typeof(global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.TlsCertificate), global::Envoy.Api.V2.Auth.TlsCertificate.Parser, new[]{ "CertificateChain", "PrivateKey", "Password", "OcspStaple", "SignedCertificateTimestamp" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.TlsSessionTicketKeys), global::Envoy.Api.V2.Auth.TlsSessionTicketKeys.Parser, new[]{ "Keys" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.CertificateValidationContext), global::Envoy.Api.V2.Auth.CertificateValidationContext.Parser, new[]{ "TrustedCa", "VerifyCertificateSpki", "VerifyCertificateHash", "VerifySubjectAltName", "RequireOcspStaple", "RequireSignedCertificateTimestamp", "Crl", "AllowExpiredCertificate" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.CommonTlsContext), global::Envoy.Api.V2.Auth.CommonTlsContext.Parser, new[]{ "TlsParams", "TlsCertificates", "TlsCertificateSdsSecretConfigs", "ValidationContext", "ValidationContextSdsSecretConfig", "AlpnProtocols", "DeprecatedV1" }, new[]{ "ValidationContextType" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1), global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1.Parser, new[]{ "AltAlpnProtocols" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.UpstreamTlsContext), global::Envoy.Api.V2.Auth.UpstreamTlsContext.Parser, new[]{ "CommonTlsContext", "Sni", "AllowRenegotiation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.DownstreamTlsContext), global::Envoy.Api.V2.Auth.DownstreamTlsContext.Parser, new[]{ "CommonTlsContext", "RequireClientCertificate", "RequireSni", "SessionTicketKeys", "SessionTicketKeysSdsSecretConfig" }, new[]{ "SessionTicketKeysType" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.SdsSecretConfig), global::Envoy.Api.V2.Auth.SdsSecretConfig.Parser, new[]{ "Name", "SdsConfig" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Auth.Secret), global::Envoy.Api.V2.Auth.Secret.Parser, new[]{ "Name", "TlsCertificate", "SessionTicketKeys", "ValidationContext" }, new[]{ "Type" }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class TlsParameters : pb::IMessage<TlsParameters> {
    private static readonly pb::MessageParser<TlsParameters> _parser = new pb::MessageParser<TlsParameters>(() => new TlsParameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TlsParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsParameters(TlsParameters other) : this() {
      tlsMinimumProtocolVersion_ = other.tlsMinimumProtocolVersion_;
      tlsMaximumProtocolVersion_ = other.tlsMaximumProtocolVersion_;
      cipherSuites_ = other.cipherSuites_.Clone();
      ecdhCurves_ = other.ecdhCurves_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsParameters Clone() {
      return new TlsParameters(this);
    }

    /// <summary>Field number for the "tls_minimum_protocol_version" field.</summary>
    public const int TlsMinimumProtocolVersionFieldNumber = 1;
    private global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol tlsMinimumProtocolVersion_ = 0;
    /// <summary>
    /// Minimum TLS protocol version.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol TlsMinimumProtocolVersion {
      get { return tlsMinimumProtocolVersion_; }
      set {
        tlsMinimumProtocolVersion_ = value;
      }
    }

    /// <summary>Field number for the "tls_maximum_protocol_version" field.</summary>
    public const int TlsMaximumProtocolVersionFieldNumber = 2;
    private global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol tlsMaximumProtocolVersion_ = 0;
    /// <summary>
    /// Maximum TLS protocol version.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol TlsMaximumProtocolVersion {
      get { return tlsMaximumProtocolVersion_; }
      set {
        tlsMaximumProtocolVersion_ = value;
      }
    }

    /// <summary>Field number for the "cipher_suites" field.</summary>
    public const int CipherSuitesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_cipherSuites_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> cipherSuites_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified, the TLS listener will only support the specified `cipher list
    /// &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_.
    /// If not specified, the default list:
    ///
    /// .. code-block:: none
    ///
    ///   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
    ///   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
    ///   ECDHE-ECDSA-AES128-SHA
    ///   ECDHE-RSA-AES128-SHA
    ///   AES128-GCM-SHA256
    ///   AES128-SHA
    ///   ECDHE-ECDSA-AES256-GCM-SHA384
    ///   ECDHE-RSA-AES256-GCM-SHA384
    ///   ECDHE-ECDSA-AES256-SHA
    ///   ECDHE-RSA-AES256-SHA
    ///   AES256-GCM-SHA384
    ///   AES256-SHA
    ///
    /// will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CipherSuites {
      get { return cipherSuites_; }
    }

    /// <summary>Field number for the "ecdh_curves" field.</summary>
    public const int EcdhCurvesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_ecdhCurves_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> ecdhCurves_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified, the TLS connection will only support the specified ECDH
    /// curves. If not specified, the default curves (X25519, P-256) will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EcdhCurves {
      get { return ecdhCurves_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TlsParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TlsParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TlsMinimumProtocolVersion != other.TlsMinimumProtocolVersion) return false;
      if (TlsMaximumProtocolVersion != other.TlsMaximumProtocolVersion) return false;
      if(!cipherSuites_.Equals(other.cipherSuites_)) return false;
      if(!ecdhCurves_.Equals(other.ecdhCurves_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (TlsMinimumProtocolVersion != 0) hash ^= TlsMinimumProtocolVersion.GetHashCode();
      if (TlsMaximumProtocolVersion != 0) hash ^= TlsMaximumProtocolVersion.GetHashCode();
      hash ^= cipherSuites_.GetHashCode();
      hash ^= ecdhCurves_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (TlsMinimumProtocolVersion != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TlsMinimumProtocolVersion);
      }
      if (TlsMaximumProtocolVersion != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TlsMaximumProtocolVersion);
      }
      cipherSuites_.WriteTo(output, _repeated_cipherSuites_codec);
      ecdhCurves_.WriteTo(output, _repeated_ecdhCurves_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (TlsMinimumProtocolVersion != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TlsMinimumProtocolVersion);
      }
      if (TlsMaximumProtocolVersion != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TlsMaximumProtocolVersion);
      }
      size += cipherSuites_.CalculateSize(_repeated_cipherSuites_codec);
      size += ecdhCurves_.CalculateSize(_repeated_ecdhCurves_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TlsParameters other) {
      if (other == null) {
        return;
      }
      if (other.TlsMinimumProtocolVersion != 0) {
        TlsMinimumProtocolVersion = other.TlsMinimumProtocolVersion;
      }
      if (other.TlsMaximumProtocolVersion != 0) {
        TlsMaximumProtocolVersion = other.TlsMaximumProtocolVersion;
      }
      cipherSuites_.Add(other.cipherSuites_);
      ecdhCurves_.Add(other.ecdhCurves_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            tlsMinimumProtocolVersion_ = (global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 16: {
            tlsMaximumProtocolVersion_ = (global::Envoy.Api.V2.Auth.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 26: {
            cipherSuites_.AddEntriesFrom(input, _repeated_cipherSuites_codec);
            break;
          }
          case 34: {
            ecdhCurves_.AddEntriesFrom(input, _repeated_ecdhCurves_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TlsParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum TlsProtocol {
        /// <summary>
        /// Envoy will choose the optimal TLS version.
        /// </summary>
        [pbr::OriginalName("TLS_AUTO")] TlsAuto = 0,
        /// <summary>
        /// TLS 1.0
        /// </summary>
        [pbr::OriginalName("TLSv1_0")] Tlsv10 = 1,
        /// <summary>
        /// TLS 1.1
        /// </summary>
        [pbr::OriginalName("TLSv1_1")] Tlsv11 = 2,
        /// <summary>
        /// TLS 1.2
        /// </summary>
        [pbr::OriginalName("TLSv1_2")] Tlsv12 = 3,
        /// <summary>
        /// TLS 1.3
        /// </summary>
        [pbr::OriginalName("TLSv1_3")] Tlsv13 = 4,
      }

    }
    #endregion

  }

  public sealed partial class TlsCertificate : pb::IMessage<TlsCertificate> {
    private static readonly pb::MessageParser<TlsCertificate> _parser = new pb::MessageParser<TlsCertificate>(() => new TlsCertificate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TlsCertificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsCertificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsCertificate(TlsCertificate other) : this() {
      CertificateChain = other.certificateChain_ != null ? other.CertificateChain.Clone() : null;
      PrivateKey = other.privateKey_ != null ? other.PrivateKey.Clone() : null;
      Password = other.password_ != null ? other.Password.Clone() : null;
      OcspStaple = other.ocspStaple_ != null ? other.OcspStaple.Clone() : null;
      signedCertificateTimestamp_ = other.signedCertificateTimestamp_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsCertificate Clone() {
      return new TlsCertificate(this);
    }

    /// <summary>Field number for the "certificate_chain" field.</summary>
    public const int CertificateChainFieldNumber = 1;
    private global::Envoy.Api.V2.Core.DataSource certificateChain_;
    /// <summary>
    /// The TLS certificate chain.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource CertificateChain {
      get { return certificateChain_; }
      set {
        certificateChain_ = value;
      }
    }

    /// <summary>Field number for the "private_key" field.</summary>
    public const int PrivateKeyFieldNumber = 2;
    private global::Envoy.Api.V2.Core.DataSource privateKey_;
    /// <summary>
    /// The TLS private key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource PrivateKey {
      get { return privateKey_; }
      set {
        privateKey_ = value;
      }
    }

    /// <summary>Field number for the "password" field.</summary>
    public const int PasswordFieldNumber = 3;
    private global::Envoy.Api.V2.Core.DataSource password_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource Password {
      get { return password_; }
      set {
        password_ = value;
      }
    }

    /// <summary>Field number for the "ocsp_staple" field.</summary>
    public const int OcspStapleFieldNumber = 4;
    private global::Envoy.Api.V2.Core.DataSource ocspStaple_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource OcspStaple {
      get { return ocspStaple_; }
      set {
        ocspStaple_ = value;
      }
    }

    /// <summary>Field number for the "signed_certificate_timestamp" field.</summary>
    public const int SignedCertificateTimestampFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.DataSource> _repeated_signedCertificateTimestamp_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Core.DataSource.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource> signedCertificateTimestamp_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource>();
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource> SignedCertificateTimestamp {
      get { return signedCertificateTimestamp_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TlsCertificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TlsCertificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CertificateChain, other.CertificateChain)) return false;
      if (!object.Equals(PrivateKey, other.PrivateKey)) return false;
      if (!object.Equals(Password, other.Password)) return false;
      if (!object.Equals(OcspStaple, other.OcspStaple)) return false;
      if(!signedCertificateTimestamp_.Equals(other.signedCertificateTimestamp_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (certificateChain_ != null) hash ^= CertificateChain.GetHashCode();
      if (privateKey_ != null) hash ^= PrivateKey.GetHashCode();
      if (password_ != null) hash ^= Password.GetHashCode();
      if (ocspStaple_ != null) hash ^= OcspStaple.GetHashCode();
      hash ^= signedCertificateTimestamp_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (certificateChain_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CertificateChain);
      }
      if (privateKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrivateKey);
      }
      if (password_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Password);
      }
      if (ocspStaple_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(OcspStaple);
      }
      signedCertificateTimestamp_.WriteTo(output, _repeated_signedCertificateTimestamp_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (certificateChain_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertificateChain);
      }
      if (privateKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrivateKey);
      }
      if (password_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Password);
      }
      if (ocspStaple_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OcspStaple);
      }
      size += signedCertificateTimestamp_.CalculateSize(_repeated_signedCertificateTimestamp_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TlsCertificate other) {
      if (other == null) {
        return;
      }
      if (other.certificateChain_ != null) {
        if (certificateChain_ == null) {
          certificateChain_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        CertificateChain.MergeFrom(other.CertificateChain);
      }
      if (other.privateKey_ != null) {
        if (privateKey_ == null) {
          privateKey_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        PrivateKey.MergeFrom(other.PrivateKey);
      }
      if (other.password_ != null) {
        if (password_ == null) {
          password_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        Password.MergeFrom(other.Password);
      }
      if (other.ocspStaple_ != null) {
        if (ocspStaple_ == null) {
          ocspStaple_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        OcspStaple.MergeFrom(other.OcspStaple);
      }
      signedCertificateTimestamp_.Add(other.signedCertificateTimestamp_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (certificateChain_ == null) {
              certificateChain_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(certificateChain_);
            break;
          }
          case 18: {
            if (privateKey_ == null) {
              privateKey_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(privateKey_);
            break;
          }
          case 26: {
            if (password_ == null) {
              password_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(password_);
            break;
          }
          case 34: {
            if (ocspStaple_ == null) {
              ocspStaple_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(ocspStaple_);
            break;
          }
          case 42: {
            signedCertificateTimestamp_.AddEntriesFrom(input, _repeated_signedCertificateTimestamp_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class TlsSessionTicketKeys : pb::IMessage<TlsSessionTicketKeys> {
    private static readonly pb::MessageParser<TlsSessionTicketKeys> _parser = new pb::MessageParser<TlsSessionTicketKeys>(() => new TlsSessionTicketKeys());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TlsSessionTicketKeys> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsSessionTicketKeys() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsSessionTicketKeys(TlsSessionTicketKeys other) : this() {
      keys_ = other.keys_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TlsSessionTicketKeys Clone() {
      return new TlsSessionTicketKeys(this);
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.DataSource> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V2.Core.DataSource.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource> keys_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource>();
    /// <summary>
    /// Keys for encrypting and decrypting TLS session tickets. The
    /// first key in the array contains the key to encrypt all new sessions created by this context.
    /// All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
    /// by, for example, putting the new key first, and the previous key second.
    ///
    /// If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
    /// is not specified, the TLS library will still support resuming sessions via tickets, but it will
    /// use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
    /// or on different hosts.
    ///
    /// Each key must contain exactly 80 bytes of cryptographically-secure random data. For
    /// example, the output of ``openssl rand 80``.
    ///
    /// .. attention::
    ///
    ///   Using this feature has serious security considerations and risks. Improper handling of keys
    ///   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
    ///   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
    ///   discussion. To minimize the risk, you must:
    ///
    ///   * Keep the session ticket keys at least as secure as your TLS certificate private keys
    ///   * Rotate session ticket keys at least daily, and preferably hourly
    ///   * Always generate keys using a cryptographically-secure random data source
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.DataSource> Keys {
      get { return keys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TlsSessionTicketKeys);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TlsSessionTicketKeys other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keys_.Equals(other.keys_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keys_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keys_.WriteTo(output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TlsSessionTicketKeys other) {
      if (other == null) {
        return;
      }
      keys_.Add(other.keys_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class CertificateValidationContext : pb::IMessage<CertificateValidationContext> {
    private static readonly pb::MessageParser<CertificateValidationContext> _parser = new pb::MessageParser<CertificateValidationContext>(() => new CertificateValidationContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateValidationContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateValidationContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateValidationContext(CertificateValidationContext other) : this() {
      TrustedCa = other.trustedCa_ != null ? other.TrustedCa.Clone() : null;
      verifyCertificateSpki_ = other.verifyCertificateSpki_.Clone();
      verifyCertificateHash_ = other.verifyCertificateHash_.Clone();
      verifySubjectAltName_ = other.verifySubjectAltName_.Clone();
      RequireOcspStaple = other.RequireOcspStaple;
      RequireSignedCertificateTimestamp = other.RequireSignedCertificateTimestamp;
      Crl = other.crl_ != null ? other.Crl.Clone() : null;
      allowExpiredCertificate_ = other.allowExpiredCertificate_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateValidationContext Clone() {
      return new CertificateValidationContext(this);
    }

    /// <summary>Field number for the "trusted_ca" field.</summary>
    public const int TrustedCaFieldNumber = 1;
    private global::Envoy.Api.V2.Core.DataSource trustedCa_;
    /// <summary>
    /// TLS certificate data containing certificate authority certificates to use in verifying
    /// a presented peer certificate (e.g. server certificate for clusters or client certificate
    /// for listeners). If not specified and a peer certificate is presented it will not be
    /// verified. By default, a client certificate is optional, unless one of the additional
    /// options (:ref:`require_client_certificate
    /// &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or
    /// :ref:`verify_subject_alt_name
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name>`) is also
    /// specified.
    ///
    /// See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification>` for a list of common
    /// system CA locations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource TrustedCa {
      get { return trustedCa_; }
      set {
        trustedCa_ = value;
      }
    }

    /// <summary>Field number for the "verify_certificate_spki" field.</summary>
    public const int VerifyCertificateSpkiFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_verifyCertificateSpki_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> verifyCertificateSpki_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
    /// SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
    /// matches one of the specified values.
    ///
    /// A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
    /// can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -noout -pubkey \
    ///     | openssl pkey -pubin -outform DER \
    ///     | openssl dgst -sha256 -binary \
    ///     | openssl enc -base64
    ///   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
    ///
    /// This is the format used in HTTP Public Key Pinning.
    ///
    /// When both:
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
    /// a hash matching value from either of the lists will result in the certificate being accepted.
    ///
    /// .. attention::
    ///
    ///   This option is preferred over :ref:`verify_certificate_hash
    ///   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,
    ///   because SPKI is tied to a private key, so it doesn't change when the certificate
    ///   is renewed using the same private key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> VerifyCertificateSpki {
      get { return verifyCertificateSpki_; }
    }

    /// <summary>Field number for the "verify_certificate_hash" field.</summary>
    public const int VerifyCertificateHashFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_verifyCertificateHash_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> verifyCertificateHash_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
    /// the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
    ///
    /// A hex-encoded SHA-256 of the certificate can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
    ///   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
    ///
    /// A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
    /// can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
    ///   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
    ///
    /// Both of those formats are acceptable.
    ///
    /// When both:
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
    /// a hash matching value from either of the lists will result in the certificate being accepted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> VerifyCertificateHash {
      get { return verifyCertificateHash_; }
    }

    /// <summary>Field number for the "verify_subject_alt_name" field.</summary>
    public const int VerifySubjectAltNameFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_verifySubjectAltName_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> verifySubjectAltName_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An optional list of Subject Alternative Names. If specified, Envoy will verify that the
    /// Subject Alternative Name of the presented certificate matches one of the specified values.
    ///
    /// .. attention::
    ///
    ///   Subject Alternative Names are easily spoofable and verifying only them is insecure,
    ///   therefore this option must be used together with :ref:`trusted_ca
    ///   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> VerifySubjectAltName {
      get { return verifySubjectAltName_; }
    }

    /// <summary>Field number for the "require_ocsp_staple" field.</summary>
    public const int RequireOcspStapleFieldNumber = 5;
    private static readonly pb::FieldCodec<bool?> _single_requireOcspStaple_codec = pb::FieldCodec.ForStructWrapper<bool>(42);
    private bool? requireOcspStaple_;
    /// <summary>
    /// [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? RequireOcspStaple {
      get { return requireOcspStaple_; }
      set {
        requireOcspStaple_ = value;
      }
    }

    /// <summary>Field number for the "require_signed_certificate_timestamp" field.</summary>
    public const int RequireSignedCertificateTimestampFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_requireSignedCertificateTimestamp_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? requireSignedCertificateTimestamp_;
    /// <summary>
    /// [#not-implemented-hide:] Must present signed certificate time-stamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? RequireSignedCertificateTimestamp {
      get { return requireSignedCertificateTimestamp_; }
      set {
        requireSignedCertificateTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "crl" field.</summary>
    public const int CrlFieldNumber = 7;
    private global::Envoy.Api.V2.Core.DataSource crl_;
    /// <summary>
    /// An optional `certificate revocation list
    /// &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
    /// (in PEM format). If specified, Envoy will verify that the presented peer
    /// certificate has not been revoked by this CRL. If this DataSource contains
    /// multiple CRLs, all of them will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource Crl {
      get { return crl_; }
      set {
        crl_ = value;
      }
    }

    /// <summary>Field number for the "allow_expired_certificate" field.</summary>
    public const int AllowExpiredCertificateFieldNumber = 8;
    private bool allowExpiredCertificate_;
    /// <summary>
    /// If specified, Envoy will not reject expired certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowExpiredCertificate {
      get { return allowExpiredCertificate_; }
      set {
        allowExpiredCertificate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateValidationContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateValidationContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TrustedCa, other.TrustedCa)) return false;
      if(!verifyCertificateSpki_.Equals(other.verifyCertificateSpki_)) return false;
      if(!verifyCertificateHash_.Equals(other.verifyCertificateHash_)) return false;
      if(!verifySubjectAltName_.Equals(other.verifySubjectAltName_)) return false;
      if (RequireOcspStaple != other.RequireOcspStaple) return false;
      if (RequireSignedCertificateTimestamp != other.RequireSignedCertificateTimestamp) return false;
      if (!object.Equals(Crl, other.Crl)) return false;
      if (AllowExpiredCertificate != other.AllowExpiredCertificate) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (trustedCa_ != null) hash ^= TrustedCa.GetHashCode();
      hash ^= verifyCertificateSpki_.GetHashCode();
      hash ^= verifyCertificateHash_.GetHashCode();
      hash ^= verifySubjectAltName_.GetHashCode();
      if (requireOcspStaple_ != null) hash ^= RequireOcspStaple.GetHashCode();
      if (requireSignedCertificateTimestamp_ != null) hash ^= RequireSignedCertificateTimestamp.GetHashCode();
      if (crl_ != null) hash ^= Crl.GetHashCode();
      if (AllowExpiredCertificate != false) hash ^= AllowExpiredCertificate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (trustedCa_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrustedCa);
      }
      verifyCertificateHash_.WriteTo(output, _repeated_verifyCertificateHash_codec);
      verifyCertificateSpki_.WriteTo(output, _repeated_verifyCertificateSpki_codec);
      verifySubjectAltName_.WriteTo(output, _repeated_verifySubjectAltName_codec);
      if (requireOcspStaple_ != null) {
        _single_requireOcspStaple_codec.WriteTagAndValue(output, RequireOcspStaple);
      }
      if (requireSignedCertificateTimestamp_ != null) {
        _single_requireSignedCertificateTimestamp_codec.WriteTagAndValue(output, RequireSignedCertificateTimestamp);
      }
      if (crl_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Crl);
      }
      if (AllowExpiredCertificate != false) {
        output.WriteRawTag(64);
        output.WriteBool(AllowExpiredCertificate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (trustedCa_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrustedCa);
      }
      size += verifyCertificateSpki_.CalculateSize(_repeated_verifyCertificateSpki_codec);
      size += verifyCertificateHash_.CalculateSize(_repeated_verifyCertificateHash_codec);
      size += verifySubjectAltName_.CalculateSize(_repeated_verifySubjectAltName_codec);
      if (requireOcspStaple_ != null) {
        size += _single_requireOcspStaple_codec.CalculateSizeWithTag(RequireOcspStaple);
      }
      if (requireSignedCertificateTimestamp_ != null) {
        size += _single_requireSignedCertificateTimestamp_codec.CalculateSizeWithTag(RequireSignedCertificateTimestamp);
      }
      if (crl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Crl);
      }
      if (AllowExpiredCertificate != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateValidationContext other) {
      if (other == null) {
        return;
      }
      if (other.trustedCa_ != null) {
        if (trustedCa_ == null) {
          trustedCa_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        TrustedCa.MergeFrom(other.TrustedCa);
      }
      verifyCertificateSpki_.Add(other.verifyCertificateSpki_);
      verifyCertificateHash_.Add(other.verifyCertificateHash_);
      verifySubjectAltName_.Add(other.verifySubjectAltName_);
      if (other.requireOcspStaple_ != null) {
        if (requireOcspStaple_ == null || other.RequireOcspStaple != false) {
          RequireOcspStaple = other.RequireOcspStaple;
        }
      }
      if (other.requireSignedCertificateTimestamp_ != null) {
        if (requireSignedCertificateTimestamp_ == null || other.RequireSignedCertificateTimestamp != false) {
          RequireSignedCertificateTimestamp = other.RequireSignedCertificateTimestamp;
        }
      }
      if (other.crl_ != null) {
        if (crl_ == null) {
          crl_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        Crl.MergeFrom(other.Crl);
      }
      if (other.AllowExpiredCertificate != false) {
        AllowExpiredCertificate = other.AllowExpiredCertificate;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (trustedCa_ == null) {
              trustedCa_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(trustedCa_);
            break;
          }
          case 18: {
            verifyCertificateHash_.AddEntriesFrom(input, _repeated_verifyCertificateHash_codec);
            break;
          }
          case 26: {
            verifyCertificateSpki_.AddEntriesFrom(input, _repeated_verifyCertificateSpki_codec);
            break;
          }
          case 34: {
            verifySubjectAltName_.AddEntriesFrom(input, _repeated_verifySubjectAltName_codec);
            break;
          }
          case 42: {
            bool? value = _single_requireOcspStaple_codec.Read(input);
            if (requireOcspStaple_ == null || value != false) {
              RequireOcspStaple = value;
            }
            break;
          }
          case 50: {
            bool? value = _single_requireSignedCertificateTimestamp_codec.Read(input);
            if (requireSignedCertificateTimestamp_ == null || value != false) {
              RequireSignedCertificateTimestamp = value;
            }
            break;
          }
          case 58: {
            if (crl_ == null) {
              crl_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(crl_);
            break;
          }
          case 64: {
            AllowExpiredCertificate = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// TLS context shared by both client and server TLS contexts.
  /// </summary>
  public sealed partial class CommonTlsContext : pb::IMessage<CommonTlsContext> {
    private static readonly pb::MessageParser<CommonTlsContext> _parser = new pb::MessageParser<CommonTlsContext>(() => new CommonTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CommonTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommonTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommonTlsContext(CommonTlsContext other) : this() {
      TlsParams = other.tlsParams_ != null ? other.TlsParams.Clone() : null;
      tlsCertificates_ = other.tlsCertificates_.Clone();
      tlsCertificateSdsSecretConfigs_ = other.tlsCertificateSdsSecretConfigs_.Clone();
      alpnProtocols_ = other.alpnProtocols_.Clone();
      DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
      switch (other.ValidationContextTypeCase) {
        case ValidationContextTypeOneofCase.ValidationContext:
          ValidationContext = other.ValidationContext.Clone();
          break;
        case ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig:
          ValidationContextSdsSecretConfig = other.ValidationContextSdsSecretConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommonTlsContext Clone() {
      return new CommonTlsContext(this);
    }

    /// <summary>Field number for the "tls_params" field.</summary>
    public const int TlsParamsFieldNumber = 1;
    private global::Envoy.Api.V2.Auth.TlsParameters tlsParams_;
    /// <summary>
    /// TLS protocol versions, cipher suites etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsParameters TlsParams {
      get { return tlsParams_; }
      set {
        tlsParams_ = value;
      }
    }

    /// <summary>Field number for the "tls_certificates" field.</summary>
    public const int TlsCertificatesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Auth.TlsCertificate> _repeated_tlsCertificates_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Api.V2.Auth.TlsCertificate.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Auth.TlsCertificate> tlsCertificates_ = new pbc::RepeatedField<global::Envoy.Api.V2.Auth.TlsCertificate>();
    /// <summary>
    /// Multiple TLS certificates can be associated with the same context.
    /// E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
    ///
    /// .. attention::
    ///
    ///   Although this is a list, currently only a single certificate is supported. This will be
    ///   relaxed in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Auth.TlsCertificate> TlsCertificates {
      get { return tlsCertificates_; }
    }

    /// <summary>Field number for the "tls_certificate_sds_secret_configs" field.</summary>
    public const int TlsCertificateSdsSecretConfigsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Auth.SdsSecretConfig> _repeated_tlsCertificateSdsSecretConfigs_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Api.V2.Auth.SdsSecretConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Auth.SdsSecretConfig> tlsCertificateSdsSecretConfigs_ = new pbc::RepeatedField<global::Envoy.Api.V2.Auth.SdsSecretConfig>();
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Auth.SdsSecretConfig> TlsCertificateSdsSecretConfigs {
      get { return tlsCertificateSdsSecretConfigs_; }
    }

    /// <summary>Field number for the "validation_context" field.</summary>
    public const int ValidationContextFieldNumber = 3;
    /// <summary>
    /// How to validate peer certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.CertificateValidationContext ValidationContext {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext ? (global::Envoy.Api.V2.Auth.CertificateValidationContext) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContext;
      }
    }

    /// <summary>Field number for the "validation_context_sds_secret_config" field.</summary>
    public const int ValidationContextSdsSecretConfigFieldNumber = 7;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.SdsSecretConfig ValidationContextSdsSecretConfig {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig ? (global::Envoy.Api.V2.Auth.SdsSecretConfig) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig;
      }
    }

    /// <summary>Field number for the "alpn_protocols" field.</summary>
    public const int AlpnProtocolsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_alpnProtocols_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> alpnProtocols_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Supplies the list of ALPN protocols that the listener should expose. In
    /// practice this is likely to be set to one of two values (see the
    /// :ref:`codec_type &lt;config_http_conn_man_codec_type>` parameter in the HTTP connection
    /// manager for more information):
    ///
    /// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
    /// * "http/1.1" If the listener is only going to support HTTP/1.1.
    ///
    /// There is no default for this parameter. If empty, Envoy will not expose ALPN.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AlpnProtocols {
      get { return alpnProtocols_; }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 5;
    private global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    private object validationContextType_;
    /// <summary>Enum of possible cases for the "validation_context_type" oneof.</summary>
    public enum ValidationContextTypeOneofCase {
      None = 0,
      ValidationContext = 3,
      ValidationContextSdsSecretConfig = 7,
    }
    private ValidationContextTypeOneofCase validationContextTypeCase_ = ValidationContextTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidationContextTypeOneofCase ValidationContextTypeCase {
      get { return validationContextTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValidationContextType() {
      validationContextTypeCase_ = ValidationContextTypeOneofCase.None;
      validationContextType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CommonTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CommonTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TlsParams, other.TlsParams)) return false;
      if(!tlsCertificates_.Equals(other.tlsCertificates_)) return false;
      if(!tlsCertificateSdsSecretConfigs_.Equals(other.tlsCertificateSdsSecretConfigs_)) return false;
      if (!object.Equals(ValidationContext, other.ValidationContext)) return false;
      if (!object.Equals(ValidationContextSdsSecretConfig, other.ValidationContextSdsSecretConfig)) return false;
      if(!alpnProtocols_.Equals(other.alpnProtocols_)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (ValidationContextTypeCase != other.ValidationContextTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tlsParams_ != null) hash ^= TlsParams.GetHashCode();
      hash ^= tlsCertificates_.GetHashCode();
      hash ^= tlsCertificateSdsSecretConfigs_.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) hash ^= ValidationContext.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) hash ^= ValidationContextSdsSecretConfig.GetHashCode();
      hash ^= alpnProtocols_.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      hash ^= (int) validationContextTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (tlsParams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TlsParams);
      }
      tlsCertificates_.WriteTo(output, _repeated_tlsCertificates_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
        output.WriteRawTag(26);
        output.WriteMessage(ValidationContext);
      }
      alpnProtocols_.WriteTo(output, _repeated_alpnProtocols_codec);
      if (deprecatedV1_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DeprecatedV1);
      }
      tlsCertificateSdsSecretConfigs_.WriteTo(output, _repeated_tlsCertificateSdsSecretConfigs_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
        output.WriteRawTag(58);
        output.WriteMessage(ValidationContextSdsSecretConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tlsParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsParams);
      }
      size += tlsCertificates_.CalculateSize(_repeated_tlsCertificates_codec);
      size += tlsCertificateSdsSecretConfigs_.CalculateSize(_repeated_tlsCertificateSdsSecretConfigs_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContext);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextSdsSecretConfig);
      }
      size += alpnProtocols_.CalculateSize(_repeated_alpnProtocols_codec);
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CommonTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.tlsParams_ != null) {
        if (tlsParams_ == null) {
          tlsParams_ = new global::Envoy.Api.V2.Auth.TlsParameters();
        }
        TlsParams.MergeFrom(other.TlsParams);
      }
      tlsCertificates_.Add(other.tlsCertificates_);
      tlsCertificateSdsSecretConfigs_.Add(other.tlsCertificateSdsSecretConfigs_);
      alpnProtocols_.Add(other.alpnProtocols_);
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          deprecatedV1_ = new global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      switch (other.ValidationContextTypeCase) {
        case ValidationContextTypeOneofCase.ValidationContext:
          if (ValidationContext == null) {
            ValidationContext = new global::Envoy.Api.V2.Auth.CertificateValidationContext();
          }
          ValidationContext.MergeFrom(other.ValidationContext);
          break;
        case ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig:
          if (ValidationContextSdsSecretConfig == null) {
            ValidationContextSdsSecretConfig = new global::Envoy.Api.V2.Auth.SdsSecretConfig();
          }
          ValidationContextSdsSecretConfig.MergeFrom(other.ValidationContextSdsSecretConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tlsParams_ == null) {
              tlsParams_ = new global::Envoy.Api.V2.Auth.TlsParameters();
            }
            input.ReadMessage(tlsParams_);
            break;
          }
          case 18: {
            tlsCertificates_.AddEntriesFrom(input, _repeated_tlsCertificates_codec);
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Auth.CertificateValidationContext subBuilder = new global::Envoy.Api.V2.Auth.CertificateValidationContext();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
              subBuilder.MergeFrom(ValidationContext);
            }
            input.ReadMessage(subBuilder);
            ValidationContext = subBuilder;
            break;
          }
          case 34: {
            alpnProtocols_.AddEntriesFrom(input, _repeated_alpnProtocols_codec);
            break;
          }
          case 42: {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Api.V2.Auth.CommonTlsContext.Types.DeprecatedV1();
            }
            input.ReadMessage(deprecatedV1_);
            break;
          }
          case 50: {
            tlsCertificateSdsSecretConfigs_.AddEntriesFrom(input, _repeated_tlsCertificateSdsSecretConfigs_codec);
            break;
          }
          case 58: {
            global::Envoy.Api.V2.Auth.SdsSecretConfig subBuilder = new global::Envoy.Api.V2.Auth.SdsSecretConfig();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
              subBuilder.MergeFrom(ValidationContextSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            ValidationContextSdsSecretConfig = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CommonTlsContext message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These fields are deprecated and only are used during the interim v1 -> v2
      /// transition period for internal purposes. They should not be used outside of
      /// the Envoy binary. [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Auth.CommonTlsContext.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          altAlpnProtocols_ = other.altAlpnProtocols_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "alt_alpn_protocols" field.</summary>
        public const int AltAlpnProtocolsFieldNumber = 1;
        private string altAlpnProtocols_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string AltAlpnProtocols {
          get { return altAlpnProtocols_; }
          set {
            altAlpnProtocols_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (AltAlpnProtocols != other.AltAlpnProtocols) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (AltAlpnProtocols.Length != 0) hash ^= AltAlpnProtocols.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (AltAlpnProtocols.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(AltAlpnProtocols);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (AltAlpnProtocols.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(AltAlpnProtocols);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.AltAlpnProtocols.Length != 0) {
            AltAlpnProtocols = other.AltAlpnProtocols;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                AltAlpnProtocols = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class UpstreamTlsContext : pb::IMessage<UpstreamTlsContext> {
    private static readonly pb::MessageParser<UpstreamTlsContext> _parser = new pb::MessageParser<UpstreamTlsContext>(() => new UpstreamTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamTlsContext(UpstreamTlsContext other) : this() {
      CommonTlsContext = other.commonTlsContext_ != null ? other.CommonTlsContext.Clone() : null;
      sni_ = other.sni_;
      allowRenegotiation_ = other.allowRenegotiation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamTlsContext Clone() {
      return new UpstreamTlsContext(this);
    }

    /// <summary>Field number for the "common_tls_context" field.</summary>
    public const int CommonTlsContextFieldNumber = 1;
    private global::Envoy.Api.V2.Auth.CommonTlsContext commonTlsContext_;
    /// <summary>
    /// Common TLS context settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.CommonTlsContext CommonTlsContext {
      get { return commonTlsContext_; }
      set {
        commonTlsContext_ = value;
      }
    }

    /// <summary>Field number for the "sni" field.</summary>
    public const int SniFieldNumber = 2;
    private string sni_ = "";
    /// <summary>
    /// SNI string to use when creating TLS backend connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Sni {
      get { return sni_; }
      set {
        sni_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_renegotiation" field.</summary>
    public const int AllowRenegotiationFieldNumber = 3;
    private bool allowRenegotiation_;
    /// <summary>
    /// If true, server-initiated TLS renegotiation will be allowed.
    ///
    /// .. attention::
    ///
    ///   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowRenegotiation {
      get { return allowRenegotiation_; }
      set {
        allowRenegotiation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CommonTlsContext, other.CommonTlsContext)) return false;
      if (Sni != other.Sni) return false;
      if (AllowRenegotiation != other.AllowRenegotiation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (commonTlsContext_ != null) hash ^= CommonTlsContext.GetHashCode();
      if (Sni.Length != 0) hash ^= Sni.GetHashCode();
      if (AllowRenegotiation != false) hash ^= AllowRenegotiation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (Sni.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Sni);
      }
      if (AllowRenegotiation != false) {
        output.WriteRawTag(24);
        output.WriteBool(AllowRenegotiation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (commonTlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CommonTlsContext);
      }
      if (Sni.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Sni);
      }
      if (AllowRenegotiation != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.commonTlsContext_ != null) {
        if (commonTlsContext_ == null) {
          commonTlsContext_ = new global::Envoy.Api.V2.Auth.CommonTlsContext();
        }
        CommonTlsContext.MergeFrom(other.CommonTlsContext);
      }
      if (other.Sni.Length != 0) {
        Sni = other.Sni;
      }
      if (other.AllowRenegotiation != false) {
        AllowRenegotiation = other.AllowRenegotiation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              commonTlsContext_ = new global::Envoy.Api.V2.Auth.CommonTlsContext();
            }
            input.ReadMessage(commonTlsContext_);
            break;
          }
          case 18: {
            Sni = input.ReadString();
            break;
          }
          case 24: {
            AllowRenegotiation = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class DownstreamTlsContext : pb::IMessage<DownstreamTlsContext> {
    private static readonly pb::MessageParser<DownstreamTlsContext> _parser = new pb::MessageParser<DownstreamTlsContext>(() => new DownstreamTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DownstreamTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DownstreamTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DownstreamTlsContext(DownstreamTlsContext other) : this() {
      CommonTlsContext = other.commonTlsContext_ != null ? other.CommonTlsContext.Clone() : null;
      RequireClientCertificate = other.RequireClientCertificate;
      RequireSni = other.RequireSni;
      switch (other.SessionTicketKeysTypeCase) {
        case SessionTicketKeysTypeOneofCase.SessionTicketKeys:
          SessionTicketKeys = other.SessionTicketKeys.Clone();
          break;
        case SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig:
          SessionTicketKeysSdsSecretConfig = other.SessionTicketKeysSdsSecretConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DownstreamTlsContext Clone() {
      return new DownstreamTlsContext(this);
    }

    /// <summary>Field number for the "common_tls_context" field.</summary>
    public const int CommonTlsContextFieldNumber = 1;
    private global::Envoy.Api.V2.Auth.CommonTlsContext commonTlsContext_;
    /// <summary>
    /// Common TLS context settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.CommonTlsContext CommonTlsContext {
      get { return commonTlsContext_; }
      set {
        commonTlsContext_ = value;
      }
    }

    /// <summary>Field number for the "require_client_certificate" field.</summary>
    public const int RequireClientCertificateFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_requireClientCertificate_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? requireClientCertificate_;
    /// <summary>
    /// If specified, Envoy will reject connections without a valid client
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? RequireClientCertificate {
      get { return requireClientCertificate_; }
      set {
        requireClientCertificate_ = value;
      }
    }

    /// <summary>Field number for the "require_sni" field.</summary>
    public const int RequireSniFieldNumber = 3;
    private static readonly pb::FieldCodec<bool?> _single_requireSni_codec = pb::FieldCodec.ForStructWrapper<bool>(26);
    private bool? requireSni_;
    /// <summary>
    /// If specified, Envoy will reject connections without a valid and matching SNI.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? RequireSni {
      get { return requireSni_; }
      set {
        requireSni_ = value;
      }
    }

    /// <summary>Field number for the "session_ticket_keys" field.</summary>
    public const int SessionTicketKeysFieldNumber = 4;
    /// <summary>
    /// TLS session ticket key settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsSessionTicketKeys SessionTicketKeys {
      get { return sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys ? (global::Envoy.Api.V2.Auth.TlsSessionTicketKeys) sessionTicketKeysType_ : null; }
      set {
        sessionTicketKeysType_ = value;
        sessionTicketKeysTypeCase_ = value == null ? SessionTicketKeysTypeOneofCase.None : SessionTicketKeysTypeOneofCase.SessionTicketKeys;
      }
    }

    /// <summary>Field number for the "session_ticket_keys_sds_secret_config" field.</summary>
    public const int SessionTicketKeysSdsSecretConfigFieldNumber = 5;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.SdsSecretConfig SessionTicketKeysSdsSecretConfig {
      get { return sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig ? (global::Envoy.Api.V2.Auth.SdsSecretConfig) sessionTicketKeysType_ : null; }
      set {
        sessionTicketKeysType_ = value;
        sessionTicketKeysTypeCase_ = value == null ? SessionTicketKeysTypeOneofCase.None : SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig;
      }
    }

    private object sessionTicketKeysType_;
    /// <summary>Enum of possible cases for the "session_ticket_keys_type" oneof.</summary>
    public enum SessionTicketKeysTypeOneofCase {
      None = 0,
      SessionTicketKeys = 4,
      SessionTicketKeysSdsSecretConfig = 5,
    }
    private SessionTicketKeysTypeOneofCase sessionTicketKeysTypeCase_ = SessionTicketKeysTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SessionTicketKeysTypeOneofCase SessionTicketKeysTypeCase {
      get { return sessionTicketKeysTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSessionTicketKeysType() {
      sessionTicketKeysTypeCase_ = SessionTicketKeysTypeOneofCase.None;
      sessionTicketKeysType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DownstreamTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DownstreamTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CommonTlsContext, other.CommonTlsContext)) return false;
      if (RequireClientCertificate != other.RequireClientCertificate) return false;
      if (RequireSni != other.RequireSni) return false;
      if (!object.Equals(SessionTicketKeys, other.SessionTicketKeys)) return false;
      if (!object.Equals(SessionTicketKeysSdsSecretConfig, other.SessionTicketKeysSdsSecretConfig)) return false;
      if (SessionTicketKeysTypeCase != other.SessionTicketKeysTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (commonTlsContext_ != null) hash ^= CommonTlsContext.GetHashCode();
      if (requireClientCertificate_ != null) hash ^= RequireClientCertificate.GetHashCode();
      if (requireSni_ != null) hash ^= RequireSni.GetHashCode();
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) hash ^= SessionTicketKeys.GetHashCode();
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) hash ^= SessionTicketKeysSdsSecretConfig.GetHashCode();
      hash ^= (int) sessionTicketKeysTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (requireClientCertificate_ != null) {
        _single_requireClientCertificate_codec.WriteTagAndValue(output, RequireClientCertificate);
      }
      if (requireSni_ != null) {
        _single_requireSni_codec.WriteTagAndValue(output, RequireSni);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
        output.WriteRawTag(34);
        output.WriteMessage(SessionTicketKeys);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
        output.WriteRawTag(42);
        output.WriteMessage(SessionTicketKeysSdsSecretConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (commonTlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CommonTlsContext);
      }
      if (requireClientCertificate_ != null) {
        size += _single_requireClientCertificate_codec.CalculateSizeWithTag(RequireClientCertificate);
      }
      if (requireSni_ != null) {
        size += _single_requireSni_codec.CalculateSizeWithTag(RequireSni);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTicketKeys);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTicketKeysSdsSecretConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DownstreamTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.commonTlsContext_ != null) {
        if (commonTlsContext_ == null) {
          commonTlsContext_ = new global::Envoy.Api.V2.Auth.CommonTlsContext();
        }
        CommonTlsContext.MergeFrom(other.CommonTlsContext);
      }
      if (other.requireClientCertificate_ != null) {
        if (requireClientCertificate_ == null || other.RequireClientCertificate != false) {
          RequireClientCertificate = other.RequireClientCertificate;
        }
      }
      if (other.requireSni_ != null) {
        if (requireSni_ == null || other.RequireSni != false) {
          RequireSni = other.RequireSni;
        }
      }
      switch (other.SessionTicketKeysTypeCase) {
        case SessionTicketKeysTypeOneofCase.SessionTicketKeys:
          if (SessionTicketKeys == null) {
            SessionTicketKeys = new global::Envoy.Api.V2.Auth.TlsSessionTicketKeys();
          }
          SessionTicketKeys.MergeFrom(other.SessionTicketKeys);
          break;
        case SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig:
          if (SessionTicketKeysSdsSecretConfig == null) {
            SessionTicketKeysSdsSecretConfig = new global::Envoy.Api.V2.Auth.SdsSecretConfig();
          }
          SessionTicketKeysSdsSecretConfig.MergeFrom(other.SessionTicketKeysSdsSecretConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              commonTlsContext_ = new global::Envoy.Api.V2.Auth.CommonTlsContext();
            }
            input.ReadMessage(commonTlsContext_);
            break;
          }
          case 18: {
            bool? value = _single_requireClientCertificate_codec.Read(input);
            if (requireClientCertificate_ == null || value != false) {
              RequireClientCertificate = value;
            }
            break;
          }
          case 26: {
            bool? value = _single_requireSni_codec.Read(input);
            if (requireSni_ == null || value != false) {
              RequireSni = value;
            }
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Auth.TlsSessionTicketKeys subBuilder = new global::Envoy.Api.V2.Auth.TlsSessionTicketKeys();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
              subBuilder.MergeFrom(SessionTicketKeys);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeys = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Auth.SdsSecretConfig subBuilder = new global::Envoy.Api.V2.Auth.SdsSecretConfig();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
              subBuilder.MergeFrom(SessionTicketKeysSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeysSdsSecretConfig = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#proto-status: experimental]
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class SdsSecretConfig : pb::IMessage<SdsSecretConfig> {
    private static readonly pb::MessageParser<SdsSecretConfig> _parser = new pb::MessageParser<SdsSecretConfig>(() => new SdsSecretConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SdsSecretConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SdsSecretConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SdsSecretConfig(SdsSecretConfig other) : this() {
      name_ = other.name_;
      SdsConfig = other.sdsConfig_ != null ? other.SdsConfig.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SdsSecretConfig Clone() {
      return new SdsSecretConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
    /// When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
    /// When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sds_config" field.</summary>
    public const int SdsConfigFieldNumber = 2;
    private global::Envoy.Api.V2.Core.ConfigSource sdsConfig_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.ConfigSource SdsConfig {
      get { return sdsConfig_; }
      set {
        sdsConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SdsSecretConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SdsSecretConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(SdsConfig, other.SdsConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (sdsConfig_ != null) hash ^= SdsConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (sdsConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SdsConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (sdsConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SdsConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SdsSecretConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.sdsConfig_ != null) {
        if (sdsConfig_ == null) {
          sdsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
        }
        SdsConfig.MergeFrom(other.SdsConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (sdsConfig_ == null) {
              sdsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            input.ReadMessage(sdsConfig_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#proto-status: experimental]
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class Secret : pb::IMessage<Secret> {
    private static readonly pb::MessageParser<Secret> _parser = new pb::MessageParser<Secret>(() => new Secret());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Secret> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Auth.CertReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Secret() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Secret(Secret other) : this() {
      name_ = other.name_;
      switch (other.TypeCase) {
        case TypeOneofCase.TlsCertificate:
          TlsCertificate = other.TlsCertificate.Clone();
          break;
        case TypeOneofCase.SessionTicketKeys:
          SessionTicketKeys = other.SessionTicketKeys.Clone();
          break;
        case TypeOneofCase.ValidationContext:
          ValidationContext = other.ValidationContext.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Secret Clone() {
      return new Secret(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tls_certificate" field.</summary>
    public const int TlsCertificateFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsCertificate TlsCertificate {
      get { return typeCase_ == TypeOneofCase.TlsCertificate ? (global::Envoy.Api.V2.Auth.TlsCertificate) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.TlsCertificate;
      }
    }

    /// <summary>Field number for the "session_ticket_keys" field.</summary>
    public const int SessionTicketKeysFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.TlsSessionTicketKeys SessionTicketKeys {
      get { return typeCase_ == TypeOneofCase.SessionTicketKeys ? (global::Envoy.Api.V2.Auth.TlsSessionTicketKeys) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.SessionTicketKeys;
      }
    }

    /// <summary>Field number for the "validation_context" field.</summary>
    public const int ValidationContextFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.CertificateValidationContext ValidationContext {
      get { return typeCase_ == TypeOneofCase.ValidationContext ? (global::Envoy.Api.V2.Auth.CertificateValidationContext) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.ValidationContext;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      TlsCertificate = 2,
      SessionTicketKeys = 3,
      ValidationContext = 4,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Secret);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Secret other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(TlsCertificate, other.TlsCertificate)) return false;
      if (!object.Equals(SessionTicketKeys, other.SessionTicketKeys)) return false;
      if (!object.Equals(ValidationContext, other.ValidationContext)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (typeCase_ == TypeOneofCase.TlsCertificate) hash ^= TlsCertificate.GetHashCode();
      if (typeCase_ == TypeOneofCase.SessionTicketKeys) hash ^= SessionTicketKeys.GetHashCode();
      if (typeCase_ == TypeOneofCase.ValidationContext) hash ^= ValidationContext.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (typeCase_ == TypeOneofCase.TlsCertificate) {
        output.WriteRawTag(18);
        output.WriteMessage(TlsCertificate);
      }
      if (typeCase_ == TypeOneofCase.SessionTicketKeys) {
        output.WriteRawTag(26);
        output.WriteMessage(SessionTicketKeys);
      }
      if (typeCase_ == TypeOneofCase.ValidationContext) {
        output.WriteRawTag(34);
        output.WriteMessage(ValidationContext);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (typeCase_ == TypeOneofCase.TlsCertificate) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsCertificate);
      }
      if (typeCase_ == TypeOneofCase.SessionTicketKeys) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTicketKeys);
      }
      if (typeCase_ == TypeOneofCase.ValidationContext) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContext);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Secret other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.TlsCertificate:
          if (TlsCertificate == null) {
            TlsCertificate = new global::Envoy.Api.V2.Auth.TlsCertificate();
          }
          TlsCertificate.MergeFrom(other.TlsCertificate);
          break;
        case TypeOneofCase.SessionTicketKeys:
          if (SessionTicketKeys == null) {
            SessionTicketKeys = new global::Envoy.Api.V2.Auth.TlsSessionTicketKeys();
          }
          SessionTicketKeys.MergeFrom(other.SessionTicketKeys);
          break;
        case TypeOneofCase.ValidationContext:
          if (ValidationContext == null) {
            ValidationContext = new global::Envoy.Api.V2.Auth.CertificateValidationContext();
          }
          ValidationContext.MergeFrom(other.ValidationContext);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Auth.TlsCertificate subBuilder = new global::Envoy.Api.V2.Auth.TlsCertificate();
            if (typeCase_ == TypeOneofCase.TlsCertificate) {
              subBuilder.MergeFrom(TlsCertificate);
            }
            input.ReadMessage(subBuilder);
            TlsCertificate = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Auth.TlsSessionTicketKeys subBuilder = new global::Envoy.Api.V2.Auth.TlsSessionTicketKeys();
            if (typeCase_ == TypeOneofCase.SessionTicketKeys) {
              subBuilder.MergeFrom(SessionTicketKeys);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeys = subBuilder;
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Auth.CertificateValidationContext subBuilder = new global::Envoy.Api.V2.Auth.CertificateValidationContext();
            if (typeCase_ == TypeOneofCase.ValidationContext) {
              subBuilder.MergeFrom(ValidationContext);
            }
            input.ReadMessage(subBuilder);
            ValidationContext = subBuilder;
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
