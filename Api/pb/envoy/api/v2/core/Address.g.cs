// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/core/address.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Core {

  /// <summary>Holder for reflection information generated from envoy/api/v2/core/address.proto</summary>
  public static partial class AddressReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/core/address.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AddressReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch9lbnZveS9hcGkvdjIvY29yZS9hZGRyZXNzLnByb3RvEhFlbnZveS5hcGku",
            "djIuY29yZRoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhd2YWxp",
            "ZGF0ZS92YWxpZGF0ZS5wcm90bxoUZ29nb3Byb3RvL2dvZ28ucHJvdG8iHwoE",
            "UGlwZRIXCgRwYXRoGAEgASgJQgm66cADBHICIAEilgIKDVNvY2tldEFkZHJl",
            "c3MSRwoIcHJvdG9jb2wYASABKA4yKS5lbnZveS5hcGkudjIuY29yZS5Tb2Nr",
            "ZXRBZGRyZXNzLlByb3RvY29sQgq66cADBYIBAhABEhoKB2FkZHJlc3MYAiAB",
            "KAlCCbrpwAMEcgIgARIhCgpwb3J0X3ZhbHVlGAMgASgNQgu66cADBioEGP//",
            "A0gAEhQKCm5hbWVkX3BvcnQYBCABKAlIABIVCg1yZXNvbHZlcl9uYW1lGAUg",
            "ASgJEhMKC2lwdjRfY29tcGF0GAYgASgIIiIKCFByb3RvY29sEgcKA1RDUBAA",
            "EgcKA1VEUBABGgSIox4AQhcKDnBvcnRfc3BlY2lmaWVyEgW46cADASK2AQoM",
            "VGNwS2VlcGFsaXZlEjYKEGtlZXBhbGl2ZV9wcm9iZXMYASABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWUSNAoOa2VlcGFsaXZlX3RpbWUYAiAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUSOAoSa2VlcGFsaXZl",
            "X2ludGVydmFsGAMgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVl",
            "IoQBCgpCaW5kQ29uZmlnEkgKDnNvdXJjZV9hZGRyZXNzGAEgASgLMiAuZW52",
            "b3kuYXBpLnYyLmNvcmUuU29ja2V0QWRkcmVzc0IOuunAAwWKAQIQAcjeHwAS",
            "LAoIZnJlZWJpbmQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVl",
            "IoABCgdBZGRyZXNzEjoKDnNvY2tldF9hZGRyZXNzGAEgASgLMiAuZW52b3ku",
            "YXBpLnYyLmNvcmUuU29ja2V0QWRkcmVzc0gAEicKBHBpcGUYAiABKAsyFy5l",
            "bnZveS5hcGkudjIuY29yZS5QaXBlSABCEAoHYWRkcmVzcxIFuOnAAwEibAoJ",
            "Q2lkclJhbmdlEiEKDmFkZHJlc3NfcHJlZml4GAEgASgJQgm66cADBHICIAES",
            "PAoKcHJlZml4X2xlbhgCIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZUIKuunAAwUqAxiAAUIEqOIeAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Pipe), global::Envoy.Api.V2.Core.Pipe.Parser, new[]{ "Path" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.SocketAddress), global::Envoy.Api.V2.Core.SocketAddress.Parser, new[]{ "Protocol", "Address", "PortValue", "NamedPort", "ResolverName", "Ipv4Compat" }, new[]{ "PortSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.TcpKeepalive), global::Envoy.Api.V2.Core.TcpKeepalive.Parser, new[]{ "KeepaliveProbes", "KeepaliveTime", "KeepaliveInterval" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.BindConfig), global::Envoy.Api.V2.Core.BindConfig.Parser, new[]{ "SourceAddress", "Freebind" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Address), global::Envoy.Api.V2.Core.Address.Parser, new[]{ "SocketAddress", "Pipe" }, new[]{ "Address" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.CidrRange), global::Envoy.Api.V2.Core.CidrRange.Parser, new[]{ "AddressPrefix", "PrefixLen" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Pipe : pb::IMessage<Pipe> {
    private static readonly pb::MessageParser<Pipe> _parser = new pb::MessageParser<Pipe>(() => new Pipe());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Pipe> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe(Pipe other) : this() {
      path_ = other.path_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe Clone() {
      return new Pipe(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private string path_ = "";
    /// <summary>
    /// Unix Domain Socket path. On Linux, paths starting with '@' will use the
    /// abstract namespace. The starting '@' is replaced by a null byte by Envoy.
    /// Paths starting with '@' will result in an error in environments other than
    /// Linux.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Path {
      get { return path_; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Pipe);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Pipe other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Path.Length != 0) hash ^= Path.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Path.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Pipe other) {
      if (other == null) {
        return;
      }
      if (other.Path.Length != 0) {
        Path = other.Path;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SocketAddress : pb::IMessage<SocketAddress> {
    private static readonly pb::MessageParser<SocketAddress> _parser = new pb::MessageParser<SocketAddress>(() => new SocketAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SocketAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress(SocketAddress other) : this() {
      protocol_ = other.protocol_;
      address_ = other.address_;
      resolverName_ = other.resolverName_;
      ipv4Compat_ = other.ipv4Compat_;
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress Clone() {
      return new SocketAddress(this);
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 1;
    private global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol protocol_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol Protocol {
      get { return protocol_; }
      set {
        protocol_ = value;
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private string address_ = "";
    /// <summary>
    /// The address for this socket. :ref:`Listeners &lt;config_listeners>` will bind
    /// to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
    /// to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
    /// It is possible to distinguish a Listener address via the prefix/suffix matching
    /// in :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>`.] When used
    /// within an upstream :ref:`BindConfig &lt;envoy_api_msg_core.BindConfig>`, the address
    /// controls the source address of outbound connections. For :ref:`clusters
    /// &lt;config_cluster_manager_cluster>`, the cluster type determines whether the
    /// address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS
    /// (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized
    /// via :ref:`resolver_name &lt;envoy_api_field_core.SocketAddress.resolver_name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port_value" field.</summary>
    public const int PortValueFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PortValue {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.PortValue ? (uint) portSpecifier_ : 0; }
      set {
        portSpecifier_ = value;
        portSpecifierCase_ = PortSpecifierOneofCase.PortValue;
      }
    }

    /// <summary>Field number for the "named_port" field.</summary>
    public const int NamedPortFieldNumber = 4;
    /// <summary>
    /// This is only valid if :ref:`resolver_name
    /// &lt;envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
    /// named resolver is capable of named port resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NamedPort {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.NamedPort ? (string) portSpecifier_ : ""; }
      set {
        portSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        portSpecifierCase_ = PortSpecifierOneofCase.NamedPort;
      }
    }

    /// <summary>Field number for the "resolver_name" field.</summary>
    public const int ResolverNameFieldNumber = 5;
    private string resolverName_ = "";
    /// <summary>
    /// The name of the resolver. This must have been registered with Envoy. If this is
    /// empty, a context dependent default applies. If address is a hostname this
    /// should be set for resolution other than DNS. If the address is a concrete
    /// IP address, no resolution will occur.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ResolverName {
      get { return resolverName_; }
      set {
        resolverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ipv4_compat" field.</summary>
    public const int Ipv4CompatFieldNumber = 6;
    private bool ipv4Compat_;
    /// <summary>
    /// When binding to an IPv6 address above, this enables `IPv4 compatibity
    /// &lt;https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
    /// allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
    /// IPv6 space as ``::FFFF:&lt;IPv4-address>``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Ipv4Compat {
      get { return ipv4Compat_; }
      set {
        ipv4Compat_ = value;
      }
    }

    private object portSpecifier_;
    /// <summary>Enum of possible cases for the "port_specifier" oneof.</summary>
    public enum PortSpecifierOneofCase {
      None = 0,
      PortValue = 3,
      NamedPort = 4,
    }
    private PortSpecifierOneofCase portSpecifierCase_ = PortSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PortSpecifierOneofCase PortSpecifierCase {
      get { return portSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPortSpecifier() {
      portSpecifierCase_ = PortSpecifierOneofCase.None;
      portSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SocketAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SocketAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Protocol != other.Protocol) return false;
      if (Address != other.Address) return false;
      if (PortValue != other.PortValue) return false;
      if (NamedPort != other.NamedPort) return false;
      if (ResolverName != other.ResolverName) return false;
      if (Ipv4Compat != other.Ipv4Compat) return false;
      if (PortSpecifierCase != other.PortSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Protocol != 0) hash ^= Protocol.GetHashCode();
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) hash ^= PortValue.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) hash ^= NamedPort.GetHashCode();
      if (ResolverName.Length != 0) hash ^= ResolverName.GetHashCode();
      if (Ipv4Compat != false) hash ^= Ipv4Compat.GetHashCode();
      hash ^= (int) portSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Protocol != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Protocol);
      }
      if (Address.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        output.WriteRawTag(24);
        output.WriteUInt32(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        output.WriteRawTag(34);
        output.WriteString(NamedPort);
      }
      if (ResolverName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ResolverName);
      }
      if (Ipv4Compat != false) {
        output.WriteRawTag(48);
        output.WriteBool(Ipv4Compat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Protocol != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Protocol);
      }
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NamedPort);
      }
      if (ResolverName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResolverName);
      }
      if (Ipv4Compat != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SocketAddress other) {
      if (other == null) {
        return;
      }
      if (other.Protocol != 0) {
        Protocol = other.Protocol;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      if (other.ResolverName.Length != 0) {
        ResolverName = other.ResolverName;
      }
      if (other.Ipv4Compat != false) {
        Ipv4Compat = other.Ipv4Compat;
      }
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            protocol_ = (global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol) input.ReadEnum();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
          case 24: {
            PortValue = input.ReadUInt32();
            break;
          }
          case 34: {
            NamedPort = input.ReadString();
            break;
          }
          case 42: {
            ResolverName = input.ReadString();
            break;
          }
          case 48: {
            Ipv4Compat = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SocketAddress message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Protocol {
        [pbr::OriginalName("TCP")] Tcp = 0,
        /// <summary>
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("UDP")] Udp = 1,
      }

    }
    #endregion

  }

  public sealed partial class TcpKeepalive : pb::IMessage<TcpKeepalive> {
    private static readonly pb::MessageParser<TcpKeepalive> _parser = new pb::MessageParser<TcpKeepalive>(() => new TcpKeepalive());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TcpKeepalive> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpKeepalive() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpKeepalive(TcpKeepalive other) : this() {
      KeepaliveProbes = other.KeepaliveProbes;
      KeepaliveTime = other.KeepaliveTime;
      KeepaliveInterval = other.KeepaliveInterval;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpKeepalive Clone() {
      return new TcpKeepalive(this);
    }

    /// <summary>Field number for the "keepalive_probes" field.</summary>
    public const int KeepaliveProbesFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveProbes_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? keepaliveProbes_;
    /// <summary>
    /// Maximum number of keepalive probes to send without response before deciding
    /// the connection is dead. Default is to use the OS level configuration (unless
    /// overridden, Linux defaults to 9.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? KeepaliveProbes {
      get { return keepaliveProbes_; }
      set {
        keepaliveProbes_ = value;
      }
    }

    /// <summary>Field number for the "keepalive_time" field.</summary>
    public const int KeepaliveTimeFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveTime_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? keepaliveTime_;
    /// <summary>
    /// The number of seconds a connection needs to be idle before keep-alive probes
    /// start being sent. Default is to use the OS level configuration (unless
    /// overridden, Linux defaults to 7200s (ie 2 hours.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? KeepaliveTime {
      get { return keepaliveTime_; }
      set {
        keepaliveTime_ = value;
      }
    }

    /// <summary>Field number for the "keepalive_interval" field.</summary>
    public const int KeepaliveIntervalFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveInterval_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? keepaliveInterval_;
    /// <summary>
    /// The number of seconds between keep-alive probes. Default is to use the OS
    /// level configuration (unless overridden, Linux defaults to 75s.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? KeepaliveInterval {
      get { return keepaliveInterval_; }
      set {
        keepaliveInterval_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TcpKeepalive);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TcpKeepalive other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (KeepaliveProbes != other.KeepaliveProbes) return false;
      if (KeepaliveTime != other.KeepaliveTime) return false;
      if (KeepaliveInterval != other.KeepaliveInterval) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (keepaliveProbes_ != null) hash ^= KeepaliveProbes.GetHashCode();
      if (keepaliveTime_ != null) hash ^= KeepaliveTime.GetHashCode();
      if (keepaliveInterval_ != null) hash ^= KeepaliveInterval.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (keepaliveProbes_ != null) {
        _single_keepaliveProbes_codec.WriteTagAndValue(output, KeepaliveProbes);
      }
      if (keepaliveTime_ != null) {
        _single_keepaliveTime_codec.WriteTagAndValue(output, KeepaliveTime);
      }
      if (keepaliveInterval_ != null) {
        _single_keepaliveInterval_codec.WriteTagAndValue(output, KeepaliveInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (keepaliveProbes_ != null) {
        size += _single_keepaliveProbes_codec.CalculateSizeWithTag(KeepaliveProbes);
      }
      if (keepaliveTime_ != null) {
        size += _single_keepaliveTime_codec.CalculateSizeWithTag(KeepaliveTime);
      }
      if (keepaliveInterval_ != null) {
        size += _single_keepaliveInterval_codec.CalculateSizeWithTag(KeepaliveInterval);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TcpKeepalive other) {
      if (other == null) {
        return;
      }
      if (other.keepaliveProbes_ != null) {
        if (keepaliveProbes_ == null || other.KeepaliveProbes != 0) {
          KeepaliveProbes = other.KeepaliveProbes;
        }
      }
      if (other.keepaliveTime_ != null) {
        if (keepaliveTime_ == null || other.KeepaliveTime != 0) {
          KeepaliveTime = other.KeepaliveTime;
        }
      }
      if (other.keepaliveInterval_ != null) {
        if (keepaliveInterval_ == null || other.KeepaliveInterval != 0) {
          KeepaliveInterval = other.KeepaliveInterval;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_keepaliveProbes_codec.Read(input);
            if (keepaliveProbes_ == null || value != 0) {
              KeepaliveProbes = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_keepaliveTime_codec.Read(input);
            if (keepaliveTime_ == null || value != 0) {
              KeepaliveTime = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_keepaliveInterval_codec.Read(input);
            if (keepaliveInterval_ == null || value != 0) {
              KeepaliveInterval = value;
            }
            break;
          }
        }
      }
    }

  }

  public sealed partial class BindConfig : pb::IMessage<BindConfig> {
    private static readonly pb::MessageParser<BindConfig> _parser = new pb::MessageParser<BindConfig>(() => new BindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig(BindConfig other) : this() {
      SourceAddress = other.sourceAddress_ != null ? other.SourceAddress.Clone() : null;
      Freebind = other.Freebind;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig Clone() {
      return new BindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.SocketAddress sourceAddress_;
    /// <summary>
    /// The address to bind to when creating a socket.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? freebind_;
    /// <summary>
    /// Whether to set the *IP_FREEBIND* option when creating the socket. When this
    /// flag is set to true, allows the :ref:`source_address
    /// &lt;envoy_api_field_UpstreamBindConfig.source_address>` to be an IP address
    /// that is not configured on the system running Envoy. When this flag is set
    /// to false, the option *IP_FREEBIND* is disabled on the socket. When this
    /// flag is not set (default), the socket is not modified, i.e. the option is
    /// neither enabled nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      if (Freebind != other.Freebind) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          sourceAddress_ = new global::Envoy.Api.V2.Core.SocketAddress();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              sourceAddress_ = new global::Envoy.Api.V2.Core.SocketAddress();
            }
            input.ReadMessage(sourceAddress_);
            break;
          }
          case 18: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Addresses specify either a logical or physical address and port, which are
  /// used to tell Envoy where to bind/listen, connect to upstream and find
  /// management servers.
  /// </summary>
  public sealed partial class Address : pb::IMessage<Address> {
    private static readonly pb::MessageParser<Address> _parser = new pb::MessageParser<Address>(() => new Address());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Address> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address(Address other) : this() {
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          SocketAddress = other.SocketAddress.Clone();
          break;
        case AddressOneofCase.Pipe:
          Pipe = other.Pipe.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address Clone() {
      return new Address(this);
    }

    /// <summary>Field number for the "socket_address" field.</summary>
    public const int SocketAddressFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress SocketAddress {
      get { return addressCase_ == AddressOneofCase.SocketAddress ? (global::Envoy.Api.V2.Core.SocketAddress) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.SocketAddress;
      }
    }

    /// <summary>Field number for the "pipe" field.</summary>
    public const int PipeFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Pipe Pipe {
      get { return addressCase_ == AddressOneofCase.Pipe ? (global::Envoy.Api.V2.Core.Pipe) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.Pipe;
      }
    }

    private object address_;
    /// <summary>Enum of possible cases for the "address" oneof.</summary>
    public enum AddressOneofCase {
      None = 0,
      SocketAddress = 1,
      Pipe = 2,
    }
    private AddressOneofCase addressCase_ = AddressOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddressOneofCase AddressCase {
      get { return addressCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAddress() {
      addressCase_ = AddressOneofCase.None;
      address_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Address);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Address other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SocketAddress, other.SocketAddress)) return false;
      if (!object.Equals(Pipe, other.Pipe)) return false;
      if (AddressCase != other.AddressCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (addressCase_ == AddressOneofCase.SocketAddress) hash ^= SocketAddress.GetHashCode();
      if (addressCase_ == AddressOneofCase.Pipe) hash ^= Pipe.GetHashCode();
      hash ^= (int) addressCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        output.WriteRawTag(10);
        output.WriteMessage(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        output.WriteRawTag(18);
        output.WriteMessage(Pipe);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pipe);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Address other) {
      if (other == null) {
        return;
      }
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          if (SocketAddress == null) {
            SocketAddress = new global::Envoy.Api.V2.Core.SocketAddress();
          }
          SocketAddress.MergeFrom(other.SocketAddress);
          break;
        case AddressOneofCase.Pipe:
          if (Pipe == null) {
            Pipe = new global::Envoy.Api.V2.Core.Pipe();
          }
          Pipe.MergeFrom(other.Pipe);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Api.V2.Core.SocketAddress subBuilder = new global::Envoy.Api.V2.Core.SocketAddress();
            if (addressCase_ == AddressOneofCase.SocketAddress) {
              subBuilder.MergeFrom(SocketAddress);
            }
            input.ReadMessage(subBuilder);
            SocketAddress = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Core.Pipe subBuilder = new global::Envoy.Api.V2.Core.Pipe();
            if (addressCase_ == AddressOneofCase.Pipe) {
              subBuilder.MergeFrom(Pipe);
            }
            input.ReadMessage(subBuilder);
            Pipe = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// CidrRange specifies an IP Address and a prefix length to construct
  /// the subnet mask for a `CIDR &lt;https://tools.ietf.org/html/rfc4632>`_ range.
  /// </summary>
  public sealed partial class CidrRange : pb::IMessage<CidrRange> {
    private static readonly pb::MessageParser<CidrRange> _parser = new pb::MessageParser<CidrRange>(() => new CidrRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CidrRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange(CidrRange other) : this() {
      addressPrefix_ = other.addressPrefix_;
      PrefixLen = other.PrefixLen;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange Clone() {
      return new CidrRange(this);
    }

    /// <summary>Field number for the "address_prefix" field.</summary>
    public const int AddressPrefixFieldNumber = 1;
    private string addressPrefix_ = "";
    /// <summary>
    /// IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AddressPrefix {
      get { return addressPrefix_; }
      set {
        addressPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "prefix_len" field.</summary>
    public const int PrefixLenFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_prefixLen_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? prefixLen_;
    /// <summary>
    /// Length of prefix, e.g. 0, 32.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PrefixLen {
      get { return prefixLen_; }
      set {
        prefixLen_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CidrRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CidrRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AddressPrefix != other.AddressPrefix) return false;
      if (PrefixLen != other.PrefixLen) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AddressPrefix.Length != 0) hash ^= AddressPrefix.GetHashCode();
      if (prefixLen_ != null) hash ^= PrefixLen.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AddressPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AddressPrefix);
      }
      if (prefixLen_ != null) {
        _single_prefixLen_codec.WriteTagAndValue(output, PrefixLen);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AddressPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AddressPrefix);
      }
      if (prefixLen_ != null) {
        size += _single_prefixLen_codec.CalculateSizeWithTag(PrefixLen);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CidrRange other) {
      if (other == null) {
        return;
      }
      if (other.AddressPrefix.Length != 0) {
        AddressPrefix = other.AddressPrefix;
      }
      if (other.prefixLen_ != null) {
        if (prefixLen_ == null || other.PrefixLen != 0) {
          PrefixLen = other.PrefixLen;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            AddressPrefix = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_prefixLen_codec.Read(input);
            if (prefixLen_ == null || value != 0) {
              PrefixLen = value;
            }
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
