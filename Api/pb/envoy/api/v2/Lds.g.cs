// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/lds.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from envoy/api/v2/lds.proto</summary>
  public static partial class LdsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/lds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZlbnZveS9hcGkvdjIvbGRzLnByb3RvEgxlbnZveS5hcGkudjIaH2Vudm95",
            "L2FwaS92Mi9jb3JlL2FkZHJlc3MucHJvdG8aHGVudm95L2FwaS92Mi9jb3Jl",
            "L2Jhc2UucHJvdG8aHGVudm95L2FwaS92Mi9kaXNjb3ZlcnkucHJvdG8aJGVu",
            "dm95L2FwaS92Mi9saXN0ZW5lci9saXN0ZW5lci5wcm90bxocZ29vZ2xlL2Fw",
            "aS9hbm5vdGF0aW9ucy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJz",
            "LnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90bxoUZ29nb3Byb3RvL2dv",
            "Z28ucHJvdG8imQYKCExpc3RlbmVyEgwKBG5hbWUYASABKAkSOwoHYWRkcmVz",
            "cxgCIAEoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3NCDrrpwAMFigEC",
            "EAHI3h8AEkkKDWZpbHRlcl9jaGFpbnMYAyADKAsyIi5lbnZveS5hcGkudjIu",
            "bGlzdGVuZXIuRmlsdGVyQ2hhaW5CDrrpwAMFkgECCAHI3h8AEjgKEHVzZV9v",
            "cmlnaW5hbF9kc3QYBCABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVl",
            "QgIYARJHCiFwZXJfY29ubmVjdGlvbl9idWZmZXJfbGltaXRfYnl0ZXMYBSAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUSLQoIbWV0YWRhdGEY",
            "BiABKAsyGy5lbnZveS5hcGkudjIuY29yZS5NZXRhZGF0YRI6Cg1kZXByZWNh",
            "dGVkX3YxGAcgASgLMiMuZW52b3kuYXBpLnYyLkxpc3RlbmVyLkRlcHJlY2F0",
            "ZWRWMRI0CgpkcmFpbl90eXBlGAggASgOMiAuZW52b3kuYXBpLnYyLkxpc3Rl",
            "bmVyLkRyYWluVHlwZRJFChBsaXN0ZW5lcl9maWx0ZXJzGAkgAygLMiUuZW52",
            "b3kuYXBpLnYyLmxpc3RlbmVyLkxpc3RlbmVyRmlsdGVyQgTI3h8AEi8KC3Ry",
            "YW5zcGFyZW50GAogASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIs",
            "CghmcmVlYmluZBgLIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUS",
            "QAoadGNwX2Zhc3Rfb3Blbl9xdWV1ZV9sZW5ndGgYDCABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuVUludDMyVmFsdWUaQAoMRGVwcmVjYXRlZFYxEjAKDGJpbmRf",
            "dG9fcG9ydBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUiKQoJ",
            "RHJhaW5UeXBlEgsKB0RFRkFVTFQQABIPCgtNT0RJRllfT05MWRABMusBChhM",
            "aXN0ZW5lckRpc2NvdmVyeVNlcnZpY2USWAoPU3RyZWFtTGlzdGVuZXJzEh4u",
            "ZW52b3kuYXBpLnYyLkRpc2NvdmVyeVJlcXVlc3QaHy5lbnZveS5hcGkudjIu",
            "RGlzY292ZXJ5UmVzcG9uc2UiACgBMAESdQoORmV0Y2hMaXN0ZW5lcnMSHi5l",
            "bnZveS5hcGkudjIuRGlzY292ZXJ5UmVxdWVzdBofLmVudm95LmFwaS52Mi5E",
            "aXNjb3ZlcnlSZXNwb25zZSIigtPkkwIcIhcvdjIvZGlzY292ZXJ5Omxpc3Rl",
            "bmVyczoBKkIHiAEBqOIeAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.DiscoveryReflection.Descriptor, global::Envoy.Api.V2.ListenerNS.ListenerReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener), global::Envoy.Api.V2.Listener.Parser, new[]{ "Name", "Address", "FilterChains", "UseOriginalDst", "PerConnectionBufferLimitBytes", "Metadata", "DeprecatedV1", "DrainType", "ListenerFilters", "Transparent", "Freebind", "TcpFastOpenQueueLength" }, null, new[]{ typeof(global::Envoy.Api.V2.Listener.Types.DrainType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener.Types.DeprecatedV1), global::Envoy.Api.V2.Listener.Types.DeprecatedV1.Parser, new[]{ "BindToPort" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Listener : pb::IMessage<Listener> {
    private static readonly pb::MessageParser<Listener> _parser = new pb::MessageParser<Listener>(() => new Listener());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Listener> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.LdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener(Listener other) : this() {
      name_ = other.name_;
      Address = other.address_ != null ? other.Address.Clone() : null;
      filterChains_ = other.filterChains_.Clone();
      UseOriginalDst = other.UseOriginalDst;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      Metadata = other.metadata_ != null ? other.Metadata.Clone() : null;
      DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
      drainType_ = other.drainType_;
      listenerFilters_ = other.listenerFilters_.Clone();
      Transparent = other.Transparent;
      Freebind = other.Freebind;
      TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener Clone() {
      return new Listener(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name by which this listener is known. If no name is provided,
    /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    /// updated or removed via :ref:`LDS &lt;config_listeners_lds>` a unique name must be provided.
    /// By default, the maximum length of a listener's name is limited to 60 characters. This limit can
    /// be increased by setting the :option:`--max-obj-name-len` command line argument to the desired
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private global::Envoy.Api.V2.Core.Address address_;
    /// <summary>
    /// The address that the listener should listen on. In general, the address must be unique, though
    /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    /// Linux as the actual port will be allocated by the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Address Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "filter_chains" field.</summary>
    public const int FilterChainsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ListenerNS.FilterChain> _repeated_filterChains_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.ListenerNS.FilterChain.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain> filterChains_ = new pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain>();
    /// <summary>
    /// A list of filter chains to consider for this listener. The
    /// :ref:`FilterChain &lt;envoy_api_msg_listener.FilterChain>` with the most specific
    /// :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
    /// connection.
    ///
    /// Example using SNI for filter chain selection can be found in the
    /// :ref:`FAQ entry &lt;faq_how_to_setup_sni>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.FilterChain> FilterChains {
      get { return filterChains_; }
    }

    /// <summary>Field number for the "use_original_dst" field.</summary>
    public const int UseOriginalDstFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_useOriginalDst_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? useOriginalDst_;
    /// <summary>
    /// If a connection is redirected using *iptables*, the port on which the proxy
    /// receives it might be different from the original destination address. When this flag is set to
    /// true, the listener hands off redirected connections to the listener associated with the
    /// original destination address. If there is no listener associated with the original destination
    /// address, the connection is handled by the listener that receives it. Defaults to false.
    ///
    /// .. attention::
    ///
    ///   This field is deprecated. Use :ref:`an original_dst &lt;config_listener_filters_original_dst>`
    ///   :ref:`listener filter &lt;envoy_api_field_Listener.listener_filters>` instead.
    ///
    ///   Note that hand off to another listener is *NOT* performed without this flag. Once
    ///   :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
    ///   will be removed, as filter chain matching can be used to select a filter chain based on the
    ///   restored destination address.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseOriginalDst {
      get { return useOriginalDst_; }
      set {
        useOriginalDst_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the listener’s new connection read and write buffers.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// Listener metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 7;
    private global::Envoy.Api.V2.Listener.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Listener.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    /// <summary>Field number for the "drain_type" field.</summary>
    public const int DrainTypeFieldNumber = 8;
    private global::Envoy.Api.V2.Listener.Types.DrainType drainType_ = 0;
    /// <summary>
    /// The type of draining to perform at a listener-wide level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Listener.Types.DrainType DrainType {
      get { return drainType_; }
      set {
        drainType_ = value;
      }
    }

    /// <summary>Field number for the "listener_filters" field.</summary>
    public const int ListenerFiltersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ListenerNS.ListenerFilter> _repeated_listenerFilters_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Api.V2.ListenerNS.ListenerFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter> listenerFilters_ = new pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter>();
    /// <summary>
    /// Listener filters have the opportunity to manipulate and augment the connection metadata that
    /// is used in connection filter chain matching, for example. These filters are run before any in
    /// :ref:`filter_chains &lt;envoy_api_field_Listener.filter_chains>`. Order matters as the
    /// filters are processed sequentially right after a socket has been accepted by the listener, and
    /// before a connection is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.ListenerNS.ListenerFilter> ListenerFilters {
      get { return listenerFilters_; }
    }

    /// <summary>Field number for the "transparent" field.</summary>
    public const int TransparentFieldNumber = 10;
    private static readonly pb::FieldCodec<bool?> _single_transparent_codec = pb::FieldCodec.ForStructWrapper<bool>(82);
    private bool? transparent_;
    /// <summary>
    /// Whether the listener should be set as a transparent socket.
    /// When this flag is set to true, connections can be redirected to the listener using an
    /// *iptables* *TPROXY* target, in which case the original source and destination addresses and
    /// ports are preserved on accepted connections. This flag should be used in combination with
    /// :ref:`an original_dst &lt;config_listener_filters_original_dst>` :ref:`listener filter
    /// &lt;envoy_api_field_Listener.listener_filters>` to mark the connections' local addresses as
    /// "restored." This can be used to hand off each redirected connection to another listener
    /// associated with the connection's destination address. Direct connections to the socket without
    /// using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
    /// therefore treated as if they were redirected.
    /// When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
    /// Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
    /// When this flag is not set (default), the socket is not modified, i.e. the transparent option
    /// is neither set nor reset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Transparent {
      get { return transparent_; }
      set {
        transparent_ = value;
      }
    }

    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 11;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(90);
    private bool? freebind_;
    /// <summary>
    /// Whether the listener should set the *IP_FREEBIND* socket option. When this
    /// flag is set to true, listeners can be bound to an IP address that is not
    /// configured on the system running Envoy. When this flag is set to false, the
    /// option *IP_FREEBIND* is disabled on the socket. When this flag is not set
    /// (default), the socket is not modified, i.e. the option is neither enabled
    /// nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }

    /// <summary>Field number for the "tcp_fast_open_queue_length" field.</summary>
    public const int TcpFastOpenQueueLengthFieldNumber = 12;
    private static readonly pb::FieldCodec<uint?> _single_tcpFastOpenQueueLength_codec = pb::FieldCodec.ForStructWrapper<uint>(98);
    private uint? tcpFastOpenQueueLength_;
    /// <summary>
    /// Whether the listener should accept TCP Fast Open (TFO) connections.
    /// When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
    /// the socket, with a queue length of the specified size
    /// (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1>`_).
    /// When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
    /// When this flag is not set (default), the socket is not modified,
    /// i.e. the option is neither enabled nor disabled.
    ///
    /// On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
    /// TCP_FASTOPEN.
    /// See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
    ///
    /// On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
    /// To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? TcpFastOpenQueueLength {
      get { return tcpFastOpenQueueLength_; }
      set {
        tcpFastOpenQueueLength_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Listener);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Listener other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Address, other.Address)) return false;
      if(!filterChains_.Equals(other.filterChains_)) return false;
      if (UseOriginalDst != other.UseOriginalDst) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (DrainType != other.DrainType) return false;
      if(!listenerFilters_.Equals(other.listenerFilters_)) return false;
      if (Transparent != other.Transparent) return false;
      if (Freebind != other.Freebind) return false;
      if (TcpFastOpenQueueLength != other.TcpFastOpenQueueLength) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (address_ != null) hash ^= Address.GetHashCode();
      hash ^= filterChains_.GetHashCode();
      if (useOriginalDst_ != null) hash ^= UseOriginalDst.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      if (DrainType != 0) hash ^= DrainType.GetHashCode();
      hash ^= listenerFilters_.GetHashCode();
      if (transparent_ != null) hash ^= Transparent.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      if (tcpFastOpenQueueLength_ != null) hash ^= TcpFastOpenQueueLength.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(output, TcpFastOpenQueueLength);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      size += filterChains_.CalculateSize(_repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        size += _single_useOriginalDst_codec.CalculateSizeWithTag(UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (DrainType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DrainType);
      }
      size += listenerFilters_.CalculateSize(_repeated_listenerFilters_codec);
      if (transparent_ != null) {
        size += _single_transparent_codec.CalculateSizeWithTag(Transparent);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        size += _single_tcpFastOpenQueueLength_codec.CalculateSizeWithTag(TcpFastOpenQueueLength);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Listener other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          address_ = new global::Envoy.Api.V2.Core.Address();
        }
        Address.MergeFrom(other.Address);
      }
      filterChains_.Add(other.filterChains_);
      if (other.useOriginalDst_ != null) {
        if (useOriginalDst_ == null || other.UseOriginalDst != false) {
          UseOriginalDst = other.UseOriginalDst;
        }
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          metadata_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          deprecatedV1_ = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      if (other.DrainType != 0) {
        DrainType = other.DrainType;
      }
      listenerFilters_.Add(other.listenerFilters_);
      if (other.transparent_ != null) {
        if (transparent_ == null || other.Transparent != false) {
          Transparent = other.Transparent;
        }
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      if (other.tcpFastOpenQueueLength_ != null) {
        if (tcpFastOpenQueueLength_ == null || other.TcpFastOpenQueueLength != 0) {
          TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              address_ = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(address_);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              metadata_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadata_);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(deprecatedV1_);
            break;
          }
          case 64: {
            drainType_ = (global::Envoy.Api.V2.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Listener message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DrainType {
        /// <summary>
        /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
        /// filter), listener removal/modification, and hot restart.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 0,
        /// <summary>
        /// Drain in response to listener removal/modification and hot restart. This setting does not
        /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
        /// and egress listeners.
        /// </summary>
        [pbr::OriginalName("MODIFY_ONLY")] ModifyOnly = 1,
      }

      /// <summary>
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Listener.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          BindToPort = other.BindToPort;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "bind_to_port" field.</summary>
        public const int BindToPortFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? bindToPort_;
        /// <summary>
        /// Whether the listener should bind to the port. A listener that doesn’t
        /// bind can only receive connections redirected from other listeners that
        /// set use_original_dst parameter to true. Default is true.
        ///
        /// [V2-API-DIFF] This is deprecated in v2, all Listeners will bind to their
        /// port. An additional filter chain must be created for every original
        /// destination port this listener may redirect to in v2, with the original
        /// port specified in the FilterChainMatch destination_port field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? BindToPort {
          get { return bindToPort_; }
          set {
            bindToPort_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BindToPort != other.BindToPort) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (bindToPort_ != null) {
            size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.bindToPort_ != null) {
            if (bindToPort_ == null || other.BindToPort != false) {
              BindToPort = other.BindToPort;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
