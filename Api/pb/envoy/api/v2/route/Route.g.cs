// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/route/route.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Route {

  /// <summary>Holder for reflection information generated from envoy/api/v2/route/route.proto</summary>
  public static partial class RouteReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/route/route.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RouteReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch5lbnZveS9hcGkvdjIvcm91dGUvcm91dGUucHJvdG8SEmVudm95LmFwaS52",
            "Mi5yb3V0ZRocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxoWZW52b3kv",
            "dHlwZS9yYW5nZS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnBy",
            "b3RvGhxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvGh5nb29nbGUvcHJv",
            "dG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3Rv",
            "GhRnb2dvcHJvdG8vZ29nby5wcm90byLyBQoLVmlydHVhbEhvc3QSFwoEbmFt",
            "ZRgBIAEoCUIJuunAAwRyAiABEhsKB2RvbWFpbnMYAiADKAlCCrrpwAMFkgEC",
            "CAESLwoGcm91dGVzGAMgAygLMhkuZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRl",
            "QgTI3h8AEkcKC3JlcXVpcmVfdGxzGAQgASgOMjIuZW52b3kuYXBpLnYyLnJv",
            "dXRlLlZpcnR1YWxIb3N0LlRsc1JlcXVpcmVtZW50VHlwZRI8ChB2aXJ0dWFs",
            "X2NsdXN0ZXJzGAUgAygLMiIuZW52b3kuYXBpLnYyLnJvdXRlLlZpcnR1YWxD",
            "bHVzdGVyEjIKC3JhdGVfbGltaXRzGAYgAygLMh0uZW52b3kuYXBpLnYyLnJv",
            "dXRlLlJhdGVMaW1pdBJEChZyZXF1ZXN0X2hlYWRlcnNfdG9fYWRkGAcgAygL",
            "MiQuZW52b3kuYXBpLnYyLmNvcmUuSGVhZGVyVmFsdWVPcHRpb24SRQoXcmVz",
            "cG9uc2VfaGVhZGVyc190b19hZGQYCiADKAsyJC5lbnZveS5hcGkudjIuY29y",
            "ZS5IZWFkZXJWYWx1ZU9wdGlvbhIiChpyZXNwb25zZV9oZWFkZXJzX3RvX3Jl",
            "bW92ZRgLIAMoCRIsCgRjb3JzGAggASgLMh4uZW52b3kuYXBpLnYyLnJvdXRl",
            "LkNvcnNQb2xpY3kSTwoRcGVyX2ZpbHRlcl9jb25maWcYDCADKAsyNC5lbnZv",
            "eS5hcGkudjIucm91dGUuVmlydHVhbEhvc3QuUGVyRmlsdGVyQ29uZmlnRW50",
            "cnkaTwoUUGVyRmlsdGVyQ29uZmlnRW50cnkSCwoDa2V5GAEgASgJEiYKBXZh",
            "bHVlGAIgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdDoCOAEiOgoSVGxz",
            "UmVxdWlyZW1lbnRUeXBlEggKBE5PTkUQABIRCg1FWFRFUk5BTF9PTkxZEAES",
            "BwoDQUxMEAJKBAgJEAoiiQQKBVJvdXRlEj0KBW1hdGNoGAEgASgLMh4uZW52",
            "b3kuYXBpLnYyLnJvdXRlLlJvdXRlTWF0Y2hCDrrpwAMFigECEAHI3h8AEjAK",
            "BXJvdXRlGAIgASgLMh8uZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9u",
            "SAASNgoIcmVkaXJlY3QYAyABKAsyIi5lbnZveS5hcGkudjIucm91dGUuUmVk",
            "aXJlY3RBY3Rpb25IABJDCg9kaXJlY3RfcmVzcG9uc2UYByABKAsyKC5lbnZv",
            "eS5hcGkudjIucm91dGUuRGlyZWN0UmVzcG9uc2VBY3Rpb25IABItCghtZXRh",
            "ZGF0YRgEIAEoCzIbLmVudm95LmFwaS52Mi5jb3JlLk1ldGFkYXRhEjAKCWRl",
            "Y29yYXRvchgFIAEoCzIdLmVudm95LmFwaS52Mi5yb3V0ZS5EZWNvcmF0b3IS",
            "SQoRcGVyX2ZpbHRlcl9jb25maWcYCCADKAsyLi5lbnZveS5hcGkudjIucm91",
            "dGUuUm91dGUuUGVyRmlsdGVyQ29uZmlnRW50cnkaTwoUUGVyRmlsdGVyQ29u",
            "ZmlnRW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgLMhcuZ29vZ2xl",
            "LnByb3RvYnVmLlN0cnVjdDoCOAFCDwoGYWN0aW9uEgW46cADAUoECAYQByK2",
            "BQoPV2VpZ2h0ZWRDbHVzdGVyEk8KCGNsdXN0ZXJzGAEgAygLMjEuZW52b3ku",
            "YXBpLnYyLnJvdXRlLldlaWdodGVkQ2x1c3Rlci5DbHVzdGVyV2VpZ2h0Qgq6",
            "6cADBZIBAggBEj0KDHRvdGFsX3dlaWdodBgDIAEoCzIcLmdvb2dsZS5wcm90",
            "b2J1Zi5VSW50MzJWYWx1ZUIJuunAAwQqAigBEhoKEnJ1bnRpbWVfa2V5X3By",
            "ZWZpeBgCIAEoCRr2AwoNQ2x1c3RlcldlaWdodBIXCgRuYW1lGAEgASgJQgm6",
            "6cADBHICIAESLAoGd2VpZ2h0GAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlEjMKDm1ldGFkYXRhX21hdGNoGAMgASgLMhsuZW52b3kuYXBp",
            "LnYyLmNvcmUuTWV0YWRhdGESRAoWcmVxdWVzdF9oZWFkZXJzX3RvX2FkZBgE",
            "IAMoCzIkLmVudm95LmFwaS52Mi5jb3JlLkhlYWRlclZhbHVlT3B0aW9uEkUK",
            "F3Jlc3BvbnNlX2hlYWRlcnNfdG9fYWRkGAUgAygLMiQuZW52b3kuYXBpLnYy",
            "LmNvcmUuSGVhZGVyVmFsdWVPcHRpb24SIgoacmVzcG9uc2VfaGVhZGVyc190",
            "b19yZW1vdmUYBiADKAkSYQoRcGVyX2ZpbHRlcl9jb25maWcYCCADKAsyRi5l",
            "bnZveS5hcGkudjIucm91dGUuV2VpZ2h0ZWRDbHVzdGVyLkNsdXN0ZXJXZWln",
            "aHQuUGVyRmlsdGVyQ29uZmlnRW50cnkaTwoUUGVyRmlsdGVyQ29uZmlnRW50",
            "cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgLMhcuZ29vZ2xlLnByb3Rv",
            "YnVmLlN0cnVjdDoCOAFKBAgHEAgiuAIKClJvdXRlTWF0Y2gSEAoGcHJlZml4",
            "GAEgASgJSAASDgoEcGF0aBgCIAEoCUgAEg8KBXJlZ2V4GAMgASgJSAASMgoO",
            "Y2FzZV9zZW5zaXRpdmUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZh",
            "bHVlEjEKB3J1bnRpbWUYBSABKAsyIC5lbnZveS5hcGkudjIuY29yZS5SdW50",
            "aW1lVUludDMyEjIKB2hlYWRlcnMYBiADKAsyIS5lbnZveS5hcGkudjIucm91",
            "dGUuSGVhZGVyTWF0Y2hlchJDChBxdWVyeV9wYXJhbWV0ZXJzGAcgAygLMiku",
            "ZW52b3kuYXBpLnYyLnJvdXRlLlF1ZXJ5UGFyYW1ldGVyTWF0Y2hlckIXCg5w",
            "YXRoX3NwZWNpZmllchIFuOnAAwEi3QEKCkNvcnNQb2xpY3kSFAoMYWxsb3df",
            "b3JpZ2luGAEgAygJEhUKDWFsbG93X21ldGhvZHMYAiABKAkSFQoNYWxsb3df",
            "aGVhZGVycxgDIAEoCRIWCg5leHBvc2VfaGVhZGVycxgEIAEoCRIPCgdtYXhf",
            "YWdlGAUgASgJEjUKEWFsbG93X2NyZWRlbnRpYWxzGAYgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLkJvb2xWYWx1ZRIrCgdlbmFibGVkGAcgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLkJvb2xWYWx1ZSKzEQoLUm91dGVBY3Rpb24SEQoHY2x1c3Rl",
            "chgBIAEoCUgAEhgKDmNsdXN0ZXJfaGVhZGVyGAIgASgJSAASQAoRd2VpZ2h0",
            "ZWRfY2x1c3RlcnMYAyABKAsyIy5lbnZveS5hcGkudjIucm91dGUuV2VpZ2h0",
            "ZWRDbHVzdGVySAAScAofY2x1c3Rlcl9ub3RfZm91bmRfcmVzcG9uc2VfY29k",
            "ZRgUIAEoDjI7LmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5DbHVz",
            "dGVyTm90Rm91bmRSZXNwb25zZUNvZGVCCrrpwAMFggECEAESMwoObWV0YWRh",
            "dGFfbWF0Y2gYBCABKAsyGy5lbnZveS5hcGkudjIuY29yZS5NZXRhZGF0YRIW",
            "Cg5wcmVmaXhfcmV3cml0ZRgFIAEoCRIWCgxob3N0X3Jld3JpdGUYBiABKAlI",
            "ARI3ChFhdXRvX2hvc3RfcmV3cml0ZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1",
            "Zi5Cb29sVmFsdWVIARIwCgd0aW1lb3V0GAggASgLMhkuZ29vZ2xlLnByb3Rv",
            "YnVmLkR1cmF0aW9uQgSY3x8BEkEKDHJldHJ5X3BvbGljeRgJIAEoCzIrLmVu",
            "dm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5SZXRyeVBvbGljeRJSChVy",
            "ZXF1ZXN0X21pcnJvcl9wb2xpY3kYCiABKAsyMy5lbnZveS5hcGkudjIucm91",
            "dGUuUm91dGVBY3Rpb24uUmVxdWVzdE1pcnJvclBvbGljeRI0Cghwcmlvcml0",
            "eRgLIAEoDjIiLmVudm95LmFwaS52Mi5jb3JlLlJvdXRpbmdQcmlvcml0eRJE",
            "ChZyZXF1ZXN0X2hlYWRlcnNfdG9fYWRkGAwgAygLMiQuZW52b3kuYXBpLnYy",
            "LmNvcmUuSGVhZGVyVmFsdWVPcHRpb24SRQoXcmVzcG9uc2VfaGVhZGVyc190",
            "b19hZGQYEiADKAsyJC5lbnZveS5hcGkudjIuY29yZS5IZWFkZXJWYWx1ZU9w",
            "dGlvbhIiChpyZXNwb25zZV9oZWFkZXJzX3RvX3JlbW92ZRgTIAMoCRIyCgty",
            "YXRlX2xpbWl0cxgNIAMoCzIdLmVudm95LmFwaS52Mi5yb3V0ZS5SYXRlTGlt",
            "aXQSOgoWaW5jbHVkZV92aF9yYXRlX2xpbWl0cxgOIAEoCzIaLmdvb2dsZS5w",
            "cm90b2J1Zi5Cb29sVmFsdWUSPwoLaGFzaF9wb2xpY3kYDyADKAsyKi5lbnZv",
            "eS5hcGkudjIucm91dGUuUm91dGVBY3Rpb24uSGFzaFBvbGljeRIxCg11c2Vf",
            "d2Vic29ja2V0GBAgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRJO",
            "ChB3ZWJzb2NrZXRfY29uZmlnGBYgASgLMjQuZW52b3kuYXBpLnYyLnJvdXRl",
            "LlJvdXRlQWN0aW9uLldlYlNvY2tldFByb3h5Q29uZmlnEiwKBGNvcnMYESAB",
            "KAsyHi5lbnZveS5hcGkudjIucm91dGUuQ29yc1BvbGljeRI5ChBtYXhfZ3Jw",
            "Y190aW1lb3V0GBcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgSY",
            "3x8BGowBCgtSZXRyeVBvbGljeRIQCghyZXRyeV9vbhgBIAEoCRIxCgtudW1f",
            "cmV0cmllcxgCIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZRI4",
            "Cg9wZXJfdHJ5X3RpbWVvdXQYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVy",
            "YXRpb25CBJjfHwEaRgoTUmVxdWVzdE1pcnJvclBvbGljeRIaCgdjbHVzdGVy",
            "GAEgASgJQgm66cADBHICIAESEwoLcnVudGltZV9rZXkYAiABKAkaxwMKCkhh",
            "c2hQb2xpY3kSQwoGaGVhZGVyGAEgASgLMjEuZW52b3kuYXBpLnYyLnJvdXRl",
            "LlJvdXRlQWN0aW9uLkhhc2hQb2xpY3kuSGVhZGVySAASQwoGY29va2llGAIg",
            "ASgLMjEuZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkhhc2hQb2xp",
            "Y3kuQ29va2llSAASYAoVY29ubmVjdGlvbl9wcm9wZXJ0aWVzGAMgASgLMj8u",
            "ZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkhhc2hQb2xpY3kuQ29u",
            "bmVjdGlvblByb3BlcnRpZXNIABooCgZIZWFkZXISHgoLaGVhZGVyX25hbWUY",
            "ASABKAlCCbrpwAMEcgIgARpdCgZDb29raWUSFwoEbmFtZRgBIAEoCUIJuunA",
            "AwRyAiABEiwKA3R0bBgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlv",
            "bkIEmN8fARIMCgRwYXRoGAMgASgJGikKFENvbm5lY3Rpb25Qcm9wZXJ0aWVz",
            "EhEKCXNvdXJjZV9pcBgBIAEoCEIZChBwb2xpY3lfc3BlY2lmaWVyEgW46cAD",
            "ARqzAQoUV2ViU29ja2V0UHJveHlDb25maWcSEwoLc3RhdF9wcmVmaXgYASAB",
            "KAkSPwoMaWRsZV90aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1",
            "cmF0aW9uQg666cADBaoBAioAmN8fARJFChRtYXhfY29ubmVjdF9hdHRlbXB0",
            "cxgDIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZUIJuunAAwQq",
            "AigBIkUKG0NsdXN0ZXJOb3RGb3VuZFJlc3BvbnNlQ29kZRIXChNTRVJWSUNF",
            "X1VOQVZBSUxBQkxFEAASDQoJTk9UX0ZPVU5EEAFCGgoRY2x1c3Rlcl9zcGVj",
            "aWZpZXISBbjpwAMBQhgKFmhvc3RfcmV3cml0ZV9zcGVjaWZpZXJKBAgVEBYi",
            "9gIKDlJlZGlyZWN0QWN0aW9uEhUKDWhvc3RfcmVkaXJlY3QYASABKAkSFwoN",
            "cGF0aF9yZWRpcmVjdBgCIAEoCUgAEhgKDnByZWZpeF9yZXdyaXRlGAUgASgJ",
            "SAASWgoNcmVzcG9uc2VfY29kZRgDIAEoDjI3LmVudm95LmFwaS52Mi5yb3V0",
            "ZS5SZWRpcmVjdEFjdGlvbi5SZWRpcmVjdFJlc3BvbnNlQ29kZUIKuunAAwWC",
            "AQIQARIWCg5odHRwc19yZWRpcmVjdBgEIAEoCBITCgtzdHJpcF9xdWVyeRgG",
            "IAEoCCJ3ChRSZWRpcmVjdFJlc3BvbnNlQ29kZRIVChFNT1ZFRF9QRVJNQU5F",
            "TlRMWRAAEgkKBUZPVU5EEAESDQoJU0VFX09USEVSEAISFgoSVEVNUE9SQVJZ",
            "X1JFRElSRUNUEAMSFgoSUEVSTUFORU5UX1JFRElSRUNUEARCGAoWcGF0aF9y",
            "ZXdyaXRlX3NwZWNpZmllciJhChREaXJlY3RSZXNwb25zZUFjdGlvbhIcCgZz",
            "dGF0dXMYASABKA1CDLrpwAMHKgUQ2AQoZBIrCgRib2R5GAIgASgLMh0uZW52",
            "b3kuYXBpLnYyLmNvcmUuRGF0YVNvdXJjZSIpCglEZWNvcmF0b3ISHAoJb3Bl",
            "cmF0aW9uGAEgASgJQgm66cADBHICIAEidwoOVmlydHVhbENsdXN0ZXISGgoH",
            "cGF0dGVybhgBIAEoCUIJuunAAwRyAiABEhcKBG5hbWUYAiABKAlCCbrpwAME",
            "cgIgARIwCgZtZXRob2QYAyABKA4yIC5lbnZveS5hcGkudjIuY29yZS5SZXF1",
            "ZXN0TWV0aG9kIo4ICglSYXRlTGltaXQSNgoFc3RhZ2UYASABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAMEKgIYChITCgtkaXNhYmxl",
            "X2tleRgCIAEoCRJBCgdhY3Rpb25zGAMgAygLMiQuZW52b3kuYXBpLnYyLnJv",
            "dXRlLlJhdGVMaW1pdC5BY3Rpb25CCrrpwAMFkgECCAEa8AYKBkFjdGlvbhJM",
            "Cg5zb3VyY2VfY2x1c3RlchgBIAEoCzIyLmVudm95LmFwaS52Mi5yb3V0ZS5S",
            "YXRlTGltaXQuQWN0aW9uLlNvdXJjZUNsdXN0ZXJIABJWChNkZXN0aW5hdGlv",
            "bl9jbHVzdGVyGAIgASgLMjcuZW52b3kuYXBpLnYyLnJvdXRlLlJhdGVMaW1p",
            "dC5BY3Rpb24uRGVzdGluYXRpb25DbHVzdGVySAASTgoPcmVxdWVzdF9oZWFk",
            "ZXJzGAMgASgLMjMuZW52b3kuYXBpLnYyLnJvdXRlLlJhdGVMaW1pdC5BY3Rp",
            "b24uUmVxdWVzdEhlYWRlcnNIABJMCg5yZW1vdGVfYWRkcmVzcxgEIAEoCzIy",
            "LmVudm95LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLlJlbW90ZUFk",
            "ZHJlc3NIABJGCgtnZW5lcmljX2tleRgFIAEoCzIvLmVudm95LmFwaS52Mi5y",
            "b3V0ZS5SYXRlTGltaXQuQWN0aW9uLkdlbmVyaWNLZXlIABJTChJoZWFkZXJf",
            "dmFsdWVfbWF0Y2gYBiABKAsyNS5lbnZveS5hcGkudjIucm91dGUuUmF0ZUxp",
            "bWl0LkFjdGlvbi5IZWFkZXJWYWx1ZU1hdGNoSAAaDwoNU291cmNlQ2x1c3Rl",
            "choUChJEZXN0aW5hdGlvbkNsdXN0ZXIaUwoOUmVxdWVzdEhlYWRlcnMSHgoL",
            "aGVhZGVyX25hbWUYASABKAlCCbrpwAMEcgIgARIhCg5kZXNjcmlwdG9yX2tl",
            "eRgCIAEoCUIJuunAAwRyAiABGg8KDVJlbW90ZUFkZHJlc3MaMQoKR2VuZXJp",
            "Y0tleRIjChBkZXNjcmlwdG9yX3ZhbHVlGAEgASgJQgm66cADBHICIAEaqQEK",
            "EEhlYWRlclZhbHVlTWF0Y2gSIwoQZGVzY3JpcHRvcl92YWx1ZRgBIAEoCUIJ",
            "uunAAwRyAiABEjAKDGV4cGVjdF9tYXRjaBgCIAEoCzIaLmdvb2dsZS5wcm90",
            "b2J1Zi5Cb29sVmFsdWUSPgoHaGVhZGVycxgDIAMoCzIhLmVudm95LmFwaS52",
            "Mi5yb3V0ZS5IZWFkZXJNYXRjaGVyQgq66cADBZIBAggBQhkKEGFjdGlvbl9z",
            "cGVjaWZpZXISBbjpwAMBItYCCg1IZWFkZXJNYXRjaGVyEhcKBG5hbWUYASAB",
            "KAlCCbrpwAMEcgIgARIRCgV2YWx1ZRgCIAEoCUICGAESLQoFcmVnZXgYAyAB",
            "KAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlQgIYARIVCgtleGFjdF9t",
            "YXRjaBgEIAEoCUgAEhUKC3JlZ2V4X21hdGNoGAUgASgJSAASLQoLcmFuZ2Vf",
            "bWF0Y2gYBiABKAsyFi5lbnZveS50eXBlLkludDY0UmFuZ2VIABIXCg1wcmVz",
            "ZW50X21hdGNoGAcgASgISAASIQoMcHJlZml4X21hdGNoGAkgASgJQgm66cAD",
            "BHICIAFIABIhCgxzdWZmaXhfbWF0Y2gYCiABKAlCCbrpwAMEcgIgAUgAEhQK",
            "DGludmVydF9tYXRjaBgIIAEoCEIYChZoZWFkZXJfbWF0Y2hfc3BlY2lmaWVy",
            "ImoKFVF1ZXJ5UGFyYW1ldGVyTWF0Y2hlchIXCgRuYW1lGAEgASgJQgm66cAD",
            "BHICIAESDQoFdmFsdWUYAyABKAkSKQoFcmVnZXgYBCABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuQm9vbFZhbHVlQg5aBXJvdXRliAEBqOIeAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Type.RangeReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.VirtualHost), global::Envoy.Api.V2.Route.VirtualHost.Parser, new[]{ "Name", "Domains", "Routes", "RequireTls", "VirtualClusters", "RateLimits", "RequestHeadersToAdd", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "Cors", "PerFilterConfig" }, null, new[]{ typeof(global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType) }, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.Route), global::Envoy.Api.V2.Route.Route.Parser, new[]{ "Match", "Route_", "Redirect", "DirectResponse", "Metadata", "Decorator", "PerFilterConfig" }, new[]{ "Action" }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.WeightedCluster), global::Envoy.Api.V2.Route.WeightedCluster.Parser, new[]{ "Clusters", "TotalWeight", "RuntimeKeyPrefix" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight), global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight.Parser, new[]{ "Name", "Weight", "MetadataMatch", "RequestHeadersToAdd", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "PerFilterConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteMatch), global::Envoy.Api.V2.Route.RouteMatch.Parser, new[]{ "Prefix", "Path", "Regex", "CaseSensitive", "Runtime", "Headers", "QueryParameters" }, new[]{ "PathSpecifier" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.CorsPolicy), global::Envoy.Api.V2.Route.CorsPolicy.Parser, new[]{ "AllowOrigin", "AllowMethods", "AllowHeaders", "ExposeHeaders", "MaxAge", "AllowCredentials", "Enabled" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction), global::Envoy.Api.V2.Route.RouteAction.Parser, new[]{ "Cluster", "ClusterHeader", "WeightedClusters", "ClusterNotFoundResponseCode", "MetadataMatch", "PrefixRewrite", "HostRewrite", "AutoHostRewrite", "Timeout", "RetryPolicy", "RequestMirrorPolicy", "Priority", "RequestHeadersToAdd", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "RateLimits", "IncludeVhRateLimits", "HashPolicy", "UseWebsocket", "WebsocketConfig", "Cors", "MaxGrpcTimeout" }, new[]{ "ClusterSpecifier", "HostRewriteSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy), global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy.Parser, new[]{ "RetryOn", "NumRetries", "PerTryTimeout" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy), global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy.Parser, new[]{ "Cluster", "RuntimeKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Parser, new[]{ "Header", "Cookie", "ConnectionProperties" }, new[]{ "PolicySpecifier" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header.Parser, new[]{ "HeaderName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie.Parser, new[]{ "Name", "Ttl", "Path" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties.Parser, new[]{ "SourceIp" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig), global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig.Parser, new[]{ "StatPrefix", "IdleTimeout", "MaxConnectAttempts" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RedirectAction), global::Envoy.Api.V2.Route.RedirectAction.Parser, new[]{ "HostRedirect", "PathRedirect", "PrefixRewrite", "ResponseCode", "HttpsRedirect", "StripQuery" }, new[]{ "PathRewriteSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.DirectResponseAction), global::Envoy.Api.V2.Route.DirectResponseAction.Parser, new[]{ "Status", "Body" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.Decorator), global::Envoy.Api.V2.Route.Decorator.Parser, new[]{ "Operation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.VirtualCluster), global::Envoy.Api.V2.Route.VirtualCluster.Parser, new[]{ "Pattern", "Name", "Method" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit), global::Envoy.Api.V2.Route.RateLimit.Parser, new[]{ "Stage", "DisableKey", "Actions" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Parser, new[]{ "SourceCluster", "DestinationCluster", "RequestHeaders", "RemoteAddress", "GenericKey", "HeaderValueMatch" }, new[]{ "ActionSpecifier" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders.Parser, new[]{ "HeaderName", "DescriptorKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey.Parser, new[]{ "DescriptorValue" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch.Parser, new[]{ "DescriptorValue", "ExpectMatch", "Headers" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.HeaderMatcher), global::Envoy.Api.V2.Route.HeaderMatcher.Parser, new[]{ "Name", "Value", "Regex", "ExactMatch", "RegexMatch", "RangeMatch", "PresentMatch", "PrefixMatch", "SuffixMatch", "InvertMatch" }, new[]{ "HeaderMatchSpecifier" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.QueryParameterMatcher), global::Envoy.Api.V2.Route.QueryParameterMatcher.Parser, new[]{ "Name", "Value", "Regex" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The top level element in the routing configuration is a virtual host. Each virtual host has
  /// a logical name as well as a set of domains that get routed to it based on the incoming request's
  /// host header. This allows a single listener to service multiple top level domain path trees. Once
  /// a virtual host is selected based on the domain, the routes are processed in order to see which
  /// upstream cluster to route to or whether to perform a redirect.
  /// </summary>
  public sealed partial class VirtualHost : pb::IMessage<VirtualHost> {
    private static readonly pb::MessageParser<VirtualHost> _parser = new pb::MessageParser<VirtualHost>(() => new VirtualHost());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VirtualHost> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost(VirtualHost other) : this() {
      name_ = other.name_;
      domains_ = other.domains_.Clone();
      routes_ = other.routes_.Clone();
      requireTls_ = other.requireTls_;
      virtualClusters_ = other.virtualClusters_.Clone();
      rateLimits_ = other.rateLimits_.Clone();
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      Cors = other.cors_ != null ? other.Cors.Clone() : null;
      perFilterConfig_ = other.perFilterConfig_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost Clone() {
      return new VirtualHost(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The logical name of the virtual host. This is used when emitting certain
    /// statistics but is not relevant for routing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domains" field.</summary>
    public const int DomainsFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_domains_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> domains_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of domains (host/authority header) that will be matched to this
    /// virtual host. Wildcard hosts are supported in the form of “*.foo.com” or
    /// “*-bar.foo.com”.
    ///
    /// .. note::
    ///
    ///   The wildcard will not match the empty string.
    ///   e.g. “*-bar.foo.com” will match “baz-bar.foo.com” but not “-bar.foo.com”.
    ///   Additionally, a special entry “*” is allowed which will match any
    ///   host/authority header. Only a single virtual host in the entire route
    ///   configuration can match on “*”. A domain must be unique across all virtual
    ///   hosts or the config will fail to load.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Domains {
      get { return domains_; }
    }

    /// <summary>Field number for the "routes" field.</summary>
    public const int RoutesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.Route> _repeated_routes_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.Route.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.Route> routes_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.Route>();
    /// <summary>
    /// The list of routes that will be matched, in order, for incoming requests.
    /// The first route that matches will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.Route> Routes {
      get { return routes_; }
    }

    /// <summary>Field number for the "require_tls" field.</summary>
    public const int RequireTlsFieldNumber = 4;
    private global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType requireTls_ = 0;
    /// <summary>
    /// Specifies the type of TLS enforcement the virtual host expects. If this option is not
    /// specified, there is no TLS requirement for the virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType RequireTls {
      get { return requireTls_; }
      set {
        requireTls_ = value;
      }
    }

    /// <summary>Field number for the "virtual_clusters" field.</summary>
    public const int VirtualClustersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.VirtualCluster> _repeated_virtualClusters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Route.VirtualCluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster> virtualClusters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster>();
    /// <summary>
    /// A list of virtual clusters defined for this virtual host. Virtual clusters
    /// are used for additional statistics gathering.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster> VirtualClusters {
      get { return virtualClusters_; }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Api.V2.Route.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that will be applied to the
    /// virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each request
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_api_msg_route.RouteAction` and before headers from the
    /// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each response
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_api_msg_route.RouteAction` and before headers from the
    /// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// handled by this virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 8;
    private global::Envoy.Api.V2.Route.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the virtual host has a CORS policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "per_filter_config" field.</summary>
    public const int PerFilterConfigFieldNumber = 12;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 98);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The per_filter_config field can be used to provide virtual host-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
    /// for if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
      get { return perFilterConfig_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VirtualHost);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VirtualHost other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!domains_.Equals(other.domains_)) return false;
      if(!routes_.Equals(other.routes_)) return false;
      if (RequireTls != other.RequireTls) return false;
      if(!virtualClusters_.Equals(other.virtualClusters_)) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= domains_.GetHashCode();
      hash ^= routes_.GetHashCode();
      if (RequireTls != 0) hash ^= RequireTls.GetHashCode();
      hash ^= virtualClusters_.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      hash ^= PerFilterConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      domains_.WriteTo(output, _repeated_domains_codec);
      routes_.WriteTo(output, _repeated_routes_codec);
      if (RequireTls != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RequireTls);
      }
      virtualClusters_.WriteTo(output, _repeated_virtualClusters_codec);
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      if (cors_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cors);
      }
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += domains_.CalculateSize(_repeated_domains_codec);
      size += routes_.CalculateSize(_repeated_routes_codec);
      if (RequireTls != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequireTls);
      }
      size += virtualClusters_.CalculateSize(_repeated_virtualClusters_codec);
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      if (cors_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VirtualHost other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      domains_.Add(other.domains_);
      routes_.Add(other.routes_);
      if (other.RequireTls != 0) {
        RequireTls = other.RequireTls;
      }
      virtualClusters_.Add(other.virtualClusters_);
      rateLimits_.Add(other.rateLimits_);
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      if (other.cors_ != null) {
        if (cors_ == null) {
          cors_ = new global::Envoy.Api.V2.Route.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      perFilterConfig_.Add(other.perFilterConfig_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            domains_.AddEntriesFrom(input, _repeated_domains_codec);
            break;
          }
          case 26: {
            routes_.AddEntriesFrom(input, _repeated_routes_codec);
            break;
          }
          case 32: {
            requireTls_ = (global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType) input.ReadEnum();
            break;
          }
          case 42: {
            virtualClusters_.AddEntriesFrom(input, _repeated_virtualClusters_codec);
            break;
          }
          case 50: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 58: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 66: {
            if (cors_ == null) {
              cors_ = new global::Envoy.Api.V2.Route.CorsPolicy();
            }
            input.ReadMessage(cors_);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 98: {
            perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VirtualHost message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum TlsRequirementType {
        /// <summary>
        /// No TLS requirement for the virtual host.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// External requests must use TLS. If a request is external and it is not
        /// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("EXTERNAL_ONLY")] ExternalOnly = 1,
        /// <summary>
        /// All requests must use TLS. If a request is not using TLS, a 301 redirect
        /// will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("ALL")] All = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A route is both a specification of how to match a request as well as an indication of what to do
  /// next (e.g., redirect, forward, rewrite, etc.).
  ///
  /// .. attention::
  ///
  ///   Envoy supports routing on HTTP method via :ref:`header matching
  ///   &lt;envoy_api_msg_route.HeaderMatcher>`.
  /// </summary>
  public sealed partial class Route : pb::IMessage<Route> {
    private static readonly pb::MessageParser<Route> _parser = new pb::MessageParser<Route>(() => new Route());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Route> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route(Route other) : this() {
      Match = other.match_ != null ? other.Match.Clone() : null;
      Metadata = other.metadata_ != null ? other.Metadata.Clone() : null;
      Decorator = other.decorator_ != null ? other.Decorator.Clone() : null;
      perFilterConfig_ = other.perFilterConfig_.Clone();
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          Route_ = other.Route_.Clone();
          break;
        case ActionOneofCase.Redirect:
          Redirect = other.Redirect.Clone();
          break;
        case ActionOneofCase.DirectResponse:
          DirectResponse = other.DirectResponse.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route Clone() {
      return new Route(this);
    }

    /// <summary>Field number for the "match" field.</summary>
    public const int MatchFieldNumber = 1;
    private global::Envoy.Api.V2.Route.RouteMatch match_;
    /// <summary>
    /// Route matching parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteMatch Match {
      get { return match_; }
      set {
        match_ = value;
      }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int Route_FieldNumber = 2;
    /// <summary>
    /// Route request to some upstream cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction Route_ {
      get { return actionCase_ == ActionOneofCase.Route_ ? (global::Envoy.Api.V2.Route.RouteAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Route_;
      }
    }

    /// <summary>Field number for the "redirect" field.</summary>
    public const int RedirectFieldNumber = 3;
    /// <summary>
    /// Return a redirect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RedirectAction Redirect {
      get { return actionCase_ == ActionOneofCase.Redirect ? (global::Envoy.Api.V2.Route.RedirectAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Redirect;
      }
    }

    /// <summary>Field number for the "direct_response" field.</summary>
    public const int DirectResponseFieldNumber = 7;
    /// <summary>
    /// Return an arbitrary HTTP response directly, without proxying.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.DirectResponseAction DirectResponse {
      get { return actionCase_ == ActionOneofCase.DirectResponse ? (global::Envoy.Api.V2.Route.DirectResponseAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.DirectResponse;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 4;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information
    /// about the route. It can be used for configuration, stats, and logging.
    /// The metadata should go under the filter namespace that will need it.
    /// For instance, if the metadata is intended for the Router filter,
    /// the filter name should be specified as *envoy.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "decorator" field.</summary>
    public const int DecoratorFieldNumber = 5;
    private global::Envoy.Api.V2.Route.Decorator decorator_;
    /// <summary>
    /// Decorator for the matched route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.Decorator Decorator {
      get { return decorator_; }
      set {
        decorator_ = value;
      }
    }

    /// <summary>Field number for the "per_filter_config" field.</summary>
    public const int PerFilterConfigFieldNumber = 8;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 66);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The per_filter_config field can be used to provide route-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>` for
    /// if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
      get { return perFilterConfig_; }
    }

    private object action_;
    /// <summary>Enum of possible cases for the "action" oneof.</summary>
    public enum ActionOneofCase {
      None = 0,
      Route_ = 2,
      Redirect = 3,
      DirectResponse = 7,
    }
    private ActionOneofCase actionCase_ = ActionOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ActionOneofCase ActionCase {
      get { return actionCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAction() {
      actionCase_ = ActionOneofCase.None;
      action_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Route);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Route other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Match, other.Match)) return false;
      if (!object.Equals(Route_, other.Route_)) return false;
      if (!object.Equals(Redirect, other.Redirect)) return false;
      if (!object.Equals(DirectResponse, other.DirectResponse)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Decorator, other.Decorator)) return false;
      if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
      if (ActionCase != other.ActionCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (match_ != null) hash ^= Match.GetHashCode();
      if (actionCase_ == ActionOneofCase.Route_) hash ^= Route_.GetHashCode();
      if (actionCase_ == ActionOneofCase.Redirect) hash ^= Redirect.GetHashCode();
      if (actionCase_ == ActionOneofCase.DirectResponse) hash ^= DirectResponse.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (decorator_ != null) hash ^= Decorator.GetHashCode();
      hash ^= PerFilterConfig.GetHashCode();
      hash ^= (int) actionCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (match_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        output.WriteRawTag(18);
        output.WriteMessage(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        output.WriteRawTag(26);
        output.WriteMessage(Redirect);
      }
      if (metadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Metadata);
      }
      if (decorator_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Decorator);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        output.WriteRawTag(58);
        output.WriteMessage(DirectResponse);
      }
      perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (match_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Redirect);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DirectResponse);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (decorator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Decorator);
      }
      size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Route other) {
      if (other == null) {
        return;
      }
      if (other.match_ != null) {
        if (match_ == null) {
          match_ = new global::Envoy.Api.V2.Route.RouteMatch();
        }
        Match.MergeFrom(other.Match);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          metadata_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.decorator_ != null) {
        if (decorator_ == null) {
          decorator_ = new global::Envoy.Api.V2.Route.Decorator();
        }
        Decorator.MergeFrom(other.Decorator);
      }
      perFilterConfig_.Add(other.perFilterConfig_);
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          if (Route_ == null) {
            Route_ = new global::Envoy.Api.V2.Route.RouteAction();
          }
          Route_.MergeFrom(other.Route_);
          break;
        case ActionOneofCase.Redirect:
          if (Redirect == null) {
            Redirect = new global::Envoy.Api.V2.Route.RedirectAction();
          }
          Redirect.MergeFrom(other.Redirect);
          break;
        case ActionOneofCase.DirectResponse:
          if (DirectResponse == null) {
            DirectResponse = new global::Envoy.Api.V2.Route.DirectResponseAction();
          }
          DirectResponse.MergeFrom(other.DirectResponse);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (match_ == null) {
              match_ = new global::Envoy.Api.V2.Route.RouteMatch();
            }
            input.ReadMessage(match_);
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Route.RouteAction subBuilder = new global::Envoy.Api.V2.Route.RouteAction();
            if (actionCase_ == ActionOneofCase.Route_) {
              subBuilder.MergeFrom(Route_);
            }
            input.ReadMessage(subBuilder);
            Route_ = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Route.RedirectAction subBuilder = new global::Envoy.Api.V2.Route.RedirectAction();
            if (actionCase_ == ActionOneofCase.Redirect) {
              subBuilder.MergeFrom(Redirect);
            }
            input.ReadMessage(subBuilder);
            Redirect = subBuilder;
            break;
          }
          case 34: {
            if (metadata_ == null) {
              metadata_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadata_);
            break;
          }
          case 42: {
            if (decorator_ == null) {
              decorator_ = new global::Envoy.Api.V2.Route.Decorator();
            }
            input.ReadMessage(decorator_);
            break;
          }
          case 58: {
            global::Envoy.Api.V2.Route.DirectResponseAction subBuilder = new global::Envoy.Api.V2.Route.DirectResponseAction();
            if (actionCase_ == ActionOneofCase.DirectResponse) {
              subBuilder.MergeFrom(DirectResponse);
            }
            input.ReadMessage(subBuilder);
            DirectResponse = subBuilder;
            break;
          }
          case 66: {
            perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Compared to the :ref:`cluster &lt;envoy_api_field_route.RouteAction.cluster>` field that specifies a
  /// single upstream cluster as the target of a request, the :ref:`weighted_clusters
  /// &lt;envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
  /// multiple upstream clusters along with weights that indicate the percentage of
  /// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
  /// weights.
  /// </summary>
  public sealed partial class WeightedCluster : pb::IMessage<WeightedCluster> {
    private static readonly pb::MessageParser<WeightedCluster> _parser = new pb::MessageParser<WeightedCluster>(() => new WeightedCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster(WeightedCluster other) : this() {
      clusters_ = other.clusters_.Clone();
      TotalWeight = other.TotalWeight;
      runtimeKeyPrefix_ = other.runtimeKeyPrefix_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster Clone() {
      return new WeightedCluster(this);
    }

    /// <summary>Field number for the "clusters" field.</summary>
    public const int ClustersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> _repeated_clusters_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> clusters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight>();
    /// <summary>
    /// Specifies one or more upstream clusters associated with the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> Clusters {
      get { return clusters_; }
    }

    /// <summary>Field number for the "total_weight" field.</summary>
    public const int TotalWeightFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_totalWeight_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? totalWeight_;
    /// <summary>
    /// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
    /// value, which must be greater than 0. Defaults to 100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? TotalWeight {
      get { return totalWeight_; }
      set {
        totalWeight_ = value;
      }
    }

    /// <summary>Field number for the "runtime_key_prefix" field.</summary>
    public const int RuntimeKeyPrefixFieldNumber = 2;
    private string runtimeKeyPrefix_ = "";
    /// <summary>
    /// Specifies the runtime key prefix that should be used to construct the
    /// runtime keys associated with each cluster. When the *runtime_key_prefix* is
    /// specified, the router will look for weights associated with each upstream
    /// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
    /// *cluster[i]* denotes an entry in the clusters array field. If the runtime
    /// key for the cluster does not exist, the value specified in the
    /// configuration file will be used as the default weight. See the :ref:`runtime documentation
    /// &lt;operations_runtime>` for how key names map to the underlying implementation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RuntimeKeyPrefix {
      get { return runtimeKeyPrefix_; }
      set {
        runtimeKeyPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!clusters_.Equals(other.clusters_)) return false;
      if (TotalWeight != other.TotalWeight) return false;
      if (RuntimeKeyPrefix != other.RuntimeKeyPrefix) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= clusters_.GetHashCode();
      if (totalWeight_ != null) hash ^= TotalWeight.GetHashCode();
      if (RuntimeKeyPrefix.Length != 0) hash ^= RuntimeKeyPrefix.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      clusters_.WriteTo(output, _repeated_clusters_codec);
      if (RuntimeKeyPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RuntimeKeyPrefix);
      }
      if (totalWeight_ != null) {
        _single_totalWeight_codec.WriteTagAndValue(output, TotalWeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += clusters_.CalculateSize(_repeated_clusters_codec);
      if (totalWeight_ != null) {
        size += _single_totalWeight_codec.CalculateSizeWithTag(TotalWeight);
      }
      if (RuntimeKeyPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RuntimeKeyPrefix);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedCluster other) {
      if (other == null) {
        return;
      }
      clusters_.Add(other.clusters_);
      if (other.totalWeight_ != null) {
        if (totalWeight_ == null || other.TotalWeight != 0) {
          TotalWeight = other.TotalWeight;
        }
      }
      if (other.RuntimeKeyPrefix.Length != 0) {
        RuntimeKeyPrefix = other.RuntimeKeyPrefix;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            clusters_.AddEntriesFrom(input, _repeated_clusters_codec);
            break;
          }
          case 18: {
            RuntimeKeyPrefix = input.ReadString();
            break;
          }
          case 26: {
            uint? value = _single_totalWeight_codec.Read(input);
            if (totalWeight_ == null || value != 0) {
              TotalWeight = value;
            }
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the WeightedCluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class ClusterWeight : pb::IMessage<ClusterWeight> {
        private static readonly pb::MessageParser<ClusterWeight> _parser = new pb::MessageParser<ClusterWeight>(() => new ClusterWeight());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ClusterWeight> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.WeightedCluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight(ClusterWeight other) : this() {
          name_ = other.name_;
          Weight = other.Weight;
          MetadataMatch = other.metadataMatch_ != null ? other.MetadataMatch.Clone() : null;
          requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
          responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
          responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
          perFilterConfig_ = other.perFilterConfig_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight Clone() {
          return new ClusterWeight(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the upstream cluster. The cluster must exist in the
        /// :ref:`cluster manager configuration &lt;config_cluster_manager>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_weight_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? weight_;
        /// <summary>
        /// An integer between 0 and :ref:`total_weight
        /// &lt;envoy_api_field_route.WeightedCluster.total_weight>`. When a request matches the route,
        /// the choice of an upstream cluster is determined by its weight. The sum of weights across all
        /// entries in the clusters array must add up to the total_weight, which defaults to 100.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? Weight {
          get { return weight_; }
          set {
            weight_ = value;
          }
        }

        /// <summary>Field number for the "metadata_match" field.</summary>
        public const int MetadataMatchFieldNumber = 3;
        private global::Envoy.Api.V2.Core.Metadata metadataMatch_;
        /// <summary>
        /// Optional endpoint metadata match criteria. Only endpoints in the upstream
        /// cluster with metadata matching that set in metadata_match will be
        /// considered. The filter name should be specified as *envoy.lb*.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Metadata MetadataMatch {
          get { return metadataMatch_; }
          set {
            metadataMatch_ = value;
          }
        }

        /// <summary>Field number for the "request_headers_to_add" field.</summary>
        public const int RequestHeadersToAddFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(34, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to requests when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_api_msg_route.RouteAction`,
        /// :ref:`envoy_api_msg_route.VirtualHost`, and
        /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
          get { return requestHeadersToAdd_; }
        }

        /// <summary>Field number for the "response_headers_to_add" field.</summary>
        public const int ResponseHeadersToAddFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to responses when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_api_msg_route.RouteAction`,
        /// :ref:`envoy_api_msg_route.VirtualHost`, and
        /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
          get { return responseHeadersToAdd_; }
        }

        /// <summary>Field number for the "response_headers_to_remove" field.</summary>
        public const int ResponseHeadersToRemoveFieldNumber = 6;
        private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
            = pb::FieldCodec.ForString(50);
        private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies a list of headers to be removed from responses when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ResponseHeadersToRemove {
          get { return responseHeadersToRemove_; }
        }

        /// <summary>Field number for the "per_filter_config" field.</summary>
        public const int PerFilterConfigFieldNumber = 8;
        private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
            = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 66);
        private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
        /// <summary>
        /// The per_filter_config field can be used to provide weighted cluster-specific
        /// configurations for filters. The key should match the filter name, such as
        /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
        /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
        /// for if and how it is utilized.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
          get { return perFilterConfig_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ClusterWeight);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ClusterWeight other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Weight != other.Weight) return false;
          if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
          if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
          if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
          if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
          if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (weight_ != null) hash ^= Weight.GetHashCode();
          if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
          hash ^= requestHeadersToAdd_.GetHashCode();
          hash ^= responseHeadersToAdd_.GetHashCode();
          hash ^= responseHeadersToRemove_.GetHashCode();
          hash ^= PerFilterConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (weight_ != null) {
            _single_weight_codec.WriteTagAndValue(output, Weight);
          }
          if (metadataMatch_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MetadataMatch);
          }
          requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
          responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
          responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
          perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (weight_ != null) {
            size += _single_weight_codec.CalculateSizeWithTag(Weight);
          }
          if (metadataMatch_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
          }
          size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
          size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
          size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
          size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ClusterWeight other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.weight_ != null) {
            if (weight_ == null || other.Weight != 0) {
              Weight = other.Weight;
            }
          }
          if (other.metadataMatch_ != null) {
            if (metadataMatch_ == null) {
              metadataMatch_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            MetadataMatch.MergeFrom(other.MetadataMatch);
          }
          requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
          responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
          responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
          perFilterConfig_.Add(other.perFilterConfig_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                uint? value = _single_weight_codec.Read(input);
                if (weight_ == null || value != 0) {
                  Weight = value;
                }
                break;
              }
              case 26: {
                if (metadataMatch_ == null) {
                  metadataMatch_ = new global::Envoy.Api.V2.Core.Metadata();
                }
                input.ReadMessage(metadataMatch_);
                break;
              }
              case 34: {
                requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
                break;
              }
              case 42: {
                responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
                break;
              }
              case 50: {
                responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
                break;
              }
              case 66: {
                perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class RouteMatch : pb::IMessage<RouteMatch> {
    private static readonly pb::MessageParser<RouteMatch> _parser = new pb::MessageParser<RouteMatch>(() => new RouteMatch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RouteMatch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch(RouteMatch other) : this() {
      CaseSensitive = other.CaseSensitive;
      Runtime = other.runtime_ != null ? other.Runtime.Clone() : null;
      headers_ = other.headers_.Clone();
      queryParameters_ = other.queryParameters_.Clone();
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.Regex:
          Regex = other.Regex;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch Clone() {
      return new RouteMatch(this);
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 1;
    /// <summary>
    /// If specified, the route is a prefix rule meaning that the prefix must
    /// match the beginning of the *:path* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Prefix {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Prefix ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Prefix;
      }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    /// <summary>
    /// If specified, the route is an exact path rule meaning that the path must
    /// exactly match the *:path* header once the query string is removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Path {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Path ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 3;
    /// <summary>
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the *:path* header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the *:path* header matches the regex. The regex grammar is defined `here
    /// &lt;http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex */b[io]t* matches the path */bit*
    /// * The regex */b[io]t* matches the path */bot*
    /// * The regex */b[io]t* does not match the path */bite*
    /// * The regex */b[io]t* does not match the path */bit/bot*
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Regex {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Regex ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Regex;
      }
    }

    /// <summary>Field number for the "case_sensitive" field.</summary>
    public const int CaseSensitiveFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_caseSensitive_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? caseSensitive_;
    /// <summary>
    /// Indicates that prefix/path matching should be case insensitive. The default
    /// is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? CaseSensitive {
      get { return caseSensitive_; }
      set {
        caseSensitive_ = value;
      }
    }

    /// <summary>Field number for the "runtime" field.</summary>
    public const int RuntimeFieldNumber = 5;
    private global::Envoy.Api.V2.Core.RuntimeUInt32 runtime_;
    /// <summary>
    /// Indicates that the route should additionally match on a runtime key. An
    /// integer between 0-100. Every time the route is considered for a match, a
    /// random number between 0-99 is selected. If the number is &lt;= the value found
    /// in the key (checked first) or, if the key is not present, the default
    /// value, the route is a match (assuming everything also about the route
    /// matches). A runtime route configuration can be used to roll out route changes in a
    /// gradual manner without full code/config deploys. Refer to the
    /// :ref:`traffic shifting &lt;config_http_conn_man_route_table_traffic_splitting_shift>` docs
    /// for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RuntimeUInt32 Runtime {
      get { return runtime_; }
      set {
        runtime_ = value;
      }
    }

    /// <summary>Field number for the "headers" field.</summary>
    public const int HeadersFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.HeaderMatcher> _repeated_headers_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Api.V2.Route.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher>();
    /// <summary>
    /// Specifies a set of headers that the route should match on. The router will
    /// check the request’s headers against all the specified headers in the route
    /// config. A match will happen if all the headers in the route are present in
    /// the request with the same values (or based on presence if the value field
    /// is not in the config).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> Headers {
      get { return headers_; }
    }

    /// <summary>Field number for the "query_parameters" field.</summary>
    public const int QueryParametersFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.QueryParameterMatcher> _repeated_queryParameters_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Route.QueryParameterMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher> queryParameters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher>();
    /// <summary>
    /// Specifies a set of URL query parameters on which the route should
    /// match. The router will check the query string from the *path* header
    /// against all the specified query parameters. If the number of specified
    /// query parameters is nonzero, they all must match the *path* header's
    /// query string for a match to occur.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher> QueryParameters {
      get { return queryParameters_; }
    }

    private object pathSpecifier_;
    /// <summary>Enum of possible cases for the "path_specifier" oneof.</summary>
    public enum PathSpecifierOneofCase {
      None = 0,
      Prefix = 1,
      Path = 2,
      Regex = 3,
    }
    private PathSpecifierOneofCase pathSpecifierCase_ = PathSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PathSpecifierOneofCase PathSpecifierCase {
      get { return pathSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPathSpecifier() {
      pathSpecifierCase_ = PathSpecifierOneofCase.None;
      pathSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RouteMatch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RouteMatch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Prefix != other.Prefix) return false;
      if (Path != other.Path) return false;
      if (Regex != other.Regex) return false;
      if (CaseSensitive != other.CaseSensitive) return false;
      if (!object.Equals(Runtime, other.Runtime)) return false;
      if(!headers_.Equals(other.headers_)) return false;
      if(!queryParameters_.Equals(other.queryParameters_)) return false;
      if (PathSpecifierCase != other.PathSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) hash ^= Prefix.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) hash ^= Regex.GetHashCode();
      if (caseSensitive_ != null) hash ^= CaseSensitive.GetHashCode();
      if (runtime_ != null) hash ^= Runtime.GetHashCode();
      hash ^= headers_.GetHashCode();
      hash ^= queryParameters_.GetHashCode();
      hash ^= (int) pathSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) {
        output.WriteRawTag(26);
        output.WriteString(Regex);
      }
      if (caseSensitive_ != null) {
        _single_caseSensitive_codec.WriteTagAndValue(output, CaseSensitive);
      }
      if (runtime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Runtime);
      }
      headers_.WriteTo(output, _repeated_headers_codec);
      queryParameters_.WriteTo(output, _repeated_queryParameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Regex);
      }
      if (caseSensitive_ != null) {
        size += _single_caseSensitive_codec.CalculateSizeWithTag(CaseSensitive);
      }
      if (runtime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Runtime);
      }
      size += headers_.CalculateSize(_repeated_headers_codec);
      size += queryParameters_.CalculateSize(_repeated_queryParameters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RouteMatch other) {
      if (other == null) {
        return;
      }
      if (other.caseSensitive_ != null) {
        if (caseSensitive_ == null || other.CaseSensitive != false) {
          CaseSensitive = other.CaseSensitive;
        }
      }
      if (other.runtime_ != null) {
        if (runtime_ == null) {
          runtime_ = new global::Envoy.Api.V2.Core.RuntimeUInt32();
        }
        Runtime.MergeFrom(other.Runtime);
      }
      headers_.Add(other.headers_);
      queryParameters_.Add(other.queryParameters_);
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.Regex:
          Regex = other.Regex;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            Regex = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_caseSensitive_codec.Read(input);
            if (caseSensitive_ == null || value != false) {
              CaseSensitive = value;
            }
            break;
          }
          case 42: {
            if (runtime_ == null) {
              runtime_ = new global::Envoy.Api.V2.Core.RuntimeUInt32();
            }
            input.ReadMessage(runtime_);
            break;
          }
          case 50: {
            headers_.AddEntriesFrom(input, _repeated_headers_codec);
            break;
          }
          case 58: {
            queryParameters_.AddEntriesFrom(input, _repeated_queryParameters_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class CorsPolicy : pb::IMessage<CorsPolicy> {
    private static readonly pb::MessageParser<CorsPolicy> _parser = new pb::MessageParser<CorsPolicy>(() => new CorsPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CorsPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy(CorsPolicy other) : this() {
      allowOrigin_ = other.allowOrigin_.Clone();
      allowMethods_ = other.allowMethods_;
      allowHeaders_ = other.allowHeaders_;
      exposeHeaders_ = other.exposeHeaders_;
      maxAge_ = other.maxAge_;
      AllowCredentials = other.AllowCredentials;
      Enabled = other.Enabled;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy Clone() {
      return new CorsPolicy(this);
    }

    /// <summary>Field number for the "allow_origin" field.</summary>
    public const int AllowOriginFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_allowOrigin_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> allowOrigin_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies the origins that will be allowed to do CORS requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AllowOrigin {
      get { return allowOrigin_; }
    }

    /// <summary>Field number for the "allow_methods" field.</summary>
    public const int AllowMethodsFieldNumber = 2;
    private string allowMethods_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-allow-methods* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AllowMethods {
      get { return allowMethods_; }
      set {
        allowMethods_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_headers" field.</summary>
    public const int AllowHeadersFieldNumber = 3;
    private string allowHeaders_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-allow-headers* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AllowHeaders {
      get { return allowHeaders_; }
      set {
        allowHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "expose_headers" field.</summary>
    public const int ExposeHeadersFieldNumber = 4;
    private string exposeHeaders_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-expose-headers* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExposeHeaders {
      get { return exposeHeaders_; }
      set {
        exposeHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_age" field.</summary>
    public const int MaxAgeFieldNumber = 5;
    private string maxAge_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-max-age* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MaxAge {
      get { return maxAge_; }
      set {
        maxAge_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_credentials" field.</summary>
    public const int AllowCredentialsFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_allowCredentials_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? allowCredentials_;
    /// <summary>
    /// Specifies whether the resource allows credentials.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AllowCredentials {
      get { return allowCredentials_; }
      set {
        allowCredentials_ = value;
      }
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    private bool? enabled_;
    /// <summary>
    /// Specifies if CORS is enabled. Defaults to true. Only effective on route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CorsPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CorsPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!allowOrigin_.Equals(other.allowOrigin_)) return false;
      if (AllowMethods != other.AllowMethods) return false;
      if (AllowHeaders != other.AllowHeaders) return false;
      if (ExposeHeaders != other.ExposeHeaders) return false;
      if (MaxAge != other.MaxAge) return false;
      if (AllowCredentials != other.AllowCredentials) return false;
      if (Enabled != other.Enabled) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= allowOrigin_.GetHashCode();
      if (AllowMethods.Length != 0) hash ^= AllowMethods.GetHashCode();
      if (AllowHeaders.Length != 0) hash ^= AllowHeaders.GetHashCode();
      if (ExposeHeaders.Length != 0) hash ^= ExposeHeaders.GetHashCode();
      if (MaxAge.Length != 0) hash ^= MaxAge.GetHashCode();
      if (allowCredentials_ != null) hash ^= AllowCredentials.GetHashCode();
      if (enabled_ != null) hash ^= Enabled.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      allowOrigin_.WriteTo(output, _repeated_allowOrigin_codec);
      if (AllowMethods.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(MaxAge);
      }
      if (allowCredentials_ != null) {
        _single_allowCredentials_codec.WriteTagAndValue(output, AllowCredentials);
      }
      if (enabled_ != null) {
        _single_enabled_codec.WriteTagAndValue(output, Enabled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += allowOrigin_.CalculateSize(_repeated_allowOrigin_codec);
      if (AllowMethods.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MaxAge);
      }
      if (allowCredentials_ != null) {
        size += _single_allowCredentials_codec.CalculateSizeWithTag(AllowCredentials);
      }
      if (enabled_ != null) {
        size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CorsPolicy other) {
      if (other == null) {
        return;
      }
      allowOrigin_.Add(other.allowOrigin_);
      if (other.AllowMethods.Length != 0) {
        AllowMethods = other.AllowMethods;
      }
      if (other.AllowHeaders.Length != 0) {
        AllowHeaders = other.AllowHeaders;
      }
      if (other.ExposeHeaders.Length != 0) {
        ExposeHeaders = other.ExposeHeaders;
      }
      if (other.MaxAge.Length != 0) {
        MaxAge = other.MaxAge;
      }
      if (other.allowCredentials_ != null) {
        if (allowCredentials_ == null || other.AllowCredentials != false) {
          AllowCredentials = other.AllowCredentials;
        }
      }
      if (other.enabled_ != null) {
        if (enabled_ == null || other.Enabled != false) {
          Enabled = other.Enabled;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            allowOrigin_.AddEntriesFrom(input, _repeated_allowOrigin_codec);
            break;
          }
          case 18: {
            AllowMethods = input.ReadString();
            break;
          }
          case 26: {
            AllowHeaders = input.ReadString();
            break;
          }
          case 34: {
            ExposeHeaders = input.ReadString();
            break;
          }
          case 42: {
            MaxAge = input.ReadString();
            break;
          }
          case 50: {
            bool? value = _single_allowCredentials_codec.Read(input);
            if (allowCredentials_ == null || value != false) {
              AllowCredentials = value;
            }
            break;
          }
          case 58: {
            bool? value = _single_enabled_codec.Read(input);
            if (enabled_ == null || value != false) {
              Enabled = value;
            }
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#comment:next free field: 24]
  /// </summary>
  public sealed partial class RouteAction : pb::IMessage<RouteAction> {
    private static readonly pb::MessageParser<RouteAction> _parser = new pb::MessageParser<RouteAction>(() => new RouteAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RouteAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction(RouteAction other) : this() {
      clusterNotFoundResponseCode_ = other.clusterNotFoundResponseCode_;
      MetadataMatch = other.metadataMatch_ != null ? other.MetadataMatch.Clone() : null;
      prefixRewrite_ = other.prefixRewrite_;
      Timeout = other.timeout_ != null ? other.Timeout.Clone() : null;
      RetryPolicy = other.retryPolicy_ != null ? other.RetryPolicy.Clone() : null;
      RequestMirrorPolicy = other.requestMirrorPolicy_ != null ? other.RequestMirrorPolicy.Clone() : null;
      priority_ = other.priority_;
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      rateLimits_ = other.rateLimits_.Clone();
      IncludeVhRateLimits = other.IncludeVhRateLimits;
      hashPolicy_ = other.hashPolicy_.Clone();
      UseWebsocket = other.UseWebsocket;
      WebsocketConfig = other.websocketConfig_ != null ? other.WebsocketConfig.Clone() : null;
      Cors = other.cors_ != null ? other.Cors.Clone() : null;
      MaxGrpcTimeout = other.maxGrpcTimeout_ != null ? other.MaxGrpcTimeout.Clone() : null;
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          WeightedClusters = other.WeightedClusters.Clone();
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewrite:
          HostRewrite = other.HostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction Clone() {
      return new RouteAction(this);
    }

    /// <summary>Field number for the "cluster" field.</summary>
    public const int ClusterFieldNumber = 1;
    /// <summary>
    /// Indicates the upstream cluster to which the request should be routed
    /// to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Cluster {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.Cluster;
      }
    }

    /// <summary>Field number for the "cluster_header" field.</summary>
    public const int ClusterHeaderFieldNumber = 2;
    /// <summary>
    /// Envoy will determine the cluster to route to by reading the value of the
    /// HTTP header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist, Envoy will
    /// return a 404 response.
    ///
    /// .. attention::
    ///
    ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
    ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClusterHeader {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.ClusterHeader;
      }
    }

    /// <summary>Field number for the "weighted_clusters" field.</summary>
    public const int WeightedClustersFieldNumber = 3;
    /// <summary>
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster. See
    /// :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split>`
    /// for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.WeightedCluster WeightedClusters {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters ? (global::Envoy.Api.V2.Route.WeightedCluster) clusterSpecifier_ : null; }
      set {
        clusterSpecifier_ = value;
        clusterSpecifierCase_ = value == null ? ClusterSpecifierOneofCase.None : ClusterSpecifierOneofCase.WeightedClusters;
      }
    }

    /// <summary>Field number for the "cluster_not_found_response_code" field.</summary>
    public const int ClusterNotFoundResponseCodeFieldNumber = 20;
    private global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode clusterNotFoundResponseCode_ = 0;
    /// <summary>
    /// The HTTP status code to use when configured cluster is not found.
    /// The default response code is 503 Service Unavailable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode ClusterNotFoundResponseCode {
      get { return clusterNotFoundResponseCode_; }
      set {
        clusterNotFoundResponseCode_ = value;
      }
    }

    /// <summary>Field number for the "metadata_match" field.</summary>
    public const int MetadataMatchFieldNumber = 4;
    private global::Envoy.Api.V2.Core.Metadata metadataMatch_;
    /// <summary>
    /// Optional endpoint metadata match criteria. Only endpoints in the upstream
    /// cluster with metadata matching that set in metadata_match will be
    /// considered. The filter name should be specified as *envoy.lb*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata MetadataMatch {
      get { return metadataMatch_; }
      set {
        metadataMatch_ = value;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    private string prefixRewrite_ = "";
    /// <summary>
    /// Indicates that during forwarding, the matched prefix (or path) should be
    /// swapped with this value. This option allows application URLs to be rooted
    /// at a different path from those exposed at the reverse proxy layer. The router filter will
    /// place the original path before rewrite into the :ref:`x-envoy-original-path
    /// &lt;config_http_filters_router_x-envoy-original-path>` header.
    ///
    /// .. attention::
    ///
    ///   Pay careful attention to the use of trailing slashes in the
    ///   :ref:`route's match &lt;envoy_api_field_route.Route.match>` prefix value.
    ///   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
    ///   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
    ///   :ref:`Route &lt;envoy_api_msg_route.Route>`, as shown by the below config entries:
    ///
    ///   .. code-block:: yaml
    ///
    ///     - match:
    ///         prefix: "/prefix/"
    ///       route:
    ///         prefix_rewrite: "/"
    ///     - match:
    ///         prefix: "/prefix"
    ///       route:
    ///         prefix_rewrite: "/"
    ///
    ///   Having above entries in the config, requests to */prefix* will be stripped to */*, while
    ///   requests to */prefix/etc* will be stripped to */etc*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixRewrite {
      get { return prefixRewrite_; }
      set {
        prefixRewrite_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "host_rewrite" field.</summary>
    public const int HostRewriteFieldNumber = 6;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HostRewrite {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite ? (string) hostRewriteSpecifier_ : ""; }
      set {
        hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.HostRewrite;
      }
    }

    /// <summary>Field number for the "auto_host_rewrite" field.</summary>
    public const int AutoHostRewriteFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _oneof_autoHostRewrite_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// the hostname of the upstream host chosen by the cluster manager. This
    /// option is applicable only when the destination cluster for a route is of
    /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
    /// types has no effect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AutoHostRewrite {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite ? (bool?) hostRewriteSpecifier_ : (bool?) null; }
      set {
        hostRewriteSpecifier_ = value;
        hostRewriteSpecifierCase_ = value == null ? HostRewriteSpecifierOneofCase.None : HostRewriteSpecifierOneofCase.AutoHostRewrite;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// Specifies the timeout for the route. If not specified, the default is 15s.
    ///
    /// .. note::
    ///
    ///   This timeout includes all retries. See also
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
    ///   :ref:`retry overview &lt;arch_overview_http_routing_retry>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 9;
    private global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy retryPolicy_;
    /// <summary>
    /// Indicates that the route has a retry policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy RetryPolicy {
      get { return retryPolicy_; }
      set {
        retryPolicy_ = value;
      }
    }

    /// <summary>Field number for the "request_mirror_policy" field.</summary>
    public const int RequestMirrorPolicyFieldNumber = 10;
    private global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy requestMirrorPolicy_;
    /// <summary>
    /// Indicates that the route has a request mirroring policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy RequestMirrorPolicy {
      get { return requestMirrorPolicy_; }
      set {
        requestMirrorPolicy_ = value;
      }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 11;
    private global::Envoy.Api.V2.Core.RoutingPriority priority_ = 0;
    /// <summary>
    /// Optionally specifies the :ref:`routing priority &lt;arch_overview_http_routing_priority>`.
    /// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
    /// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RoutingPriority Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(98, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to requests matching this
    /// route. Headers specified at this level are applied before headers from the
    /// enclosing :ref:`envoy_api_msg_route.VirtualHost` and
    /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to responses to requests
    /// matching this route. Headers specified at this level are applied before
    /// headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
    /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on
    /// :ref:`custom request headers &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 19;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(154);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// to requests matching this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Api.V2.Route.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that could be applied to the
    /// route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "include_vh_rate_limits" field.</summary>
    public const int IncludeVhRateLimitsFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_includeVhRateLimits_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? includeVhRateLimits_;
    /// <summary>
    /// Specifies if the rate limit filter should include the virtual host rate
    /// limits. By default, if the route configured rate limits, the virtual host
    /// :ref:`rate_limits &lt;envoy_api_field_route.VirtualHost.rate_limits>` are not applied to the
    /// request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? IncludeVhRateLimits {
      get { return includeVhRateLimits_; }
      set {
        includeVhRateLimits_ = value;
      }
    }

    /// <summary>Field number for the "hash_policy" field.</summary>
    public const int HashPolicyFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> _repeated_hashPolicy_codec
        = pb::FieldCodec.ForMessage(122, global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> hashPolicy_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy>();
    /// <summary>
    /// Specifies a list of hash policies to use for ring hash load balancing. Each
    /// hash policy is evaluated individually and the combined result is used to
    /// route the request. The method of combination is deterministic such that
    /// identical lists of hash policies will produce the same hash. Since a hash
    /// policy examines specific parts of a request, it can fail to produce a hash
    /// (i.e. if the hashed header is not present). If (and only if) all configured
    /// hash policies fail to generate a hash, no hash will be produced for
    /// the route. In this case, the behavior is the same as if no hash policies
    /// were specified (i.e. the ring hash load balancer will choose a random
    /// backend).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> HashPolicy {
      get { return hashPolicy_; }
    }

    /// <summary>Field number for the "use_websocket" field.</summary>
    public const int UseWebsocketFieldNumber = 16;
    private static readonly pb::FieldCodec<bool?> _single_useWebsocket_codec = pb::FieldCodec.ForStructWrapper<bool>(130);
    private bool? useWebsocket_;
    /// <summary>
    /// Indicates that a HTTP/1.1 client connection to this particular route is allowed to
    /// upgrade to a WebSocket connection. The default is false.
    ///
    /// .. attention::
    ///
    ///   If a connection is upgraded to a WebSocket connection, Envoy will set up plain TCP
    ///   proxying between the client and the upstream server. Hence, an upstream
    ///   server that rejects the WebSocket upgrade request is also responsible for
    ///   closing the associated connection. Until then, Envoy will continue to
    ///   proxy data from the client to the upstream server.
    ///
    ///   Redirects are not supported on routes where WebSocket upgrades are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseWebsocket {
      get { return useWebsocket_; }
      set {
        useWebsocket_ = value;
      }
    }

    /// <summary>Field number for the "websocket_config" field.</summary>
    public const int WebsocketConfigFieldNumber = 22;
    private global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig websocketConfig_;
    /// <summary>
    /// Proxy configuration used for WebSocket connections. If unset, the default values as specified
    /// in :ref:`TcpProxy &lt;envoy_api_msg_config.filter.network.tcp_proxy.v2.TcpProxy>` are used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig WebsocketConfig {
      get { return websocketConfig_; }
      set {
        websocketConfig_ = value;
      }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 17;
    private global::Envoy.Api.V2.Route.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the route has a CORS policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "max_grpc_timeout" field.</summary>
    public const int MaxGrpcTimeoutFieldNumber = 23;
    private global::Google.Protobuf.WellKnownTypes.Duration maxGrpcTimeout_;
    /// <summary>
    /// If present, and the request is a gRPC request, use the
    /// `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
    /// or its default value (infinity) instead of
    /// :ref:`timeout &lt;envoy_api_field_route.RouteAction.timeout>`, but limit the applied timeout
    /// to the maximum value specified here. If configured as 0, the maximum allowed timeout for
    /// gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
    /// and gRPC requests time out like any other requests using
    /// :ref:`timeout &lt;envoy_api_field_route.RouteAction.timeout>` or its default.
    /// This can be used to prevent unexpected upstream request timeouts due to potentially long
    /// time gaps between gRPC request and response in gRPC streaming mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxGrpcTimeout {
      get { return maxGrpcTimeout_; }
      set {
        maxGrpcTimeout_ = value;
      }
    }

    private object clusterSpecifier_;
    /// <summary>Enum of possible cases for the "cluster_specifier" oneof.</summary>
    public enum ClusterSpecifierOneofCase {
      None = 0,
      Cluster = 1,
      ClusterHeader = 2,
      WeightedClusters = 3,
    }
    private ClusterSpecifierOneofCase clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterSpecifierOneofCase ClusterSpecifierCase {
      get { return clusterSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterSpecifier() {
      clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
      clusterSpecifier_ = null;
    }

    private object hostRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "host_rewrite_specifier" oneof.</summary>
    public enum HostRewriteSpecifierOneofCase {
      None = 0,
      HostRewrite = 6,
      AutoHostRewrite = 7,
    }
    private HostRewriteSpecifierOneofCase hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HostRewriteSpecifierOneofCase HostRewriteSpecifierCase {
      get { return hostRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHostRewriteSpecifier() {
      hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
      hostRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RouteAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RouteAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Cluster != other.Cluster) return false;
      if (ClusterHeader != other.ClusterHeader) return false;
      if (!object.Equals(WeightedClusters, other.WeightedClusters)) return false;
      if (ClusterNotFoundResponseCode != other.ClusterNotFoundResponseCode) return false;
      if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (HostRewrite != other.HostRewrite) return false;
      if (AutoHostRewrite != other.AutoHostRewrite) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(RequestMirrorPolicy, other.RequestMirrorPolicy)) return false;
      if (Priority != other.Priority) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if (IncludeVhRateLimits != other.IncludeVhRateLimits) return false;
      if(!hashPolicy_.Equals(other.hashPolicy_)) return false;
      if (UseWebsocket != other.UseWebsocket) return false;
      if (!object.Equals(WebsocketConfig, other.WebsocketConfig)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!object.Equals(MaxGrpcTimeout, other.MaxGrpcTimeout)) return false;
      if (ClusterSpecifierCase != other.ClusterSpecifierCase) return false;
      if (HostRewriteSpecifierCase != other.HostRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) hash ^= Cluster.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) hash ^= ClusterHeader.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) hash ^= WeightedClusters.GetHashCode();
      if (ClusterNotFoundResponseCode != 0) hash ^= ClusterNotFoundResponseCode.GetHashCode();
      if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
      if (PrefixRewrite.Length != 0) hash ^= PrefixRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) hash ^= HostRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) hash ^= AutoHostRewrite.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (retryPolicy_ != null) hash ^= RetryPolicy.GetHashCode();
      if (requestMirrorPolicy_ != null) hash ^= RequestMirrorPolicy.GetHashCode();
      if (Priority != 0) hash ^= Priority.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      if (includeVhRateLimits_ != null) hash ^= IncludeVhRateLimits.GetHashCode();
      hash ^= hashPolicy_.GetHashCode();
      if (useWebsocket_ != null) hash ^= UseWebsocket.GetHashCode();
      if (websocketConfig_ != null) hash ^= WebsocketConfig.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      if (maxGrpcTimeout_ != null) hash ^= MaxGrpcTimeout.GetHashCode();
      hash ^= (int) clusterSpecifierCase_;
      hash ^= (int) hostRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        output.WriteRawTag(10);
        output.WriteString(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        output.WriteRawTag(18);
        output.WriteString(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        output.WriteRawTag(26);
        output.WriteMessage(WeightedClusters);
      }
      if (metadataMatch_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) {
        output.WriteRawTag(50);
        output.WriteString(HostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        _oneof_autoHostRewrite_codec.WriteTagAndValue(output, (bool?) hostRewriteSpecifier_);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      if (retryPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RetryPolicy);
      }
      if (requestMirrorPolicy_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RequestMirrorPolicy);
      }
      if (Priority != 0) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Priority);
      }
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        _single_includeVhRateLimits_codec.WriteTagAndValue(output, IncludeVhRateLimits);
      }
      hashPolicy_.WriteTo(output, _repeated_hashPolicy_codec);
      if (useWebsocket_ != null) {
        _single_useWebsocket_codec.WriteTagAndValue(output, UseWebsocket);
      }
      if (cors_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Cors);
      }
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      if (ClusterNotFoundResponseCode != 0) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) ClusterNotFoundResponseCode);
      }
      if (websocketConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(WebsocketConfig);
      }
      if (maxGrpcTimeout_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(MaxGrpcTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedClusters);
      }
      if (ClusterNotFoundResponseCode != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ClusterNotFoundResponseCode);
      }
      if (metadataMatch_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        size += _oneof_autoHostRewrite_codec.CalculateSizeWithTag(AutoHostRewrite);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (retryPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (requestMirrorPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestMirrorPolicy);
      }
      if (Priority != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Priority);
      }
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        size += _single_includeVhRateLimits_codec.CalculateSizeWithTag(IncludeVhRateLimits);
      }
      size += hashPolicy_.CalculateSize(_repeated_hashPolicy_codec);
      if (useWebsocket_ != null) {
        size += _single_useWebsocket_codec.CalculateSizeWithTag(UseWebsocket);
      }
      if (websocketConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(WebsocketConfig);
      }
      if (cors_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      if (maxGrpcTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaxGrpcTimeout);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RouteAction other) {
      if (other == null) {
        return;
      }
      if (other.ClusterNotFoundResponseCode != 0) {
        ClusterNotFoundResponseCode = other.ClusterNotFoundResponseCode;
      }
      if (other.metadataMatch_ != null) {
        if (metadataMatch_ == null) {
          metadataMatch_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        MetadataMatch.MergeFrom(other.MetadataMatch);
      }
      if (other.PrefixRewrite.Length != 0) {
        PrefixRewrite = other.PrefixRewrite;
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.retryPolicy_ != null) {
        if (retryPolicy_ == null) {
          retryPolicy_ = new global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy();
        }
        RetryPolicy.MergeFrom(other.RetryPolicy);
      }
      if (other.requestMirrorPolicy_ != null) {
        if (requestMirrorPolicy_ == null) {
          requestMirrorPolicy_ = new global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy();
        }
        RequestMirrorPolicy.MergeFrom(other.RequestMirrorPolicy);
      }
      if (other.Priority != 0) {
        Priority = other.Priority;
      }
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      rateLimits_.Add(other.rateLimits_);
      if (other.includeVhRateLimits_ != null) {
        if (includeVhRateLimits_ == null || other.IncludeVhRateLimits != false) {
          IncludeVhRateLimits = other.IncludeVhRateLimits;
        }
      }
      hashPolicy_.Add(other.hashPolicy_);
      if (other.useWebsocket_ != null) {
        if (useWebsocket_ == null || other.UseWebsocket != false) {
          UseWebsocket = other.UseWebsocket;
        }
      }
      if (other.websocketConfig_ != null) {
        if (websocketConfig_ == null) {
          websocketConfig_ = new global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig();
        }
        WebsocketConfig.MergeFrom(other.WebsocketConfig);
      }
      if (other.cors_ != null) {
        if (cors_ == null) {
          cors_ = new global::Envoy.Api.V2.Route.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      if (other.maxGrpcTimeout_ != null) {
        if (maxGrpcTimeout_ == null) {
          maxGrpcTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxGrpcTimeout.MergeFrom(other.MaxGrpcTimeout);
      }
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          if (WeightedClusters == null) {
            WeightedClusters = new global::Envoy.Api.V2.Route.WeightedCluster();
          }
          WeightedClusters.MergeFrom(other.WeightedClusters);
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewrite:
          HostRewrite = other.HostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Cluster = input.ReadString();
            break;
          }
          case 18: {
            ClusterHeader = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Route.WeightedCluster subBuilder = new global::Envoy.Api.V2.Route.WeightedCluster();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
              subBuilder.MergeFrom(WeightedClusters);
            }
            input.ReadMessage(subBuilder);
            WeightedClusters = subBuilder;
            break;
          }
          case 34: {
            if (metadataMatch_ == null) {
              metadataMatch_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadataMatch_);
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 50: {
            HostRewrite = input.ReadString();
            break;
          }
          case 58: {
            AutoHostRewrite = _oneof_autoHostRewrite_codec.Read(input);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(timeout_);
            break;
          }
          case 74: {
            if (retryPolicy_ == null) {
              retryPolicy_ = new global::Envoy.Api.V2.Route.RouteAction.Types.RetryPolicy();
            }
            input.ReadMessage(retryPolicy_);
            break;
          }
          case 82: {
            if (requestMirrorPolicy_ == null) {
              requestMirrorPolicy_ = new global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy();
            }
            input.ReadMessage(requestMirrorPolicy_);
            break;
          }
          case 88: {
            priority_ = (global::Envoy.Api.V2.Core.RoutingPriority) input.ReadEnum();
            break;
          }
          case 98: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 106: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 114: {
            bool? value = _single_includeVhRateLimits_codec.Read(input);
            if (includeVhRateLimits_ == null || value != false) {
              IncludeVhRateLimits = value;
            }
            break;
          }
          case 122: {
            hashPolicy_.AddEntriesFrom(input, _repeated_hashPolicy_codec);
            break;
          }
          case 130: {
            bool? value = _single_useWebsocket_codec.Read(input);
            if (useWebsocket_ == null || value != false) {
              UseWebsocket = value;
            }
            break;
          }
          case 138: {
            if (cors_ == null) {
              cors_ = new global::Envoy.Api.V2.Route.CorsPolicy();
            }
            input.ReadMessage(cors_);
            break;
          }
          case 146: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 154: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 160: {
            clusterNotFoundResponseCode_ = (global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode) input.ReadEnum();
            break;
          }
          case 178: {
            if (websocketConfig_ == null) {
              websocketConfig_ = new global::Envoy.Api.V2.Route.RouteAction.Types.WebSocketProxyConfig();
            }
            input.ReadMessage(websocketConfig_);
            break;
          }
          case 186: {
            if (maxGrpcTimeout_ == null) {
              maxGrpcTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(maxGrpcTimeout_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RouteAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum ClusterNotFoundResponseCode {
        /// <summary>
        /// HTTP status code - 503 Service Unavailable.
        /// </summary>
        [pbr::OriginalName("SERVICE_UNAVAILABLE")] ServiceUnavailable = 0,
        /// <summary>
        /// HTTP status code - 404 Not Found.
        /// </summary>
        [pbr::OriginalName("NOT_FOUND")] NotFound = 1,
      }

      /// <summary>
      /// HTTP retry :ref:`architecture overview &lt;arch_overview_http_routing_retry>`.
      /// </summary>
      public sealed partial class RetryPolicy : pb::IMessage<RetryPolicy> {
        private static readonly pb::MessageParser<RetryPolicy> _parser = new pb::MessageParser<RetryPolicy>(() => new RetryPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy(RetryPolicy other) : this() {
          retryOn_ = other.retryOn_;
          NumRetries = other.NumRetries;
          PerTryTimeout = other.perTryTimeout_ != null ? other.PerTryTimeout.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy Clone() {
          return new RetryPolicy(this);
        }

        /// <summary>Field number for the "retry_on" field.</summary>
        public const int RetryOnFieldNumber = 1;
        private string retryOn_ = "";
        /// <summary>
        /// Specifies the conditions under which retry takes place. These are the same
        /// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
        /// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string RetryOn {
          get { return retryOn_; }
          set {
            retryOn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "num_retries" field.</summary>
        public const int NumRetriesFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_numRetries_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? numRetries_;
        /// <summary>
        /// Specifies the allowed number of retries. This parameter is optional and
        /// defaults to 1. These are the same conditions documented for
        /// :ref:`config_http_filters_router_x-envoy-max-retries`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? NumRetries {
          get { return numRetries_; }
          set {
            numRetries_ = value;
          }
        }

        /// <summary>Field number for the "per_try_timeout" field.</summary>
        public const int PerTryTimeoutFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Duration perTryTimeout_;
        /// <summary>
        /// Specifies a non-zero timeout per retry attempt. This parameter is optional.
        /// The same conditions documented for
        /// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
        ///
        /// .. note::
        ///
        ///   If left unspecified, Envoy will use the global
        ///   :ref:`route timeout &lt;envoy_api_field_route.RouteAction.timeout>` for the request.
        ///   Consequently, when using a :ref:`5xx &lt;config_http_filters_router_x-envoy-retry-on>` based
        ///   retry policy, a request that times out will not be retried as the total timeout budget
        ///   would have been exhausted.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration PerTryTimeout {
          get { return perTryTimeout_; }
          set {
            perTryTimeout_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (RetryOn != other.RetryOn) return false;
          if (NumRetries != other.NumRetries) return false;
          if (!object.Equals(PerTryTimeout, other.PerTryTimeout)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (RetryOn.Length != 0) hash ^= RetryOn.GetHashCode();
          if (numRetries_ != null) hash ^= NumRetries.GetHashCode();
          if (perTryTimeout_ != null) hash ^= PerTryTimeout.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (RetryOn.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(RetryOn);
          }
          if (numRetries_ != null) {
            _single_numRetries_codec.WriteTagAndValue(output, NumRetries);
          }
          if (perTryTimeout_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(PerTryTimeout);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (RetryOn.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RetryOn);
          }
          if (numRetries_ != null) {
            size += _single_numRetries_codec.CalculateSizeWithTag(NumRetries);
          }
          if (perTryTimeout_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PerTryTimeout);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryPolicy other) {
          if (other == null) {
            return;
          }
          if (other.RetryOn.Length != 0) {
            RetryOn = other.RetryOn;
          }
          if (other.numRetries_ != null) {
            if (numRetries_ == null || other.NumRetries != 0) {
              NumRetries = other.NumRetries;
            }
          }
          if (other.perTryTimeout_ != null) {
            if (perTryTimeout_ == null) {
              perTryTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            PerTryTimeout.MergeFrom(other.PerTryTimeout);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                RetryOn = input.ReadString();
                break;
              }
              case 18: {
                uint? value = _single_numRetries_codec.Read(input);
                if (numRetries_ == null || value != 0) {
                  NumRetries = value;
                }
                break;
              }
              case 26: {
                if (perTryTimeout_ == null) {
                  perTryTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(perTryTimeout_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The router is capable of shadowing traffic from one cluster to another. The current
      /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      /// respond before returning the response from the primary cluster. All normal statistics are
      /// collected for the shadow cluster making this feature useful for testing.
      ///
      /// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
      /// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
      /// </summary>
      public sealed partial class RequestMirrorPolicy : pb::IMessage<RequestMirrorPolicy> {
        private static readonly pb::MessageParser<RequestMirrorPolicy> _parser = new pb::MessageParser<RequestMirrorPolicy>(() => new RequestMirrorPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RequestMirrorPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy(RequestMirrorPolicy other) : this() {
          cluster_ = other.cluster_;
          runtimeKey_ = other.runtimeKey_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy Clone() {
          return new RequestMirrorPolicy(this);
        }

        /// <summary>Field number for the "cluster" field.</summary>
        public const int ClusterFieldNumber = 1;
        private string cluster_ = "";
        /// <summary>
        /// Specifies the cluster that requests will be mirrored to. The cluster must
        /// exist in the cluster manager configuration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Cluster {
          get { return cluster_; }
          set {
            cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "runtime_key" field.</summary>
        public const int RuntimeKeyFieldNumber = 2;
        private string runtimeKey_ = "";
        /// <summary>
        /// If not specified, all requests to the target cluster will be mirrored. If
        /// specified, Envoy will lookup the runtime key to get the % of requests to
        /// mirror. Valid values are from 0 to 10000, allowing for increments of
        /// 0.01% of requests to be mirrored. If the runtime key is specified in the
        /// configuration but not present in runtime, 0 is the default and thus 0% of
        /// requests will be mirrored.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string RuntimeKey {
          get { return runtimeKey_; }
          set {
            runtimeKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RequestMirrorPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RequestMirrorPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Cluster != other.Cluster) return false;
          if (RuntimeKey != other.RuntimeKey) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
          if (RuntimeKey.Length != 0) hash ^= RuntimeKey.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Cluster.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Cluster);
          }
          if (RuntimeKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(RuntimeKey);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Cluster.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
          }
          if (RuntimeKey.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RuntimeKey);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RequestMirrorPolicy other) {
          if (other == null) {
            return;
          }
          if (other.Cluster.Length != 0) {
            Cluster = other.Cluster;
          }
          if (other.RuntimeKey.Length != 0) {
            RuntimeKey = other.RuntimeKey;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Cluster = input.ReadString();
                break;
              }
              case 18: {
                RuntimeKey = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
      /// &lt;arch_overview_load_balancing_types>`.
      /// </summary>
      public sealed partial class HashPolicy : pb::IMessage<HashPolicy> {
        private static readonly pb::MessageParser<HashPolicy> _parser = new pb::MessageParser<HashPolicy>(() => new HashPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HashPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy(HashPolicy other) : this() {
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              Header = other.Header.Clone();
              break;
            case PolicySpecifierOneofCase.Cookie:
              Cookie = other.Cookie.Clone();
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              ConnectionProperties = other.ConnectionProperties.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy Clone() {
          return new HashPolicy(this);
        }

        /// <summary>Field number for the "header" field.</summary>
        public const int HeaderFieldNumber = 1;
        /// <summary>
        /// Header hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header Header {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Header ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Header;
          }
        }

        /// <summary>Field number for the "cookie" field.</summary>
        public const int CookieFieldNumber = 2;
        /// <summary>
        /// Cookie hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie Cookie {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Cookie ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Cookie;
          }
        }

        /// <summary>Field number for the "connection_properties" field.</summary>
        public const int ConnectionPropertiesFieldNumber = 3;
        /// <summary>
        /// Connection properties hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties ConnectionProperties {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.ConnectionProperties;
          }
        }

        private object policySpecifier_;
        /// <summary>Enum of possible cases for the "policy_specifier" oneof.</summary>
        public enum PolicySpecifierOneofCase {
          None = 0,
          Header = 1,
          Cookie = 2,
          ConnectionProperties = 3,
        }
        private PolicySpecifierOneofCase policySpecifierCase_ = PolicySpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PolicySpecifierOneofCase PolicySpecifierCase {
          get { return policySpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearPolicySpecifier() {
          policySpecifierCase_ = PolicySpecifierOneofCase.None;
          policySpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HashPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HashPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Header, other.Header)) return false;
          if (!object.Equals(Cookie, other.Cookie)) return false;
          if (!object.Equals(ConnectionProperties, other.ConnectionProperties)) return false;
          if (PolicySpecifierCase != other.PolicySpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) hash ^= Header.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) hash ^= Cookie.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) hash ^= ConnectionProperties.GetHashCode();
          hash ^= (int) policySpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            output.WriteRawTag(10);
            output.WriteMessage(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            output.WriteRawTag(18);
            output.WriteMessage(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectionProperties);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionProperties);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HashPolicy other) {
          if (other == null) {
            return;
          }
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              if (Header == null) {
                Header = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header();
              }
              Header.MergeFrom(other.Header);
              break;
            case PolicySpecifierOneofCase.Cookie:
              if (Cookie == null) {
                Cookie = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie();
              }
              Cookie.MergeFrom(other.Cookie);
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              if (ConnectionProperties == null) {
                ConnectionProperties = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
              }
              ConnectionProperties.MergeFrom(other.ConnectionProperties);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
                  subBuilder.MergeFrom(Header);
                }
                input.ReadMessage(subBuilder);
                Header = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
                  subBuilder.MergeFrom(Cookie);
                }
                input.ReadMessage(subBuilder);
                Cookie = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
                  subBuilder.MergeFrom(ConnectionProperties);
                }
                input.ReadMessage(subBuilder);
                ConnectionProperties = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the HashPolicy message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class Header : pb::IMessage<Header> {
            private static readonly pb::MessageParser<Header> _parser = new pb::MessageParser<Header>(() => new Header());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Header> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header(Header other) : this() {
              headerName_ = other.headerName_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header Clone() {
              return new Header(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The name of the request header that will be used to obtain the hash
            /// key. If the request header is not present, no hash will be produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Header);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Header other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Header other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Envoy supports two types of cookie affinity:
          ///
          /// 1. Passive. Envoy takes a cookie that's present in the cookies header and
          ///    hashes on its value.
          ///
          /// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
          ///    on the first request from the client in its response to the client,
          ///    based on the endpoint the request gets sent to. The client then
          ///    presents this on the next and all subsequent requests. The hash of
          ///    this is sufficient to ensure these requests get sent to the same
          ///    endpoint. The cookie is generated by hashing the source and
          ///    destination ports and addresses so that multiple independent HTTP2
          ///    streams on the same connection will independently receive the same
          ///    cookie, even if they arrive at the Envoy simultaneously.
          /// </summary>
          public sealed partial class Cookie : pb::IMessage<Cookie> {
            private static readonly pb::MessageParser<Cookie> _parser = new pb::MessageParser<Cookie>(() => new Cookie());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Cookie> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie(Cookie other) : this() {
              name_ = other.name_;
              Ttl = other.ttl_ != null ? other.Ttl.Clone() : null;
              path_ = other.path_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie Clone() {
              return new Cookie(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            /// The name of the cookie that will be used to obtain the hash key. If the
            /// cookie is not present and ttl below is not set, no hash will be
            /// produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "ttl" field.</summary>
            public const int TtlFieldNumber = 2;
            private global::Google.Protobuf.WellKnownTypes.Duration ttl_;
            /// <summary>
            /// If specified, a cookie with the TTL will be generated if the cookie is
            /// not present. If the TTL is present and zero, the generated cookie will
            /// be a session cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Protobuf.WellKnownTypes.Duration Ttl {
              get { return ttl_; }
              set {
                ttl_ = value;
              }
            }

            /// <summary>Field number for the "path" field.</summary>
            public const int PathFieldNumber = 3;
            private string path_ = "";
            /// <summary>
            /// The name of the path for the cookie. If no path is specified here, no path
            /// will be set for the cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Path {
              get { return path_; }
              set {
                path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Cookie);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Cookie other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              if (!object.Equals(Ttl, other.Ttl)) return false;
              if (Path != other.Path) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              if (ttl_ != null) hash ^= Ttl.GetHashCode();
              if (Path.Length != 0) hash ^= Path.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (ttl_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(Ttl);
              }
              if (Path.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(Path);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              if (ttl_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ttl);
              }
              if (Path.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Cookie other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              if (other.ttl_ != null) {
                if (ttl_ == null) {
                  ttl_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                Ttl.MergeFrom(other.Ttl);
              }
              if (other.Path.Length != 0) {
                Path = other.Path;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (ttl_ == null) {
                      ttl_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(ttl_);
                    break;
                  }
                  case 26: {
                    Path = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          public sealed partial class ConnectionProperties : pb::IMessage<ConnectionProperties> {
            private static readonly pb::MessageParser<ConnectionProperties> _parser = new pb::MessageParser<ConnectionProperties>(() => new ConnectionProperties());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<ConnectionProperties> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties(ConnectionProperties other) : this() {
              sourceIp_ = other.sourceIp_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties Clone() {
              return new ConnectionProperties(this);
            }

            /// <summary>Field number for the "source_ip" field.</summary>
            public const int SourceIpFieldNumber = 1;
            private bool sourceIp_;
            /// <summary>
            /// Hash on source IP address.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool SourceIp {
              get { return sourceIp_; }
              set {
                sourceIp_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as ConnectionProperties);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(ConnectionProperties other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (SourceIp != other.SourceIp) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (SourceIp != false) hash ^= SourceIp.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (SourceIp != false) {
                output.WriteRawTag(8);
                output.WriteBool(SourceIp);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (SourceIp != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(ConnectionProperties other) {
              if (other == null) {
                return;
              }
              if (other.SourceIp != false) {
                SourceIp = other.SourceIp;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    SourceIp = input.ReadBool();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      public sealed partial class WebSocketProxyConfig : pb::IMessage<WebSocketProxyConfig> {
        private static readonly pb::MessageParser<WebSocketProxyConfig> _parser = new pb::MessageParser<WebSocketProxyConfig>(() => new WebSocketProxyConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<WebSocketProxyConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public WebSocketProxyConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public WebSocketProxyConfig(WebSocketProxyConfig other) : this() {
          statPrefix_ = other.statPrefix_;
          IdleTimeout = other.idleTimeout_ != null ? other.IdleTimeout.Clone() : null;
          MaxConnectAttempts = other.MaxConnectAttempts;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public WebSocketProxyConfig Clone() {
          return new WebSocketProxyConfig(this);
        }

        /// <summary>Field number for the "stat_prefix" field.</summary>
        public const int StatPrefixFieldNumber = 1;
        private string statPrefix_ = "";
        /// <summary>
        /// See :ref:`stat_prefix
        /// &lt;envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.stat_prefix>`. If the parameter
        /// is not specified, the default value of "websocket" is used.
        ///
        /// WebSocket connections support the :ref:`downstream statistics
        /// &lt;config_network_filters_tcp_proxy_stats>` for TCP proxy, except for the following, which are
        /// reported in the :ref:`HTTP Connection Manager statistics &lt;config_http_conn_man_stats>`:
        /// - downstream_cx_tx_bytes_total
        /// - downstream_cx_tx_bytes_buffered
        /// - downstream_cx_rx_bytes_total
        /// - downstream_cx_rx_bytes_buffered
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string StatPrefix {
          get { return statPrefix_; }
          set {
            statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "idle_timeout" field.</summary>
        public const int IdleTimeoutFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
        /// <summary>
        /// See :ref:`idle_timeout
        /// &lt;envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.idle_timeout>`. This timeout is
        /// only in effect after the WebSocket upgrade request is received by Envoy. It does not cover
        /// the initial part of the HTTP request.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
          get { return idleTimeout_; }
          set {
            idleTimeout_ = value;
          }
        }

        /// <summary>Field number for the "max_connect_attempts" field.</summary>
        public const int MaxConnectAttemptsFieldNumber = 3;
        private static readonly pb::FieldCodec<uint?> _single_maxConnectAttempts_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
        private uint? maxConnectAttempts_;
        /// <summary>
        /// See :ref:`max_connect_attempts
        /// &lt;envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.max_connect_attempts>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? MaxConnectAttempts {
          get { return maxConnectAttempts_; }
          set {
            maxConnectAttempts_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as WebSocketProxyConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(WebSocketProxyConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (StatPrefix != other.StatPrefix) return false;
          if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
          if (MaxConnectAttempts != other.MaxConnectAttempts) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
          if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
          if (maxConnectAttempts_ != null) hash ^= MaxConnectAttempts.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (StatPrefix.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(StatPrefix);
          }
          if (idleTimeout_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(IdleTimeout);
          }
          if (maxConnectAttempts_ != null) {
            _single_maxConnectAttempts_codec.WriteTagAndValue(output, MaxConnectAttempts);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (StatPrefix.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
          }
          if (idleTimeout_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
          }
          if (maxConnectAttempts_ != null) {
            size += _single_maxConnectAttempts_codec.CalculateSizeWithTag(MaxConnectAttempts);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(WebSocketProxyConfig other) {
          if (other == null) {
            return;
          }
          if (other.StatPrefix.Length != 0) {
            StatPrefix = other.StatPrefix;
          }
          if (other.idleTimeout_ != null) {
            if (idleTimeout_ == null) {
              idleTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            IdleTimeout.MergeFrom(other.IdleTimeout);
          }
          if (other.maxConnectAttempts_ != null) {
            if (maxConnectAttempts_ == null || other.MaxConnectAttempts != 0) {
              MaxConnectAttempts = other.MaxConnectAttempts;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                StatPrefix = input.ReadString();
                break;
              }
              case 18: {
                if (idleTimeout_ == null) {
                  idleTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(idleTimeout_);
                break;
              }
              case 26: {
                uint? value = _single_maxConnectAttempts_codec.Read(input);
                if (maxConnectAttempts_ == null || value != 0) {
                  MaxConnectAttempts = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class RedirectAction : pb::IMessage<RedirectAction> {
    private static readonly pb::MessageParser<RedirectAction> _parser = new pb::MessageParser<RedirectAction>(() => new RedirectAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RedirectAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction(RedirectAction other) : this() {
      hostRedirect_ = other.hostRedirect_;
      responseCode_ = other.responseCode_;
      httpsRedirect_ = other.httpsRedirect_;
      stripQuery_ = other.stripQuery_;
      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction Clone() {
      return new RedirectAction(this);
    }

    /// <summary>Field number for the "host_redirect" field.</summary>
    public const int HostRedirectFieldNumber = 1;
    private string hostRedirect_ = "";
    /// <summary>
    /// The host portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HostRedirect {
      get { return hostRedirect_; }
      set {
        hostRedirect_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "path_redirect" field.</summary>
    public const int PathRedirectFieldNumber = 2;
    /// <summary>
    /// The path portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PathRedirect {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PathRedirect;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    /// <summary>
    /// Indicates that during redirection, the matched prefix (or path)
    /// should be swapped with this value. This option allows redirect URLs be dynamically created
    /// based on the request.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the use of trailing slashes as mentioned in
    ///   :ref:`RouteAction's prefix_rewrite &lt;envoy_api_field_route.RouteAction.prefix_rewrite>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixRewrite {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PrefixRewrite;
      }
    }

    /// <summary>Field number for the "response_code" field.</summary>
    public const int ResponseCodeFieldNumber = 3;
    private global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode responseCode_ = 0;
    /// <summary>
    /// The HTTP status code to use in the redirect response. The default response
    /// code is MOVED_PERMANENTLY (301).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode ResponseCode {
      get { return responseCode_; }
      set {
        responseCode_ = value;
      }
    }

    /// <summary>Field number for the "https_redirect" field.</summary>
    public const int HttpsRedirectFieldNumber = 4;
    private bool httpsRedirect_;
    /// <summary>
    /// The scheme portion of the URL will be swapped with "https".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HttpsRedirect {
      get { return httpsRedirect_; }
      set {
        httpsRedirect_ = value;
      }
    }

    /// <summary>Field number for the "strip_query" field.</summary>
    public const int StripQueryFieldNumber = 6;
    private bool stripQuery_;
    /// <summary>
    /// Indicates that during redirection, the query portion of the URL will
    /// be removed. Default value is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StripQuery {
      get { return stripQuery_; }
      set {
        stripQuery_ = value;
      }
    }

    private object pathRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "path_rewrite_specifier" oneof.</summary>
    public enum PathRewriteSpecifierOneofCase {
      None = 0,
      PathRedirect = 2,
      PrefixRewrite = 5,
    }
    private PathRewriteSpecifierOneofCase pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PathRewriteSpecifierOneofCase PathRewriteSpecifierCase {
      get { return pathRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPathRewriteSpecifier() {
      pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
      pathRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RedirectAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RedirectAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HostRedirect != other.HostRedirect) return false;
      if (PathRedirect != other.PathRedirect) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (ResponseCode != other.ResponseCode) return false;
      if (HttpsRedirect != other.HttpsRedirect) return false;
      if (StripQuery != other.StripQuery) return false;
      if (PathRewriteSpecifierCase != other.PathRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HostRedirect.Length != 0) hash ^= HostRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) hash ^= PathRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) hash ^= PrefixRewrite.GetHashCode();
      if (ResponseCode != 0) hash ^= ResponseCode.GetHashCode();
      if (HttpsRedirect != false) hash ^= HttpsRedirect.GetHashCode();
      if (StripQuery != false) hash ^= StripQuery.GetHashCode();
      hash ^= (int) pathRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HostRedirect.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(HostRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        output.WriteRawTag(18);
        output.WriteString(PathRedirect);
      }
      if (ResponseCode != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ResponseCode);
      }
      if (HttpsRedirect != false) {
        output.WriteRawTag(32);
        output.WriteBool(HttpsRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (StripQuery != false) {
        output.WriteRawTag(48);
        output.WriteBool(StripQuery);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HostRedirect.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (ResponseCode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResponseCode);
      }
      if (HttpsRedirect != false) {
        size += 1 + 1;
      }
      if (StripQuery != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RedirectAction other) {
      if (other == null) {
        return;
      }
      if (other.HostRedirect.Length != 0) {
        HostRedirect = other.HostRedirect;
      }
      if (other.ResponseCode != 0) {
        ResponseCode = other.ResponseCode;
      }
      if (other.HttpsRedirect != false) {
        HttpsRedirect = other.HttpsRedirect;
      }
      if (other.StripQuery != false) {
        StripQuery = other.StripQuery;
      }
      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            HostRedirect = input.ReadString();
            break;
          }
          case 18: {
            PathRedirect = input.ReadString();
            break;
          }
          case 24: {
            responseCode_ = (global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode) input.ReadEnum();
            break;
          }
          case 32: {
            HttpsRedirect = input.ReadBool();
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 48: {
            StripQuery = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RedirectAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum RedirectResponseCode {
        /// <summary>
        /// Moved Permanently HTTP Status Code - 301.
        /// </summary>
        [pbr::OriginalName("MOVED_PERMANENTLY")] MovedPermanently = 0,
        /// <summary>
        /// Found HTTP Status Code - 302.
        /// </summary>
        [pbr::OriginalName("FOUND")] Found = 1,
        /// <summary>
        /// See Other HTTP Status Code - 303.
        /// </summary>
        [pbr::OriginalName("SEE_OTHER")] SeeOther = 2,
        /// <summary>
        /// Temporary Redirect HTTP Status Code - 307.
        /// </summary>
        [pbr::OriginalName("TEMPORARY_REDIRECT")] TemporaryRedirect = 3,
        /// <summary>
        /// Permanent Redirect HTTP Status Code - 308.
        /// </summary>
        [pbr::OriginalName("PERMANENT_REDIRECT")] PermanentRedirect = 4,
      }

    }
    #endregion

  }

  public sealed partial class DirectResponseAction : pb::IMessage<DirectResponseAction> {
    private static readonly pb::MessageParser<DirectResponseAction> _parser = new pb::MessageParser<DirectResponseAction>(() => new DirectResponseAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DirectResponseAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction(DirectResponseAction other) : this() {
      status_ = other.status_;
      Body = other.body_ != null ? other.Body.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction Clone() {
      return new DirectResponseAction(this);
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 1;
    private uint status_;
    /// <summary>
    /// Specifies the HTTP response status to be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 2;
    private global::Envoy.Api.V2.Core.DataSource body_;
    /// <summary>
    /// Specifies the content of the response body. If this setting is omitted,
    /// no body is included in the generated response.
    ///
    /// .. note::
    ///
    ///   Headers can be specified using *response_headers_to_add* in
    ///   :ref:`envoy_api_msg_RouteConfiguration`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource Body {
      get { return body_; }
      set {
        body_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DirectResponseAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DirectResponseAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      if (!object.Equals(Body, other.Body)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != 0) hash ^= Status.GetHashCode();
      if (body_ != null) hash ^= Body.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Status);
      }
      if (body_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Body);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Status);
      }
      if (body_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Body);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DirectResponseAction other) {
      if (other == null) {
        return;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.body_ != null) {
        if (body_ == null) {
          body_ = new global::Envoy.Api.V2.Core.DataSource();
        }
        Body.MergeFrom(other.Body);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = input.ReadUInt32();
            break;
          }
          case 18: {
            if (body_ == null) {
              body_ = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(body_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Decorator : pb::IMessage<Decorator> {
    private static readonly pb::MessageParser<Decorator> _parser = new pb::MessageParser<Decorator>(() => new Decorator());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Decorator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator(Decorator other) : this() {
      operation_ = other.operation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator Clone() {
      return new Decorator(this);
    }

    /// <summary>Field number for the "operation" field.</summary>
    public const int OperationFieldNumber = 1;
    private string operation_ = "";
    /// <summary>
    /// The operation name associated with the request matched to this route. If tracing is
    /// enabled, this information will be used as the span name reported for this request.
    ///
    /// .. note::
    ///
    ///   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
    ///   by the :ref:`x-envoy-decorator-operation
    ///   &lt;config_http_filters_router_x-envoy-decorator-operation>` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Operation {
      get { return operation_; }
      set {
        operation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Decorator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Decorator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Operation != other.Operation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Operation.Length != 0) hash ^= Operation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Operation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Operation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Operation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Decorator other) {
      if (other == null) {
        return;
      }
      if (other.Operation.Length != 0) {
        Operation = other.Operation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Operation = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A virtual cluster is a way of specifying a regex matching rule against
  /// certain important endpoints such that statistics are generated explicitly for
  /// the matched requests. The reason this is useful is that when doing
  /// prefix/path matching Envoy does not always know what the application
  /// considers to be an endpoint. Thus, it’s impossible for Envoy to generically
  /// emit per endpoint statistics. However, often systems have highly critical
  /// endpoints that they wish to get “perfect” statistics on. Virtual cluster
  /// statistics are perfect in the sense that they are emitted on the downstream
  /// side such that they include network level failures.
  ///
  /// Documentation for :ref:`virtual cluster statistics &lt;config_http_filters_router_stats>`.
  ///
  /// .. note::
  ///
  ///    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
  ///    every application endpoint. This is both not easily maintainable and as well the matching and
  ///    statistics output are not free.
  /// </summary>
  public sealed partial class VirtualCluster : pb::IMessage<VirtualCluster> {
    private static readonly pb::MessageParser<VirtualCluster> _parser = new pb::MessageParser<VirtualCluster>(() => new VirtualCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VirtualCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster(VirtualCluster other) : this() {
      pattern_ = other.pattern_;
      name_ = other.name_;
      method_ = other.method_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster Clone() {
      return new VirtualCluster(this);
    }

    /// <summary>Field number for the "pattern" field.</summary>
    public const int PatternFieldNumber = 1;
    private string pattern_ = "";
    /// <summary>
    /// Specifies a regex pattern to use for matching requests. The entire path of the request
    /// must match the regex. The regex grammar used is defined `here
    /// &lt;http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex */rides/\d+* matches the path */rides/0*
    /// * The regex */rides/\d+* matches the path */rides/123*
    /// * The regex */rides/\d+* does not match the path */rides/123/456*
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Pattern {
      get { return pattern_; }
      set {
        pattern_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    ///  Specifies the name of the virtual cluster. The virtual cluster name as well
    /// as the virtual host name are used when emitting statistics. The statistics are emitted by the
    /// router filter and are documented :ref:`here &lt;config_http_filters_router_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "method" field.</summary>
    public const int MethodFieldNumber = 3;
    private global::Envoy.Api.V2.Core.RequestMethod method_ = 0;
    /// <summary>
    /// Optionally specifies the HTTP method to match on. For example GET, PUT,
    /// etc.
    /// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
    /// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RequestMethod Method {
      get { return method_; }
      set {
        method_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VirtualCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VirtualCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Pattern != other.Pattern) return false;
      if (Name != other.Name) return false;
      if (Method != other.Method) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Pattern.Length != 0) hash ^= Pattern.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Method != 0) hash ^= Method.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Pattern.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Pattern);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Method != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Method);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Pattern.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pattern);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Method != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Method);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VirtualCluster other) {
      if (other == null) {
        return;
      }
      if (other.Pattern.Length != 0) {
        Pattern = other.Pattern;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Method != 0) {
        Method = other.Method;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Pattern = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            method_ = (global::Envoy.Api.V2.Core.RequestMethod) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Global rate limiting :ref:`architecture overview &lt;arch_overview_rate_limit>`.
  /// </summary>
  public sealed partial class RateLimit : pb::IMessage<RateLimit> {
    private static readonly pb::MessageParser<RateLimit> _parser = new pb::MessageParser<RateLimit>(() => new RateLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RateLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit(RateLimit other) : this() {
      Stage = other.Stage;
      disableKey_ = other.disableKey_;
      actions_ = other.actions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit Clone() {
      return new RateLimit(this);
    }

    /// <summary>Field number for the "stage" field.</summary>
    public const int StageFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_stage_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? stage_;
    /// <summary>
    /// Refers to the stage set in the filter. The rate limit configuration only
    /// applies to filters with the same stage number. The default stage number is
    /// 0.
    ///
    /// .. note::
    ///
    ///   The filter supports a range of 0 - 10 inclusively for stage numbers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? Stage {
      get { return stage_; }
      set {
        stage_ = value;
      }
    }

    /// <summary>Field number for the "disable_key" field.</summary>
    public const int DisableKeyFieldNumber = 2;
    private string disableKey_ = "";
    /// <summary>
    /// The key to be set in runtime to disable this rate limit configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisableKey {
      get { return disableKey_; }
      set {
        disableKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "actions" field.</summary>
    public const int ActionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit.Types.Action> _repeated_actions_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.RateLimit.Types.Action.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action> actions_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action>();
    /// <summary>
    /// A list of actions that are to be applied for this rate limit configuration.
    /// Order matters as the actions are processed sequentially and the descriptor
    /// is composed by appending descriptor entries in that sequence. If an action
    /// cannot append a descriptor entry, no descriptor is generated for the
    /// configuration. See :ref:`composing actions
    /// &lt;config_http_filters_rate_limit_composing_actions>` for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action> Actions {
      get { return actions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RateLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RateLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Stage != other.Stage) return false;
      if (DisableKey != other.DisableKey) return false;
      if(!actions_.Equals(other.actions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (stage_ != null) hash ^= Stage.GetHashCode();
      if (DisableKey.Length != 0) hash ^= DisableKey.GetHashCode();
      hash ^= actions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (stage_ != null) {
        _single_stage_codec.WriteTagAndValue(output, Stage);
      }
      if (DisableKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisableKey);
      }
      actions_.WriteTo(output, _repeated_actions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (stage_ != null) {
        size += _single_stage_codec.CalculateSizeWithTag(Stage);
      }
      if (DisableKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisableKey);
      }
      size += actions_.CalculateSize(_repeated_actions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RateLimit other) {
      if (other == null) {
        return;
      }
      if (other.stage_ != null) {
        if (stage_ == null || other.Stage != 0) {
          Stage = other.Stage;
        }
      }
      if (other.DisableKey.Length != 0) {
        DisableKey = other.DisableKey;
      }
      actions_.Add(other.actions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_stage_codec.Read(input);
            if (stage_ == null || value != 0) {
              Stage = value;
            }
            break;
          }
          case 18: {
            DisableKey = input.ReadString();
            break;
          }
          case 26: {
            actions_.AddEntriesFrom(input, _repeated_actions_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RateLimit message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Action : pb::IMessage<Action> {
        private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Action> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RateLimit.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action(Action other) : this() {
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              SourceCluster = other.SourceCluster.Clone();
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              DestinationCluster = other.DestinationCluster.Clone();
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              RequestHeaders = other.RequestHeaders.Clone();
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              RemoteAddress = other.RemoteAddress.Clone();
              break;
            case ActionSpecifierOneofCase.GenericKey:
              GenericKey = other.GenericKey.Clone();
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              HeaderValueMatch = other.HeaderValueMatch.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action Clone() {
          return new Action(this);
        }

        /// <summary>Field number for the "source_cluster" field.</summary>
        public const int SourceClusterFieldNumber = 1;
        /// <summary>
        /// Rate limit on source cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster SourceCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.SourceCluster;
          }
        }

        /// <summary>Field number for the "destination_cluster" field.</summary>
        public const int DestinationClusterFieldNumber = 2;
        /// <summary>
        /// Rate limit on destination cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster DestinationCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.DestinationCluster;
          }
        }

        /// <summary>Field number for the "request_headers" field.</summary>
        public const int RequestHeadersFieldNumber = 3;
        /// <summary>
        /// Rate limit on request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders RequestHeaders {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RequestHeaders;
          }
        }

        /// <summary>Field number for the "remote_address" field.</summary>
        public const int RemoteAddressFieldNumber = 4;
        /// <summary>
        /// Rate limit on remote address.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress RemoteAddress {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RemoteAddress;
          }
        }

        /// <summary>Field number for the "generic_key" field.</summary>
        public const int GenericKeyFieldNumber = 5;
        /// <summary>
        /// Rate limit on a generic key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey GenericKey {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.GenericKey;
          }
        }

        /// <summary>Field number for the "header_value_match" field.</summary>
        public const int HeaderValueMatchFieldNumber = 6;
        /// <summary>
        /// Rate limit on the existence of request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch HeaderValueMatch {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.HeaderValueMatch;
          }
        }

        private object actionSpecifier_;
        /// <summary>Enum of possible cases for the "action_specifier" oneof.</summary>
        public enum ActionSpecifierOneofCase {
          None = 0,
          SourceCluster = 1,
          DestinationCluster = 2,
          RequestHeaders = 3,
          RemoteAddress = 4,
          GenericKey = 5,
          HeaderValueMatch = 6,
        }
        private ActionSpecifierOneofCase actionSpecifierCase_ = ActionSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ActionSpecifierOneofCase ActionSpecifierCase {
          get { return actionSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearActionSpecifier() {
          actionSpecifierCase_ = ActionSpecifierOneofCase.None;
          actionSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Action);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Action other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(SourceCluster, other.SourceCluster)) return false;
          if (!object.Equals(DestinationCluster, other.DestinationCluster)) return false;
          if (!object.Equals(RequestHeaders, other.RequestHeaders)) return false;
          if (!object.Equals(RemoteAddress, other.RemoteAddress)) return false;
          if (!object.Equals(GenericKey, other.GenericKey)) return false;
          if (!object.Equals(HeaderValueMatch, other.HeaderValueMatch)) return false;
          if (ActionSpecifierCase != other.ActionSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) hash ^= SourceCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) hash ^= DestinationCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) hash ^= RequestHeaders.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) hash ^= RemoteAddress.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) hash ^= GenericKey.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) hash ^= HeaderValueMatch.GetHashCode();
          hash ^= (int) actionSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            output.WriteRawTag(10);
            output.WriteMessage(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            output.WriteRawTag(18);
            output.WriteMessage(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            output.WriteRawTag(26);
            output.WriteMessage(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            output.WriteRawTag(34);
            output.WriteMessage(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            output.WriteRawTag(42);
            output.WriteMessage(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            output.WriteRawTag(50);
            output.WriteMessage(HeaderValueMatch);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderValueMatch);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Action other) {
          if (other == null) {
            return;
          }
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              if (SourceCluster == null) {
                SourceCluster = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster();
              }
              SourceCluster.MergeFrom(other.SourceCluster);
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              if (DestinationCluster == null) {
                DestinationCluster = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster();
              }
              DestinationCluster.MergeFrom(other.DestinationCluster);
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              if (RequestHeaders == null) {
                RequestHeaders = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders();
              }
              RequestHeaders.MergeFrom(other.RequestHeaders);
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              if (RemoteAddress == null) {
                RemoteAddress = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress();
              }
              RemoteAddress.MergeFrom(other.RemoteAddress);
              break;
            case ActionSpecifierOneofCase.GenericKey:
              if (GenericKey == null) {
                GenericKey = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey();
              }
              GenericKey.MergeFrom(other.GenericKey);
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              if (HeaderValueMatch == null) {
                HeaderValueMatch = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch();
              }
              HeaderValueMatch.MergeFrom(other.HeaderValueMatch);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
                  subBuilder.MergeFrom(SourceCluster);
                }
                input.ReadMessage(subBuilder);
                SourceCluster = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
                  subBuilder.MergeFrom(DestinationCluster);
                }
                input.ReadMessage(subBuilder);
                DestinationCluster = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
                  subBuilder.MergeFrom(RequestHeaders);
                }
                input.ReadMessage(subBuilder);
                RequestHeaders = subBuilder;
                break;
              }
              case 34: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
                  subBuilder.MergeFrom(RemoteAddress);
                }
                input.ReadMessage(subBuilder);
                RemoteAddress = subBuilder;
                break;
              }
              case 42: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
                  subBuilder.MergeFrom(GenericKey);
                }
                input.ReadMessage(subBuilder);
                GenericKey = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
                  subBuilder.MergeFrom(HeaderValueMatch);
                }
                input.ReadMessage(subBuilder);
                HeaderValueMatch = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Action message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("source_cluster", "&lt;local service cluster>")
          ///
          /// &lt;local service cluster> is derived from the :option:`--service-cluster` option.
          /// </summary>
          public sealed partial class SourceCluster : pb::IMessage<SourceCluster> {
            private static readonly pb::MessageParser<SourceCluster> _parser = new pb::MessageParser<SourceCluster>(() => new SourceCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<SourceCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster(SourceCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster Clone() {
              return new SourceCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as SourceCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(SourceCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(SourceCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("destination_cluster", "&lt;routed target cluster>")
          ///
          /// Once a request matches against a route table rule, a routed cluster is determined by one of
          /// the following :ref:`route table configuration &lt;envoy_api_msg_RouteConfiguration>`
          /// settings:
          ///
          /// * :ref:`cluster &lt;envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
          ///   to route to.
          /// * :ref:`weighted_clusters &lt;envoy_api_field_route.RouteAction.weighted_clusters>`
          ///   chooses a cluster randomly from a set of clusters with attributed weight.
          /// * :ref:`cluster_header &lt;envoy_api_field_route.RouteAction.cluster_header>` indicates which
          ///   header in the request contains the target cluster.
          /// </summary>
          public sealed partial class DestinationCluster : pb::IMessage<DestinationCluster> {
            private static readonly pb::MessageParser<DestinationCluster> _parser = new pb::MessageParser<DestinationCluster>(() => new DestinationCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<DestinationCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster(DestinationCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster Clone() {
              return new DestinationCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as DestinationCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(DestinationCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(DestinationCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended when a header contains a key that matches the
          /// *header_name*:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("&lt;descriptor_key>", "&lt;header_value_queried_from_header>")
          /// </summary>
          public sealed partial class RequestHeaders : pb::IMessage<RequestHeaders> {
            private static readonly pb::MessageParser<RequestHeaders> _parser = new pb::MessageParser<RequestHeaders>(() => new RequestHeaders());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<RequestHeaders> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders(RequestHeaders other) : this() {
              headerName_ = other.headerName_;
              descriptorKey_ = other.descriptorKey_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders Clone() {
              return new RequestHeaders(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The header name to be queried from the request headers. The header’s
            /// value is used to populate the value of the descriptor entry for the
            /// descriptor_key.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 2;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as RequestHeaders);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(RequestHeaders other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              if (DescriptorKey != other.DescriptorKey) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(RequestHeaders other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor and is populated using the
          /// trusted address from :ref:`x-forwarded-for &lt;config_http_conn_man_headers_x-forwarded-for>`:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("remote_address", "&lt;trusted address from x-forwarded-for>")
          /// </summary>
          public sealed partial class RemoteAddress : pb::IMessage<RemoteAddress> {
            private static readonly pb::MessageParser<RemoteAddress> _parser = new pb::MessageParser<RemoteAddress>(() => new RemoteAddress());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<RemoteAddress> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress(RemoteAddress other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress Clone() {
              return new RemoteAddress(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as RemoteAddress);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(RemoteAddress other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(RemoteAddress other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("generic_key", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class GenericKey : pb::IMessage<GenericKey> {
            private static readonly pb::MessageParser<GenericKey> _parser = new pb::MessageParser<GenericKey>(() => new GenericKey());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<GenericKey> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[4]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey(GenericKey other) : this() {
              descriptorValue_ = other.descriptorValue_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey Clone() {
              return new GenericKey(this);
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as GenericKey);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(GenericKey other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorValue != other.DescriptorValue) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(GenericKey other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("header_match", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class HeaderValueMatch : pb::IMessage<HeaderValueMatch> {
            private static readonly pb::MessageParser<HeaderValueMatch> _parser = new pb::MessageParser<HeaderValueMatch>(() => new HeaderValueMatch());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<HeaderValueMatch> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[5]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch(HeaderValueMatch other) : this() {
              descriptorValue_ = other.descriptorValue_;
              ExpectMatch = other.ExpectMatch;
              headers_ = other.headers_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch Clone() {
              return new HeaderValueMatch(this);
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "expect_match" field.</summary>
            public const int ExpectMatchFieldNumber = 2;
            private static readonly pb::FieldCodec<bool?> _single_expectMatch_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
            private bool? expectMatch_;
            /// <summary>
            /// If set to true, the action will append a descriptor entry when the
            /// request matches the headers. If set to false, the action will append a
            /// descriptor entry when the request does not match the headers. The
            /// default value is true.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool? ExpectMatch {
              get { return expectMatch_; }
              set {
                expectMatch_ = value;
              }
            }

            /// <summary>Field number for the "headers" field.</summary>
            public const int HeadersFieldNumber = 3;
            private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.HeaderMatcher> _repeated_headers_codec
                = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.HeaderMatcher.Parser);
            private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher>();
            /// <summary>
            /// Specifies a set of headers that the rate limit action should match
            /// on. The action will check the request’s headers against all the
            /// specified headers in the config. A match will happen if all the
            /// headers in the config are present in the request with the same values
            /// (or based on presence if the value field is not in the config).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> Headers {
              get { return headers_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as HeaderValueMatch);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(HeaderValueMatch other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorValue != other.DescriptorValue) return false;
              if (ExpectMatch != other.ExpectMatch) return false;
              if(!headers_.Equals(other.headers_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (expectMatch_ != null) hash ^= ExpectMatch.GetHashCode();
              hash ^= headers_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (expectMatch_ != null) {
                _single_expectMatch_codec.WriteTagAndValue(output, ExpectMatch);
              }
              headers_.WriteTo(output, _repeated_headers_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (expectMatch_ != null) {
                size += _single_expectMatch_codec.CalculateSizeWithTag(ExpectMatch);
              }
              size += headers_.CalculateSize(_repeated_headers_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(HeaderValueMatch other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              if (other.expectMatch_ != null) {
                if (expectMatch_ == null || other.ExpectMatch != false) {
                  ExpectMatch = other.ExpectMatch;
                }
              }
              headers_.Add(other.headers_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    bool? value = _single_expectMatch_codec.Read(input);
                    if (expectMatch_ == null || value != false) {
                      ExpectMatch = value;
                    }
                    break;
                  }
                  case 26: {
                    headers_.AddEntriesFrom(input, _repeated_headers_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// .. attention::
  ///
  ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
  ///   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
  ///
  /// .. attention::
  ///
  ///   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
  ///   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
  ///
  ///   .. code-block:: json
  ///
  ///     {
  ///       "name": ":method",
  ///       "value": "POST"
  ///     }
  /// </summary>
  public sealed partial class HeaderMatcher : pb::IMessage<HeaderMatcher> {
    private static readonly pb::MessageParser<HeaderMatcher> _parser = new pb::MessageParser<HeaderMatcher>(() => new HeaderMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HeaderMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher(HeaderMatcher other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      Regex = other.Regex;
      invertMatch_ = other.invertMatch_;
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RegexMatch:
          RegexMatch = other.RegexMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          RangeMatch = other.RangeMatch.Clone();
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher Clone() {
      return new HeaderMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of the header in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private string value_ = "";
    /// <summary>
    /// Specifies the value of the header. If the value is absent a request that
    /// has the name header will match, regardless of the header’s value.
    ///
    /// .. attention::
    ///   Deprecated. Use :ref:`exact_match &lt;envoy_api_field_route.HeaderMatcher.exact_match>` instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 3;
    private static readonly pb::FieldCodec<bool?> _single_regex_codec = pb::FieldCodec.ForStructWrapper<bool>(26);
    private bool? regex_;
    /// <summary>
    /// Specifies whether the header value is a regular
    /// expression or not. Defaults to false. The entire request header value must match the regex. The
    /// rule will not match if only a subsequence of the request header value matches the regex. The
    /// regex grammar used in the value field is defined
    /// `here &lt;http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex *\d{3}* matches the value *123*
    /// * The regex *\d{3}* does not match the value *1234*
    /// * The regex *\d{3}* does not match the value *123.456*
    ///
    /// .. attention::
    ///   Deprecated. Use :ref:`regex_match &lt;envoy_api_field_route.HeaderMatcher.regex_match>` instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Regex {
      get { return regex_; }
      set {
        regex_ = value;
      }
    }

    /// <summary>Field number for the "exact_match" field.</summary>
    public const int ExactMatchFieldNumber = 4;
    /// <summary>
    /// If specified, header match will be performed based on the value of the header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExactMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.ExactMatch;
      }
    }

    /// <summary>Field number for the "regex_match" field.</summary>
    public const int RegexMatchFieldNumber = 5;
    /// <summary>
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex. The regex grammar used in the value field is defined
    /// `here &lt;http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex *\d{3}* matches the value *123*
    /// * The regex *\d{3}* does not match the value *1234*
    /// * The regex *\d{3}* does not match the value *123.456*
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RegexMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.RegexMatch;
      }
    }

    /// <summary>Field number for the "range_match" field.</summary>
    public const int RangeMatchFieldNumber = 6;
    /// <summary>
    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting of
    /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    /// the header value does not represent an integer. Match will fail for empty values, floating
    /// point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
    ///   "-1somestring"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Int64Range RangeMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch ? (global::Envoy.Type.Int64Range) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.RangeMatch;
      }
    }

    /// <summary>Field number for the "present_match" field.</summary>
    public const int PresentMatchFieldNumber = 7;
    /// <summary>
    /// If specified, header match will be be performed based on whether the header is in the
    /// request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PresentMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch ? (bool) headerMatchSpecifier_ : false; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PresentMatch;
      }
    }

    /// <summary>Field number for the "prefix_match" field.</summary>
    public const int PrefixMatchFieldNumber = 9;
    /// <summary>
    /// If specified, header match will be performed based on the prefix of the header value.
    /// Note: empty prefix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PrefixMatch;
      }
    }

    /// <summary>Field number for the "suffix_match" field.</summary>
    public const int SuffixMatchFieldNumber = 10;
    /// <summary>
    /// If specified, header match will be performed based on the suffix of the header value.
    /// Note: empty suffix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SuffixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.SuffixMatch;
      }
    }

    /// <summary>Field number for the "invert_match" field.</summary>
    public const int InvertMatchFieldNumber = 8;
    private bool invertMatch_;
    /// <summary>
    /// If specified, the match result will be inverted before checking. Defaults to false.
    ///
    /// Examples:
    ///
    /// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
    /// * The range [-10,0) will match the value -1, so it will not match when inverted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool InvertMatch {
      get { return invertMatch_; }
      set {
        invertMatch_ = value;
      }
    }

    private object headerMatchSpecifier_;
    /// <summary>Enum of possible cases for the "header_match_specifier" oneof.</summary>
    public enum HeaderMatchSpecifierOneofCase {
      None = 0,
      ExactMatch = 4,
      RegexMatch = 5,
      RangeMatch = 6,
      PresentMatch = 7,
      PrefixMatch = 9,
      SuffixMatch = 10,
    }
    private HeaderMatchSpecifierOneofCase headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatchSpecifierOneofCase HeaderMatchSpecifierCase {
      get { return headerMatchSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeaderMatchSpecifier() {
      headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
      headerMatchSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HeaderMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HeaderMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      if (Regex != other.Regex) return false;
      if (ExactMatch != other.ExactMatch) return false;
      if (RegexMatch != other.RegexMatch) return false;
      if (!object.Equals(RangeMatch, other.RangeMatch)) return false;
      if (PresentMatch != other.PresentMatch) return false;
      if (PrefixMatch != other.PrefixMatch) return false;
      if (SuffixMatch != other.SuffixMatch) return false;
      if (InvertMatch != other.InvertMatch) return false;
      if (HeaderMatchSpecifierCase != other.HeaderMatchSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (regex_ != null) hash ^= Regex.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) hash ^= ExactMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) hash ^= RegexMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) hash ^= RangeMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) hash ^= PresentMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) hash ^= PrefixMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) hash ^= SuffixMatch.GetHashCode();
      if (InvertMatch != false) hash ^= InvertMatch.GetHashCode();
      hash ^= (int) headerMatchSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (regex_ != null) {
        _single_regex_codec.WriteTagAndValue(output, Regex);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        output.WriteRawTag(34);
        output.WriteString(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) {
        output.WriteRawTag(42);
        output.WriteString(RegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        output.WriteRawTag(50);
        output.WriteMessage(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(56);
        output.WriteBool(PresentMatch);
      }
      if (InvertMatch != false) {
        output.WriteRawTag(64);
        output.WriteBool(InvertMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        output.WriteRawTag(74);
        output.WriteString(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        output.WriteRawTag(82);
        output.WriteString(SuffixMatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (regex_ != null) {
        size += _single_regex_codec.CalculateSizeWithTag(Regex);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        size += 1 + 1;
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SuffixMatch);
      }
      if (InvertMatch != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HeaderMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      if (other.regex_ != null) {
        if (regex_ == null || other.Regex != false) {
          Regex = other.Regex;
        }
      }
      if (other.InvertMatch != false) {
        InvertMatch = other.InvertMatch;
      }
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RegexMatch:
          RegexMatch = other.RegexMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          if (RangeMatch == null) {
            RangeMatch = new global::Envoy.Type.Int64Range();
          }
          RangeMatch.MergeFrom(other.RangeMatch);
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            bool? value = _single_regex_codec.Read(input);
            if (regex_ == null || value != false) {
              Regex = value;
            }
            break;
          }
          case 34: {
            ExactMatch = input.ReadString();
            break;
          }
          case 42: {
            RegexMatch = input.ReadString();
            break;
          }
          case 50: {
            global::Envoy.Type.Int64Range subBuilder = new global::Envoy.Type.Int64Range();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
              subBuilder.MergeFrom(RangeMatch);
            }
            input.ReadMessage(subBuilder);
            RangeMatch = subBuilder;
            break;
          }
          case 56: {
            PresentMatch = input.ReadBool();
            break;
          }
          case 64: {
            InvertMatch = input.ReadBool();
            break;
          }
          case 74: {
            PrefixMatch = input.ReadString();
            break;
          }
          case 82: {
            SuffixMatch = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Query parameter matching treats the query string of a request's :path header
  /// as an ampersand-separated list of keys and/or key=value elements.
  /// </summary>
  public sealed partial class QueryParameterMatcher : pb::IMessage<QueryParameterMatcher> {
    private static readonly pb::MessageParser<QueryParameterMatcher> _parser = new pb::MessageParser<QueryParameterMatcher>(() => new QueryParameterMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<QueryParameterMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher(QueryParameterMatcher other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      Regex = other.Regex;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher Clone() {
      return new QueryParameterMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of a key that must be present in the requested
    /// *path*'s query string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private string value_ = "";
    /// <summary>
    /// Specifies the value of the key. If the value is absent, a request
    /// that contains the key in its query string will match, whether the
    /// key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_regex_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? regex_;
    /// <summary>
    /// Specifies whether the query parameter value is a regular expression.
    /// Defaults to false. The entire query parameter value (i.e., the part to
    /// the right of the equals sign in "key=value") must match the regex.
    /// E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Regex {
      get { return regex_; }
      set {
        regex_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as QueryParameterMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(QueryParameterMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      if (Regex != other.Regex) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (regex_ != null) hash ^= Regex.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Value);
      }
      if (regex_ != null) {
        _single_regex_codec.WriteTagAndValue(output, Regex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (regex_ != null) {
        size += _single_regex_codec.CalculateSizeWithTag(Regex);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(QueryParameterMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      if (other.regex_ != null) {
        if (regex_ == null || other.Regex != false) {
          Regex = other.Regex;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Value = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_regex_codec.Read(input);
            if (regex_ == null || value != false) {
              Regex = value;
            }
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
