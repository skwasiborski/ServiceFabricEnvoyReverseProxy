// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/rbac/v2alpha/rbac.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Rbac.V2Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/rbac/v2alpha/rbac.proto</summary>
  public static partial class RbacReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/rbac/v2alpha/rbac.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RbacReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiRlbnZveS9jb25maWcvcmJhYy92MmFscGhhL3JiYWMucHJvdG8SGWVudm95",
            "LmNvbmZpZy5yYmFjLnYyYWxwaGEaF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3Rv",
            "Gh9lbnZveS9hcGkvdjIvY29yZS9hZGRyZXNzLnByb3RvGh5lbnZveS9hcGkv",
            "djIvcm91dGUvcm91dGUucHJvdG8i8gEKBFJCQUMSNgoGYWN0aW9uGAEgASgO",
            "MiYuZW52b3kuY29uZmlnLnJiYWMudjJhbHBoYS5SQkFDLkFjdGlvbhI/Cghw",
            "b2xpY2llcxgCIAMoCzItLmVudm95LmNvbmZpZy5yYmFjLnYyYWxwaGEuUkJB",
            "Qy5Qb2xpY2llc0VudHJ5GlIKDVBvbGljaWVzRW50cnkSCwoDa2V5GAEgASgJ",
            "EjAKBXZhbHVlGAIgASgLMiEuZW52b3kuY29uZmlnLnJiYWMudjJhbHBoYS5Q",
            "b2xpY3k6AjgBIh0KBkFjdGlvbhIJCgVBTExPVxAAEggKBERFTlkQASKWAQoG",
            "UG9saWN5EkYKC3Blcm1pc3Npb25zGAEgAygLMiUuZW52b3kuY29uZmlnLnJi",
            "YWMudjJhbHBoYS5QZXJtaXNzaW9uQgq66cADBZIBAggBEkQKCnByaW5jaXBh",
            "bHMYAiADKAsyJC5lbnZveS5jb25maWcucmJhYy52MmFscGhhLlByaW5jaXBh",
            "bEIKuunAAwWSAQIIASKTAwoKUGVybWlzc2lvbhI+CglhbmRfcnVsZXMYASAB",
            "KAsyKS5lbnZveS5jb25maWcucmJhYy52MmFscGhhLlBlcm1pc3Npb24uU2V0",
            "SAASPQoIb3JfcnVsZXMYAiABKAsyKS5lbnZveS5jb25maWcucmJhYy52MmFs",
            "cGhhLlBlcm1pc3Npb24uU2V0SAASGAoDYW55GAMgASgIQgm66cADBGoCCAFI",
            "ABIzCgZoZWFkZXIYBCABKAsyIS5lbnZveS5hcGkudjIucm91dGUuSGVhZGVy",
            "TWF0Y2hlckgAEjYKDmRlc3RpbmF0aW9uX2lwGAUgASgLMhwuZW52b3kuYXBp",
            "LnYyLmNvcmUuQ2lkclJhbmdlSAASJwoQZGVzdGluYXRpb25fcG9ydBgGIAEo",
            "DUILuunAAwYqBBj//wNIABpHCgNTZXQSQAoFcnVsZXMYASADKAsyJS5lbnZv",
            "eS5jb25maWcucmJhYy52MmFscGhhLlBlcm1pc3Npb25CCrrpwAMFkgECCAFC",
            "DQoEcnVsZRIFuOnAAwEizQMKCVByaW5jaXBhbBI7CgdhbmRfaWRzGAEgASgL",
            "MiguZW52b3kuY29uZmlnLnJiYWMudjJhbHBoYS5QcmluY2lwYWwuU2V0SAAS",
            "OgoGb3JfaWRzGAIgASgLMiguZW52b3kuY29uZmlnLnJiYWMudjJhbHBoYS5Q",
            "cmluY2lwYWwuU2V0SAASGAoDYW55GAMgASgIQgm66cADBGoCCAFIABJLCg1h",
            "dXRoZW50aWNhdGVkGAQgASgLMjIuZW52b3kuY29uZmlnLnJiYWMudjJhbHBo",
            "YS5QcmluY2lwYWwuQXV0aGVudGljYXRlZEgAEjEKCXNvdXJjZV9pcBgFIAEo",
            "CzIcLmVudm95LmFwaS52Mi5jb3JlLkNpZHJSYW5nZUgAEjMKBmhlYWRlchgG",
            "IAEoCzIhLmVudm95LmFwaS52Mi5yb3V0ZS5IZWFkZXJNYXRjaGVySAAaRAoD",
            "U2V0Ej0KA2lkcxgBIAMoCzIkLmVudm95LmNvbmZpZy5yYmFjLnYyYWxwaGEu",
            "UHJpbmNpcGFsQgq66cADBZIBAggBGh0KDUF1dGhlbnRpY2F0ZWQSDAoEbmFt",
            "ZRgBIAEoCUITCgppZGVudGlmaWVyEgW46cADAUIJWgd2MmFscGhhYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Validate.ValidateReflection.Descriptor, global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Route.RouteReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.RBAC), global::Envoy.Config.Rbac.V2Alpha.RBAC.Parser, new[]{ "Action", "Policies" }, null, new[]{ typeof(global::Envoy.Config.Rbac.V2Alpha.RBAC.Types.Action) }, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Policy), global::Envoy.Config.Rbac.V2Alpha.Policy.Parser, new[]{ "Permissions", "Principals" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Permission), global::Envoy.Config.Rbac.V2Alpha.Permission.Parser, new[]{ "AndRules", "OrRules", "Any", "Header", "DestinationIp", "DestinationPort" }, new[]{ "Rule" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set), global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set.Parser, new[]{ "Rules" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Principal), global::Envoy.Config.Rbac.V2Alpha.Principal.Parser, new[]{ "AndIds", "OrIds", "Any", "Authenticated", "SourceIp", "Header" }, new[]{ "Identifier" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set), global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set.Parser, new[]{ "Ids" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated), global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated.Parser, new[]{ "Name" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Role Based Access Control (RBAC) provides service-level and method-level access control for a
  /// service. RBAC policies are additive. The policies are examined in order. A request is allowed
  /// once a matching policy is found (suppose the `action` is ALLOW).
  ///
  /// Here is an example of RBAC configuration. It has two policies:
  ///
  /// * Service account "cluster.local/ns/default/sa/admin" has full access (empty permission entry
  ///   means full access) to the service.
  ///
  /// * Any user (empty principal entry means any user) can read ("GET") the service at paths with
  ///   prefix "/products" or suffix "/reviews" when request header "version" set to either "v1" or
  ///   "v2".
  ///
  ///  .. code-block:: yaml
  ///
  ///   action: ALLOW
  ///   policies:
  ///     "service-admin":
  ///       permissions:
  ///         - any: true
  ///       principals:
  ///         - authenticated: { name: "cluster.local/ns/default/sa/admin" }
  ///         - authenticated: { name: "cluster.local/ns/default/sa/superuser" }
  ///     "product-viewer":
  ///       permissions:
  ///           - and_rules:
  ///               rules:
  ///                 - header: { name: ":method", exact_match: "GET" }
  ///                 - header: { name: ":path", regex_match: "/products(/.*)?" }
  ///                 - or_rules:
  ///                     rules:
  ///                       - destination_port: 80
  ///                       - destination_port: 443
  ///       principals:
  ///         - any: true
  /// </summary>
  public sealed partial class RBAC : pb::IMessage<RBAC> {
    private static readonly pb::MessageParser<RBAC> _parser = new pb::MessageParser<RBAC>(() => new RBAC());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RBAC> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2Alpha.RbacReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC(RBAC other) : this() {
      action_ = other.action_;
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC Clone() {
      return new RBAC(this);
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 1;
    private global::Envoy.Config.Rbac.V2Alpha.RBAC.Types.Action action_ = 0;
    /// <summary>
    /// The action to take if a policy matches. The request is allowed if and only if:
    ///
    ///   * `action` is "ALLOWED" and at least one policy matches
    ///   * `action` is "DENY" and none of the policies match
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.RBAC.Types.Action Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2Alpha.Policy>.Codec _map_policies_codec
        = new pbc::MapField<string, global::Envoy.Config.Rbac.V2Alpha.Policy>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2Alpha.Policy.Parser), 18);
    private readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2Alpha.Policy> policies_ = new pbc::MapField<string, global::Envoy.Config.Rbac.V2Alpha.Policy>();
    /// <summary>
    /// Maps from policy name to policy. A match occurs when at least one policy matches the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Envoy.Config.Rbac.V2Alpha.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RBAC);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RBAC other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Action != other.Action) return false;
      if (!Policies.Equals(other.Policies)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Action != 0) hash ^= Action.GetHashCode();
      hash ^= Policies.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Action != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Action != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Action);
      }
      size += policies_.CalculateSize(_map_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RBAC other) {
      if (other == null) {
        return;
      }
      if (other.Action != 0) {
        Action = other.Action;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            action_ = (global::Envoy.Config.Rbac.V2Alpha.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(input, _map_policies_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RBAC message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Should we do safe-list or block-list style access control?
      /// </summary>
      public enum Action {
        /// <summary>
        /// The policies grant access to principals. The rest is denied. This is safe-list style
        /// access control. This is the default type.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// The policies deny access to principals. The rest is allowed. This is block-list style
        /// access control.
        /// </summary>
        [pbr::OriginalName("DENY")] Deny = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
  /// and only if at least one of its permissions match the action taking place AND at least one of its
  /// principals match the downstream.
  /// </summary>
  public sealed partial class Policy : pb::IMessage<Policy> {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2Alpha.RbacReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy(Policy other) : this() {
      permissions_ = other.permissions_.Clone();
      principals_ = other.principals_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2Alpha.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2Alpha.Permission.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission> permissions_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission>();
    /// <summary>
    /// Required. The set of permissions that define a role. Each permission is matched with OR
    /// semantics. To match all actions for this policy, a single Permission with the `any` field set
    /// to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "principals" field.</summary>
    public const int PrincipalsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2Alpha.Principal> _repeated_principals_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2Alpha.Principal.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal> principals_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal>();
    /// <summary>
    /// Required. The set of principals that are assigned/denied the role based on “action”. Each
    /// principal is matched with OR semantics. To match all downstreams for this policy, a single
    /// Principal with the `any` field set to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal> Principals {
      get { return principals_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!permissions_.Equals(other.permissions_)) return false;
      if(!principals_.Equals(other.principals_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= permissions_.GetHashCode();
      hash ^= principals_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      permissions_.WriteTo(output, _repeated_permissions_codec);
      principals_.WriteTo(output, _repeated_principals_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      size += principals_.CalculateSize(_repeated_principals_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      permissions_.Add(other.permissions_);
      principals_.Add(other.principals_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(input, _repeated_principals_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Permission defines an action (or actions) that a principal can take.
  /// </summary>
  public sealed partial class Permission : pb::IMessage<Permission> {
    private static readonly pb::MessageParser<Permission> _parser = new pb::MessageParser<Permission>(() => new Permission());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Permission> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2Alpha.RbacReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission(Permission other) : this() {
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          AndRules = other.AndRules.Clone();
          break;
        case RuleOneofCase.OrRules:
          OrRules = other.OrRules.Clone();
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case RuleOneofCase.DestinationIp:
          DestinationIp = other.DestinationIp.Clone();
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission Clone() {
      return new Permission(this);
    }

    /// <summary>Field number for the "and_rules" field.</summary>
    public const int AndRulesFieldNumber = 1;
    /// <summary>
    /// A set of rules that all must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set AndRules {
      get { return ruleCase_ == RuleOneofCase.AndRules ? (global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.AndRules;
      }
    }

    /// <summary>Field number for the "or_rules" field.</summary>
    public const int OrRulesFieldNumber = 2;
    /// <summary>
    /// A set of rules where at least one must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set OrRules {
      get { return ruleCase_ == RuleOneofCase.OrRules ? (global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.OrRules;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Any {
      get { return ruleCase_ == RuleOneofCase.Any ? (bool) rule_ : false; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.Any;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 4;
    /// <summary>
    /// A header (or psuedo-header such as :path or :method) on the incoming HTTP request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return ruleCase_ == RuleOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Header;
      }
    }

    /// <summary>Field number for the "destination_ip" field.</summary>
    public const int DestinationIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the destination IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.CidrRange DestinationIp {
      get { return ruleCase_ == RuleOneofCase.DestinationIp ? (global::Envoy.Api.V2.Core.CidrRange) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.DestinationIp;
      }
    }

    /// <summary>Field number for the "destination_port" field.</summary>
    public const int DestinationPortFieldNumber = 6;
    /// <summary>
    /// A port number that describes the destination port connecting to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DestinationPort {
      get { return ruleCase_ == RuleOneofCase.DestinationPort ? (uint) rule_ : 0; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.DestinationPort;
      }
    }

    private object rule_;
    /// <summary>Enum of possible cases for the "rule" oneof.</summary>
    public enum RuleOneofCase {
      None = 0,
      AndRules = 1,
      OrRules = 2,
      Any = 3,
      Header = 4,
      DestinationIp = 5,
      DestinationPort = 6,
    }
    private RuleOneofCase ruleCase_ = RuleOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleOneofCase RuleCase {
      get { return ruleCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRule() {
      ruleCase_ = RuleOneofCase.None;
      rule_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Permission);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Permission other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndRules, other.AndRules)) return false;
      if (!object.Equals(OrRules, other.OrRules)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(DestinationIp, other.DestinationIp)) return false;
      if (DestinationPort != other.DestinationPort) return false;
      if (RuleCase != other.RuleCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ruleCase_ == RuleOneofCase.AndRules) hash ^= AndRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.OrRules) hash ^= OrRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Any) hash ^= Any.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Header) hash ^= Header.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationIp) hash ^= DestinationIp.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationPort) hash ^= DestinationPort.GetHashCode();
      hash ^= (int) ruleCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ruleCase_ == RuleOneofCase.AndRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        size += 1 + 1;
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DestinationPort);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Permission other) {
      if (other == null) {
        return;
      }
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          if (AndRules == null) {
            AndRules = new global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set();
          }
          AndRules.MergeFrom(other.AndRules);
          break;
        case RuleOneofCase.OrRules:
          if (OrRules == null) {
            OrRules = new global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set();
          }
          OrRules.MergeFrom(other.OrRules);
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case RuleOneofCase.DestinationIp:
          if (DestinationIp == null) {
            DestinationIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          DestinationIp.MergeFrom(other.DestinationIp);
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2Alpha.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Permission message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set> {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2Alpha.Permission.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set(Set other) : this() {
          rules_ = other.rules_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "rules" field.</summary>
        public const int RulesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2Alpha.Permission> _repeated_rules_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2Alpha.Permission.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission> rules_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Permission> Rules {
          get { return rules_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!rules_.Equals(other.rules_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= rules_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          rules_.WriteTo(output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += rules_.CalculateSize(_repeated_rules_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          rules_.Add(other.rules_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                rules_.AddEntriesFrom(input, _repeated_rules_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Principal defines an identity or a group of identities for a downstream subject.
  /// </summary>
  public sealed partial class Principal : pb::IMessage<Principal> {
    private static readonly pb::MessageParser<Principal> _parser = new pb::MessageParser<Principal>(() => new Principal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Principal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2Alpha.RbacReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal(Principal other) : this() {
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          AndIds = other.AndIds.Clone();
          break;
        case IdentifierOneofCase.OrIds:
          OrIds = other.OrIds.Clone();
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          Authenticated = other.Authenticated.Clone();
          break;
        case IdentifierOneofCase.SourceIp:
          SourceIp = other.SourceIp.Clone();
          break;
        case IdentifierOneofCase.Header:
          Header = other.Header.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal Clone() {
      return new Principal(this);
    }

    /// <summary>Field number for the "and_ids" field.</summary>
    public const int AndIdsFieldNumber = 1;
    /// <summary>
    /// A set of identifiers that all must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set AndIds {
      get { return identifierCase_ == IdentifierOneofCase.AndIds ? (global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.AndIds;
      }
    }

    /// <summary>Field number for the "or_ids" field.</summary>
    public const int OrIdsFieldNumber = 2;
    /// <summary>
    /// A set of identifiers at least one must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set OrIds {
      get { return identifierCase_ == IdentifierOneofCase.OrIds ? (global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.OrIds;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Any {
      get { return identifierCase_ == IdentifierOneofCase.Any ? (bool) identifier_ : false; }
      set {
        identifier_ = value;
        identifierCase_ = IdentifierOneofCase.Any;
      }
    }

    /// <summary>Field number for the "authenticated" field.</summary>
    public const int AuthenticatedFieldNumber = 4;
    /// <summary>
    /// Authenticated attributes that identify the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated Authenticated {
      get { return identifierCase_ == IdentifierOneofCase.Authenticated ? (global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Authenticated;
      }
    }

    /// <summary>Field number for the "source_ip" field.</summary>
    public const int SourceIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the downstream IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.CidrRange SourceIp {
      get { return identifierCase_ == IdentifierOneofCase.SourceIp ? (global::Envoy.Api.V2.Core.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.SourceIp;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 6;
    /// <summary>
    /// A header (or psuedo-header such as :path or :method) on the incoming HTTP request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return identifierCase_ == IdentifierOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Header;
      }
    }

    private object identifier_;
    /// <summary>Enum of possible cases for the "identifier" oneof.</summary>
    public enum IdentifierOneofCase {
      None = 0,
      AndIds = 1,
      OrIds = 2,
      Any = 3,
      Authenticated = 4,
      SourceIp = 5,
      Header = 6,
    }
    private IdentifierOneofCase identifierCase_ = IdentifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IdentifierOneofCase IdentifierCase {
      get { return identifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIdentifier() {
      identifierCase_ = IdentifierOneofCase.None;
      identifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Principal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Principal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndIds, other.AndIds)) return false;
      if (!object.Equals(OrIds, other.OrIds)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Authenticated, other.Authenticated)) return false;
      if (!object.Equals(SourceIp, other.SourceIp)) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (IdentifierCase != other.IdentifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (identifierCase_ == IdentifierOneofCase.AndIds) hash ^= AndIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.OrIds) hash ^= OrIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Any) hash ^= Any.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Authenticated) hash ^= Authenticated.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.SourceIp) hash ^= SourceIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Header) hash ^= Header.GetHashCode();
      hash ^= (int) identifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        size += 1 + 1;
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Principal other) {
      if (other == null) {
        return;
      }
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          if (AndIds == null) {
            AndIds = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set();
          }
          AndIds.MergeFrom(other.AndIds);
          break;
        case IdentifierOneofCase.OrIds:
          if (OrIds == null) {
            OrIds = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set();
          }
          OrIds.MergeFrom(other.OrIds);
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          if (Authenticated == null) {
            Authenticated = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated();
          }
          Authenticated.MergeFrom(other.Authenticated);
          break;
        case IdentifierOneofCase.SourceIp:
          if (SourceIp == null) {
            SourceIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          SourceIp.MergeFrom(other.SourceIp);
          break;
        case IdentifierOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V2Alpha.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Principal message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set> {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2Alpha.Principal.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set(Set other) : this() {
          ids_ = other.ids_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "ids" field.</summary>
        public const int IdsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2Alpha.Principal> _repeated_ids_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2Alpha.Principal.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal> ids_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2Alpha.Principal> Ids {
          get { return ids_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!ids_.Equals(other.ids_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= ids_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          ids_.WriteTo(output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += ids_.CalculateSize(_repeated_ids_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          ids_.Add(other.ids_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ids_.AddEntriesFrom(input, _repeated_ids_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Authentication attributes for a downstream.
      /// </summary>
      public sealed partial class Authenticated : pb::IMessage<Authenticated> {
        private static readonly pb::MessageParser<Authenticated> _parser = new pb::MessageParser<Authenticated>(() => new Authenticated());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Authenticated> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2Alpha.Principal.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated(Authenticated other) : this() {
          name_ = other.name_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated Clone() {
          return new Authenticated(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the principal. If set, the URI SAN is used from the certificate, otherwise the
        /// subject field is used. If unset, it applies to any user that is authenticated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Authenticated);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Authenticated other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Authenticated other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
